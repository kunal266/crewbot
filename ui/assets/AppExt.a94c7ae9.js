var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import { V as View$1, A as Api, S as Supports, a as SvelteComponent, i as init, s as safe_not_equal, T, e as element, b as space, t as text, c as attr, d as src_url_equal, u as urls, f as set_style, g as insert, h as append, l as listen, p as prevent_default, n as noop, j as detach, k as getContext$1, m as component_subscribe, o as onMount, q as binding_callbacks, r as destroy_each, v as set_data, w as create_slot, x as create_component, y as mount_component, z as update_slot_base, B as get_all_dirty_from_scope, C as get_slot_changes, D as transition_in, E as transition_out, F as destroy_component, G as bubble, H as empty, I as group_outros, J as check_outros, K as C, L as directive, N as NodePart, M as createMarker, O as reparentNodes, P as removeNodes, Q as Editor, R as Model$2, U as Msg, W as Base$3, X as get_store_value, Y as html, Z as ModelClient, _ as SPRINTF, $ as toggle_class, a0 as run_all, a1 as tick, a2 as action_destroyer, a3 as createEventDispatcher, a4 as onDestroy, a5 as afterUpdate, a6 as handle_promise, a7 as update_await_block_branch, a8 as set_input_value, a9 as update_keyed_each, aa as outro_and_destroy_block, ab as destroy_block, ac as base, ad as is_function, ae as subscribe, af as svg_element, ag as compute_slots, ah as flush, ai as null_to_empty, aj as add_render_callback, ak as select_option, al as select_value, am as compute_rest_props, an as assign$1, ao as exclude_internal_props, ap as bind$2, aq as add_flush_callback, ar as set_attributes, as as get_spread_update, at as get_spread_object, au as getDef, av as defs, aw as set_svg_attributes, ax as hasNumeric, ay as render, az as i18n, aA as setContext, aB as set_store_value, aC as Core$1, aD as loadLang } from "./sieve.d6bf62de.js";
import { p as params, d as derived, w as writable, a as push$1, c as checkSieveConstraint, i as instance$1Q, S as SearchForm, b as Selector$4, q as querystring, l as location$1, M as ModelLabel, e as Self, r as replace$1, R as Router } from "./Selector.665da9ec.js";
import { s as serviceProxy, _ as __vitePreload, f as formatTime, a as formatTimeV2 } from "./service.511decc4.js";
import { E as ElWrap, c as clickOutside$1, k as keypressEscape$1, M as MenuItem$1 } from "./escape-key.178aa387.js";
var inbox = "";
var langs = [{
  locale: "en-US",
  label: "English (US)"
}, {
  locale: "de",
  label: "Deutsch"
}, {
  locale: "fr",
  label: "Fran\xE7ais"
}, {
  locale: "ru",
  label: "\u0420\u0443\u0441\u0441\u043A\u0438\u0439"
}, {
  locale: "ja",
  label: "\u65E5\u672C\u8A9E"
}, {
  locale: "zh",
  label: "\u7B80\u4F53\u4E2D\u6587"
}, {
  locale: "es",
  label: "Espa\xF1ol"
}, {
  locale: "it",
  label: "Italiano"
}, {
  locale: "pl",
  label: "Polskie"
}, {
  locale: "pt",
  label: "Portugu\xEAs do Brasil"
}, {
  locale: "sr",
  label: "\u0421\u0440\u043F\u0441\u043A\u0438"
}];
const _$a = window._;
if (!_$a) {
  throw new Error("ADD _");
}
const $$a = window.jQuery;
if (!$$a) {
  throw new Error("ADD jQuery");
}
const LangPref = View$1.Dropdown.extend({
  getLocale: function() {
    return USER && USER.locale || LOCALE;
  },
  getLabel: function(locale) {
    const lang = _$a.findWhere(langs, { locale });
    return lang.label;
  },
  postInit: function(options) {
    this.menu = new View$1.Menu({
      items: _$a.map(langs, function(lang) {
        return {
          label: lang.label,
          data: {
            locale: lang.locale
          }
        };
      })
    });
    this.menu.on("click", this.onClick);
    this.setLabel("");
    this.$el.attr({ title: "Language" });
  },
  onClick: async function(data, event) {
    const locale = data.locale;
    event.preventDefault();
    if (Supports.agents.local) {
      const id2 = await serviceProxy.auth.getId();
      await serviceProxy.store.Prefs.set("locale", locale);
      if (id2) {
        Api.api("/users", "PUT", {
          id: id2,
          locale
        }, async function() {
          await serviceProxy.SyncMan._syncStore(serviceProxy.store.UserStore);
          location.reload();
        });
      } else {
        location.reload();
      }
    } else {
      if (USER) {
        Api.api("/users", "PUT", { locale }, function() {
          location.reload();
        });
      }
    }
    return true;
  },
  renderAction: function() {
    return A({
      "class": "ripple vbar-tooltip",
      "href": "#",
      "data-toggle": "dropdown",
      "data-html": "true"
    }, I({
      "class": "fa fa-language",
      "aria-hidden": "true"
    }));
  }
});
function get_each_context$r(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i2];
  return child_ctx;
}
function create_else_block_1$6(ctx) {
  let div;
  let a;
  let t0;
  let ul;
  let li;
  let t2;
  let each_value = ctx[2];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$r(get_each_context$r(ctx, each_value, i2));
  }
  return {
    c() {
      div = element("div");
      a = element("a");
      a.innerHTML = `<i class="fa fa-list" aria-hidden="true"></i>`;
      t0 = space();
      ul = element("ul");
      li = element("li");
      li.textContent = "Watchlists";
      t2 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(a, "class", "dropdown-toggle");
      attr(a, "data-toggle", "dropdown");
      attr(a, "href", "#");
      attr(li, "class", "dropdown-header uppercase");
      attr(ul, "class", "dropdown-menu");
      attr(ul, "role", "menu");
      set_style(ul, "bottom", "initial");
      attr(div, "class", "dropdown");
      attr(div, "title", "Watchlist");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, a);
      append(div, t0);
      append(div, ul);
      append(ul, li);
      append(ul, t2);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(ul, null);
      }
    },
    p(ctx2, dirty) {
      if (dirty & 4) {
        each_value = ctx2[2];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$r(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$r(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(ul, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_if_block_3$b(ctx) {
  let a;
  let i2;
  return {
    c() {
      a = element("a");
      i2 = element("i");
      attr(i2, "class", "fa fa-list");
      attr(i2, "aria-hidden", "true");
      attr(a, "title", "Watchlist");
      attr(a, "href", urls.watchlist);
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, i2);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(a);
    }
  };
}
function create_each_block$r(ctx) {
  let li;
  let a;
  let t_value = ctx[11].name + "";
  let t;
  let a_href_value;
  return {
    c() {
      li = element("li");
      a = element("a");
      t = text(t_value);
      attr(a, "href", a_href_value = ctx[11].href);
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, a);
      append(a, t);
    },
    p(ctx2, dirty) {
      if (dirty & 4 && t_value !== (t_value = ctx2[11].name + ""))
        set_data(t, t_value);
      if (dirty & 4 && a_href_value !== (a_href_value = ctx2[11].href)) {
        attr(a, "href", a_href_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(li);
    }
  };
}
function create_else_block$w(ctx) {
  let a;
  let t;
  return {
    c() {
      a = element("a");
      t = text("Sign In");
      attr(a, "role", "menuitem");
      attr(a, "href", urls.login);
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, t);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(a);
    }
  };
}
function create_if_block_2$j(ctx) {
  let a;
  let t0;
  let em;
  let t1_value = ctx[0].name + "";
  let t1;
  let t2;
  let mounted;
  let dispose;
  return {
    c() {
      a = element("a");
      t0 = text("Sign Out (");
      em = element("em");
      t1 = text(t1_value);
      t2 = text(")");
      attr(a, "role", "menuitem");
      attr(a, "href", urls.logout);
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, t0);
      append(a, em);
      append(em, t1);
      append(a, t2);
      if (!mounted) {
        dispose = listen(a, "click", ctx[5]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t1_value !== (t1_value = ctx2[0].name + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(a);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$x(ctx) {
  let li;
  let a;
  let t_value = T("l_billing") + "";
  let t;
  return {
    c() {
      li = element("li");
      a = element("a");
      t = text(t_value);
      attr(a, "href", urls.billing);
      attr(a, "target", "_blank");
      attr(a, "role", "menuitem");
      attr(li, "role", "presentation");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, a);
      append(a, t);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(li);
    }
  };
}
function create_if_block$S(ctx) {
  let li;
  let a;
  let t_value = T("l_admin") + "";
  let t;
  return {
    c() {
      li = element("li");
      a = element("a");
      t = text(t_value);
      attr(a, "href", urls.admin);
      attr(a, "role", "menuitem");
      attr(a, "target", "_blank");
      attr(li, "role", "presentation");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, a);
      append(a, t);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(li);
    }
  };
}
function create_fragment$1X(ctx) {
  let div4;
  let div3;
  let a0;
  let img;
  let img_src_value;
  let t0;
  let t1;
  let a1;
  let i0;
  let t2;
  let a2;
  let i1;
  let t3;
  let a3;
  let i2;
  let t4;
  let i3;
  let t5;
  let a4;
  let t6;
  let div1;
  let a5;
  let i5;
  let t7;
  let div0;
  let t8;
  let div2;
  let a6;
  let t9;
  let ul;
  let li0;
  let t10;
  let li1;
  let t11;
  let li2;
  let a7;
  let t13;
  let li3;
  let a8;
  let t14_value = T("l_settings") + "";
  let t14;
  let t15;
  let t16;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (ctx2[2].length == 1)
      return create_if_block_3$b;
    return create_else_block_1$6;
  }
  let current_block_type = select_block_type(ctx);
  let if_block0 = current_block_type(ctx);
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[3].isLoggedIn())
      return create_if_block_2$j;
    return create_else_block$w;
  }
  let current_block_type_1 = select_block_type_1(ctx);
  let if_block1 = current_block_type_1(ctx);
  let if_block2 = !ctx[0].account_id && create_if_block_1$x();
  let if_block3 = ctx[0].role == "admin" && create_if_block$S();
  return {
    c() {
      div4 = element("div");
      div3 = element("div");
      a0 = element("a");
      img = element("img");
      t0 = space();
      if_block0.c();
      t1 = space();
      a1 = element("a");
      i0 = element("i");
      t2 = space();
      a2 = element("a");
      i1 = element("i");
      t3 = space();
      a3 = element("a");
      i2 = element("i");
      t4 = space();
      i3 = element("i");
      t5 = space();
      a4 = element("a");
      a4.innerHTML = `<i class="fa fa-rocket" aria-hidden="true"></i>`;
      t6 = space();
      div1 = element("div");
      a5 = element("a");
      i5 = element("i");
      t7 = space();
      div0 = element("div");
      t8 = space();
      div2 = element("div");
      a6 = element("a");
      a6.innerHTML = `<i class="fa fa-cog" aria-hidden="true"></i>`;
      t9 = space();
      ul = element("ul");
      li0 = element("li");
      if_block1.c();
      t10 = space();
      li1 = element("li");
      t11 = space();
      li2 = element("li");
      a7 = element("a");
      a7.textContent = `${T("l_support")}`;
      t13 = space();
      li3 = element("li");
      a8 = element("a");
      t14 = text(t14_value);
      t15 = space();
      if (if_block2)
        if_block2.c();
      t16 = space();
      if (if_block3)
        if_block3.c();
      attr(img, "height", "38");
      attr(img, "alt", "distill-logo");
      if (!src_url_equal(img.src, img_src_value = "./img/distill_logo_inverted.svg"))
        attr(img, "src", img_src_value);
      attr(a0, "class", "xside-logo");
      attr(a0, "target", "_blank");
      attr(a0, "rel", "noopener");
      attr(a0, "title", "Distill.io");
      attr(a0, "href", urls.website);
      attr(i0, "class", "fa fa-bar-chart-o");
      attr(i0, "aria-hidden", "true");
      attr(a1, "title", "Usage");
      attr(a1, "href", urls.availability);
      attr(i1, "class", "fa fa-file-text");
      attr(i1, "aria-hidden", "true");
      attr(a2, "title", "Templates");
      attr(a2, "href", "#/w/" + (params.team || 0) + "/tpls/all/");
      attr(i2, "class", "fa fa-users");
      attr(i2, "aria-hidden", "true");
      attr(a3, "href", urls.groups);
      attr(a3, "title", "Manage Teams");
      set_style(i3, "flex", "1");
      attr(a4, "class", "dropdown-toggle");
      attr(a4, "href", "#");
      attr(a4, "data-toggle", "dropdown");
      attr(a4, "title", "What's new");
      a4.hidden = true;
      attr(i5, "class", "fa fa-comment");
      attr(i5, "aria-hidden", "true");
      attr(a5, "class", "ripple");
      attr(a5, "href", urls.forums);
      attr(a5, "title", "Forums");
      attr(a5, "target", "_blank");
      attr(div0, "id", "feedPop");
      attr(a6, "class", "dropdown-toggle");
      attr(a6, "data-toggle", "dropdown");
      attr(a6, "href", "#");
      attr(li0, "role", "presentation");
      attr(li1, "class", "divider");
      attr(a7, "target", "_blank");
      attr(a7, "rel", "noopener");
      attr(a7, "href", "https://distill.io/kb/");
      attr(a8, "role", "menuitem");
      attr(a8, "href", urls.settings);
      attr(li3, "role", "presentation");
      attr(ul, "class", "dropdown-menu");
      attr(ul, "role", "menu");
      attr(div2, "class", "dropdown");
      attr(div2, "title", "Settings");
      attr(div3, "class", "vbar");
      attr(div4, "id", "x-vsidebar");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div3);
      append(div3, a0);
      append(a0, img);
      append(div3, t0);
      if_block0.m(div3, null);
      append(div3, t1);
      append(div3, a1);
      append(a1, i0);
      append(div3, t2);
      append(div3, a2);
      append(a2, i1);
      append(div3, t3);
      append(div3, a3);
      append(a3, i2);
      append(div3, t4);
      append(div3, i3);
      append(div3, t5);
      append(div3, a4);
      append(div3, t6);
      append(div3, div1);
      append(div1, a5);
      append(a5, i5);
      append(div1, t7);
      append(div1, div0);
      append(div3, t8);
      append(div3, div2);
      append(div2, a6);
      append(div2, t9);
      append(div2, ul);
      append(ul, li0);
      if_block1.m(li0, null);
      append(ul, t10);
      append(ul, li1);
      append(ul, t11);
      append(ul, li2);
      append(li2, a7);
      append(ul, t13);
      append(ul, li3);
      append(li3, a8);
      append(a8, t14);
      append(ul, t15);
      if (if_block2)
        if_block2.m(ul, null);
      append(ul, t16);
      if (if_block3)
        if_block3.m(ul, null);
      ctx[6](div2);
      if (!mounted) {
        dispose = listen(a4, "click", prevent_default(ctx[4]));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(div3, t1);
        }
      }
      if_block1.p(ctx2, dirty);
      if (!ctx2[0].account_id) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_1$x();
          if_block2.c();
          if_block2.m(ul, t16);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (ctx2[0].role == "admin") {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
        } else {
          if_block3 = create_if_block$S();
          if_block3.c();
          if_block3.m(ul, null);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div4);
      if_block0.d();
      if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      ctx[6](null);
      mounted = false;
      dispose();
    }
  };
}
function instance$1P($$self, $$props, $$invalidate) {
  let $user;
  const user = getContext$1("user");
  component_subscribe($$self, user, (value) => $$invalidate(0, $user = value));
  getContext$1("api");
  let langs2 = new LangPref().render();
  let elCog;
  let groups = $user.groups || [];
  let watchlists = [];
  function openReleaseMenu() {
  }
  onMount(() => {
    elCog.parentNode.insertBefore(langs2.el, elCog);
  });
  async function onSignOut(e) {
    if (Supports.agents.local) {
      e.preventDefault();
      await serviceProxy.auth.logout();
      location.href = urls.logout;
    }
  }
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elCog = $$value;
      $$invalidate(1, elCog);
    });
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      {
        $$invalidate(2, watchlists = [
          {
            name: `${$user.name} (personal)`,
            href: "#/w/0/list/all/"
          },
          ...groups.map((g) => ({
            name: g.name,
            href: `#/w/${g.id}/list/all/`
          }))
        ]);
      }
    }
  };
  return [$user, elCog, watchlists, user, openReleaseMenu, onSignOut, div2_binding];
}
class VBar extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1P, create_fragment$1X, safe_not_equal, {});
  }
}
const get_extra_slot_changes = (dirty) => ({});
const get_extra_slot_context = (ctx) => ({});
function create_fragment$1W(ctx) {
  let div1;
  let vbar;
  let t0;
  let t1;
  let div0;
  let current;
  let mounted;
  let dispose;
  vbar = new VBar({});
  const extra_slot_template = ctx[4].extra;
  const extra_slot = create_slot(extra_slot_template, ctx, ctx[3], get_extra_slot_context);
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  return {
    c() {
      div1 = element("div");
      create_component(vbar.$$.fragment);
      t0 = space();
      if (extra_slot)
        extra_slot.c();
      t1 = space();
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      attr(div0, "id", "content");
      attr(div0, "class", ctx[0]);
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      mount_component(vbar, div1, null);
      append(div1, t0);
      if (extra_slot) {
        extra_slot.m(div1, null);
      }
      append(div1, t1);
      append(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      ctx[6](div0);
      current = true;
      if (!mounted) {
        dispose = listen(div0, "scroll", ctx[5]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (extra_slot) {
        if (extra_slot.p && (!current || dirty & 8)) {
          update_slot_base(extra_slot, extra_slot_template, ctx2, ctx2[3], !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(extra_slot_template, ctx2[3], dirty, get_extra_slot_changes), get_extra_slot_context);
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[3], !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null), null);
        }
      }
      if (!current || dirty & 1) {
        attr(div0, "class", ctx2[0]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(vbar.$$.fragment, local);
      transition_in(extra_slot, local);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(vbar.$$.fragment, local);
      transition_out(extra_slot, local);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(vbar);
      if (extra_slot)
        extra_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      ctx[6](null);
      mounted = false;
      dispose();
    }
  };
}
function instance$1O($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { contentClass = "content" } = $$props;
  let { contentScrollTop = 0 } = $$props;
  let elContent;
  function setScroll() {
    setTimeout(() => {
      elContent && $$invalidate(1, elContent.scrollTop = contentScrollTop, elContent);
    });
  }
  function scroll_handler(event) {
    bubble.call(this, $$self, event);
  }
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elContent = $$value;
      $$invalidate(1, elContent);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("contentClass" in $$props2)
      $$invalidate(0, contentClass = $$props2.contentClass);
    if ("contentScrollTop" in $$props2)
      $$invalidate(2, contentScrollTop = $$props2.contentScrollTop);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4) {
      {
        contentScrollTop && setScroll();
      }
    }
  };
  return [
    contentClass,
    elContent,
    contentScrollTop,
    $$scope,
    slots,
    scroll_handler,
    div0_binding
  ];
}
class Layout extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1O, create_fragment$1W, safe_not_equal, { contentClass: 0, contentScrollTop: 2 });
  }
}
function create_else_block$v(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = `404 - Path Not Found - ${location.hash.slice(1)}`;
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block$R(ctx) {
  let layout;
  let current;
  layout = new Layout({
    props: {
      $$slots: { default: [create_default_slot$o] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(layout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(layout, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const layout_changes = {};
      if (dirty & 4) {
        layout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layout.$set(layout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(layout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(layout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(layout, detaching);
    }
  };
}
function create_default_slot$o(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = `404 - Path Not Found - ${location.hash.slice(1)}`;
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$1V(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$R, create_else_block$v];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$1N($$self, $$props, $$invalidate) {
  let { params: params2 } = $$props;
  let { useLayout = true } = $$props;
  console.error("404", params2);
  $$self.$$set = ($$props2) => {
    if ("params" in $$props2)
      $$invalidate(1, params2 = $$props2.params);
    if ("useLayout" in $$props2)
      $$invalidate(0, useLayout = $$props2.useLayout);
  };
  return [useLayout, params2];
}
class Error404 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1N, create_fragment$1V, safe_not_equal, { params: 1, useLayout: 0 });
  }
}
function create_if_block_1$w(ctx) {
  let div;
  let t_value = ctx[1].account.name + "";
  let t;
  return {
    c() {
      div = element("div");
      t = text(t_value);
      attr(div, "class", "pr-8");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t_value !== (t_value = ctx2[1].account.name + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_else_block$u(ctx) {
  let a;
  let t;
  return {
    c() {
      a = element("a");
      t = text("Sign In");
      attr(a, "href", urls.login);
      attr(a, "class", "xnav-a");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, t);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(a);
    }
  };
}
function create_if_block$Q(ctx) {
  let a;
  let t_value = ctx[1].name + "";
  let t;
  return {
    c() {
      a = element("a");
      t = text(t_value);
      attr(a, "href", "#/settings/profile/");
      attr(a, "class", "xnav-a");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, t);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t_value !== (t_value = ctx2[1].name + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(a);
    }
  };
}
function create_fragment$1U(ctx) {
  let div2;
  let div0;
  let t0;
  let t1;
  let div1;
  let t2;
  let t3;
  let if_block0 = ctx[1].account && create_if_block_1$w(ctx);
  function select_block_type(ctx2, dirty) {
    if (ctx2[1].id)
      return create_if_block$Q;
    return create_else_block$u;
  }
  let current_block_type = select_block_type(ctx);
  let if_block1 = current_block_type(ctx);
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      t0 = text(ctx[0]);
      t1 = space();
      div1 = element("div");
      t2 = space();
      if (if_block0)
        if_block0.c();
      t3 = space();
      if_block1.c();
      attr(div0, "class", "title-header ttu fw1 f3 xnav-a");
      attr(div1, "class", "flex-grow");
      attr(div2, "id", "topbar");
      attr(div2, "class", "flex items-center bb b--light-gray");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, t0);
      append(div2, t1);
      append(div2, div1);
      append(div2, t2);
      if (if_block0)
        if_block0.m(div2, null);
      append(div2, t3);
      if_block1.m(div2, null);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1)
        set_data(t0, ctx2[0]);
      if (ctx2[1].account) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_1$w(ctx2);
          if_block0.c();
          if_block0.m(div2, t3);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if_block1.d(1);
        if_block1 = current_block_type(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(div2, null);
        }
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div2);
      if (if_block0)
        if_block0.d();
      if_block1.d();
    }
  };
}
function instance$1M($$self, $$props, $$invalidate) {
  let $user;
  let { title = "Distill" } = $$props;
  const user = getContext$1("user");
  component_subscribe($$self, user, (value) => $$invalidate(1, $user = value));
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
  };
  return [title, $user, user];
}
class Topbar$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1M, create_fragment$1U, safe_not_equal, { title: 0 });
  }
}
const DescList = [
  {
    type: C.RULE_NOT_EMPTY,
    label: "l_not_is_empty",
    params: []
  },
  {
    type: C.RULE_HAS_TEXT,
    label: "l_has",
    params: [{
      label: "l_text",
      must: true,
      name: "input",
      type: "text"
    }]
  },
  {
    type: C.RULE_HAS_TEXT_NOT,
    label: "l_has_not",
    params: [{
      label: "l_text",
      must: true,
      name: "input",
      type: "text"
    }]
  },
  {
    type: C.RULE_HAS_NUMBER_LT,
    label: "l_has_num_lt",
    params: [{
      label: "l_num",
      must: true,
      name: "input",
      type: "number"
    }]
  },
  {
    type: C.RULE_HAS_NUMBER_GT,
    label: "l_has_num_gt",
    params: [{
      label: "l_num",
      must: true,
      name: "input",
      type: "number"
    }]
  },
  {
    type: C.RULE_HAS_NUMBER_DECR_MIN,
    label: "l_has_num_decr_min",
    params: [{
      label: "l_num",
      must: true,
      name: "input",
      type: "number"
    }]
  },
  {
    type: C.RULE_HAS_NUMBER_INCR_MIN,
    label: "l_has_num_incr_min",
    params: [{
      label: "l_num",
      must: true,
      name: "input",
      type: "number"
    }]
  },
  {
    type: C.RULE_HAS_NUMBER_DECR_PERCENT_MIN,
    label: "l_has_num_decr_pct_min",
    params: [{
      label: "l_num",
      must: true,
      name: "input",
      type: "number"
    }]
  },
  {
    type: C.RULE_HAS_NUMBER_INCR_PERCENT_MIN,
    label: "l_has_num_incr_pct_min",
    params: [{
      label: "l_num",
      must: true,
      name: "input",
      type: "number"
    }]
  },
  {
    type: C.RULE_MATCH_REGEX,
    label: "l_match_regex",
    params: [{
      label: "l_regex",
      must: true,
      name: "input",
      type: "regexp"
    }]
  }
];
const ContentList = [{
  type: C.CONTENT_TYPE_TEXT,
  label: "l_text"
}, {
  type: C.CONTENT_TYPE_CHANGED_TEXT,
  label: "l_added_text"
}, {
  type: C.CONTENT_TYPE_OLD_TEXT,
  label: "l_text_old"
}];
const NumericConditions = [
  C.RULE_HAS_NUMBER_LT,
  C.RULE_HAS_NUMBER_GT,
  C.RULE_HAS_NUMBER_DECR_MIN,
  C.RULE_HAS_NUMBER_INCR_MIN,
  C.RULE_HAS_NUMBER_DECR_PERCENT_MIN,
  C.RULE_HAS_NUMBER_INCR_PERCENT_MIN
];
var Rules = {
  ContentList,
  DescList,
  NumericConditions
};
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const createAndInsertPart = (containerPart, beforePart) => {
  const container = containerPart.startNode.parentNode;
  const beforeNode = beforePart === void 0 ? containerPart.endNode : beforePart.startNode;
  const startNode = container.insertBefore(createMarker(), beforeNode);
  container.insertBefore(createMarker(), beforeNode);
  const newPart = new NodePart(containerPart.options);
  newPart.insertAfterNode(startNode);
  return newPart;
};
const updatePart = (part, value) => {
  part.setValue(value);
  part.commit();
  return part;
};
const insertPartBefore = (containerPart, part, ref) => {
  const container = containerPart.startNode.parentNode;
  const beforeNode = ref ? ref.startNode : containerPart.endNode;
  const endNode = part.endNode.nextSibling;
  if (endNode !== beforeNode) {
    reparentNodes(container, part.startNode, endNode, beforeNode);
  }
};
const removePart = (part) => {
  removeNodes(part.startNode.parentNode, part.startNode, part.endNode.nextSibling);
};
const generateMap = (list, start, end) => {
  const map = /* @__PURE__ */ new Map();
  for (let i2 = start; i2 <= end; i2++) {
    map.set(list[i2], i2);
  }
  return map;
};
const partListCache = /* @__PURE__ */ new WeakMap();
const keyListCache = /* @__PURE__ */ new WeakMap();
const repeat = directive((items, keyFnOrTemplate, template) => {
  let keyFn;
  if (template === void 0) {
    template = keyFnOrTemplate;
  } else if (keyFnOrTemplate !== void 0) {
    keyFn = keyFnOrTemplate;
  }
  return (containerPart) => {
    if (!(containerPart instanceof NodePart)) {
      throw new Error("repeat can only be used in text bindings");
    }
    const oldParts = partListCache.get(containerPart) || [];
    const oldKeys = keyListCache.get(containerPart) || [];
    const newParts = [];
    const newValues = [];
    const newKeys = [];
    let index2 = 0;
    for (const item of items) {
      newKeys[index2] = keyFn ? keyFn(item, index2) : index2;
      newValues[index2] = template(item, index2);
      index2++;
    }
    let newKeyToIndexMap;
    let oldKeyToIndexMap;
    let oldHead = 0;
    let oldTail = oldParts.length - 1;
    let newHead = 0;
    let newTail = newValues.length - 1;
    while (oldHead <= oldTail && newHead <= newTail) {
      if (oldParts[oldHead] === null) {
        oldHead++;
      } else if (oldParts[oldTail] === null) {
        oldTail--;
      } else if (oldKeys[oldHead] === newKeys[newHead]) {
        newParts[newHead] = updatePart(oldParts[oldHead], newValues[newHead]);
        oldHead++;
        newHead++;
      } else if (oldKeys[oldTail] === newKeys[newTail]) {
        newParts[newTail] = updatePart(oldParts[oldTail], newValues[newTail]);
        oldTail--;
        newTail--;
      } else if (oldKeys[oldHead] === newKeys[newTail]) {
        newParts[newTail] = updatePart(oldParts[oldHead], newValues[newTail]);
        insertPartBefore(containerPart, oldParts[oldHead], newParts[newTail + 1]);
        oldHead++;
        newTail--;
      } else if (oldKeys[oldTail] === newKeys[newHead]) {
        newParts[newHead] = updatePart(oldParts[oldTail], newValues[newHead]);
        insertPartBefore(containerPart, oldParts[oldTail], oldParts[oldHead]);
        oldTail--;
        newHead++;
      } else {
        if (newKeyToIndexMap === void 0) {
          newKeyToIndexMap = generateMap(newKeys, newHead, newTail);
          oldKeyToIndexMap = generateMap(oldKeys, oldHead, oldTail);
        }
        if (!newKeyToIndexMap.has(oldKeys[oldHead])) {
          removePart(oldParts[oldHead]);
          oldHead++;
        } else if (!newKeyToIndexMap.has(oldKeys[oldTail])) {
          removePart(oldParts[oldTail]);
          oldTail--;
        } else {
          const oldIndex = oldKeyToIndexMap.get(newKeys[newHead]);
          const oldPart = oldIndex !== void 0 ? oldParts[oldIndex] : null;
          if (oldPart === null) {
            const newPart = createAndInsertPart(containerPart, oldParts[oldHead]);
            updatePart(newPart, newValues[newHead]);
            newParts[newHead] = newPart;
          } else {
            newParts[newHead] = updatePart(oldPart, newValues[newHead]);
            insertPartBefore(containerPart, oldPart, oldParts[oldHead]);
            oldParts[oldIndex] = null;
          }
          newHead++;
        }
      }
    }
    while (newHead <= newTail) {
      const newPart = createAndInsertPart(containerPart, newParts[newTail + 1]);
      updatePart(newPart, newValues[newHead]);
      newParts[newHead++] = newPart;
    }
    while (oldHead <= oldTail) {
      const oldPart = oldParts[oldHead++];
      if (oldPart !== null) {
        removePart(oldPart);
      }
    }
    partListCache.set(containerPart, newParts);
    keyListCache.set(containerPart, newKeys);
  };
});
let KVStore = serviceProxy.store.KVStore;
const $$9 = window.jQuery;
if (!$$9) {
  throw new Error("ADD jQuery");
}
const _$9 = window._;
if (!_$9) {
  throw new Error("ADD _");
}
const domo$8 = window.domo;
if (!domo$8) {
  throw new Error("ADD domo");
}
const Backbone$9 = window.Backbone;
if (!Backbone$9) {
  throw new Error("ADD Backbone");
}
const Common$1 = View$1.Base.extend({
  name: "actions$Common",
  events: {
    "change": "event_change"
  },
  event_change: function() {
    this.saveValues();
  },
  render: function() {
    this.$el.attr({
      "id": "common",
      "class": "panel panel-default"
    }).append(HEADER({ "class": "panel-heading" }, H3(T("l_actions"))), DIV({ "class": "panel-body" }, DIV({ "class": "checkbox" }, LABEL(INPUT({ type: "checkbox", name: "actions.popup" }), T("l_action_local_popup"))), DIV({ "class": "checkbox" }, LABEL(INPUT({ type: "checkbox", name: "actions.audio" }), T("l_action_local_audio"))), DIV({ "class": "form-group" }, T("m_firefox_only"), " - ", T("m_autohide_popup"), ": ", SELECT({ "name": "actions.popup.autohide", "style": "width:auto" }, OPTION({ value: 0 }, T("l_never")), OPTION({ value: 5 }, "5s"), OPTION({ value: 10 }, "10s"), OPTION({ value: 20 }, "20s"), OPTION({ value: 60 }, "1m"), OPTION({ value: 120 }, "2m"), OPTION({ value: 300 }, "5m"))), DIV({ "class": "alert alert-info" }, A({ href: "https://distill.io/settings/actions" }, T("Change email action settings from web app!")))));
    this.setValues();
    return this;
  },
  saveValues: function() {
    this.$el.find("input,select").each(function() {
      const el = this;
      if (el.type == "checkbox") {
        serviceProxy.store.Prefs.set(el.name, el.checked);
      } else {
        serviceProxy.store.Prefs.set(el.name, el.value);
      }
    });
  },
  setValues: function() {
    this.$el.find("input,select").each(async function() {
      const el = this;
      if (el.type == "checkbox") {
        el.checked = await serviceProxy.store.Prefs.get(el.name);
      } else {
        el.value = await serviceProxy.store.Prefs.get(el.name);
      }
    });
  }
});
const Tone = View$1.Base.extend({
  name: "Tone",
  className: "form-group",
  events: {
    "click button.xdel": "event_del",
    "click button.xplay": "event_play"
  },
  event_del: function() {
    this.model.collection.remove(this.model);
  },
  event_play: function() {
    if (this.model.get("type") == "file") {
      this.playFile();
    } else {
      this.playSrc(this.input.getValue());
    }
  },
  getDefaultName: function(path) {
    const parts = path.split(/(\/|\\)/);
    return parts.pop() || "New File";
  },
  onInputChange: function() {
    const value = this.input.getValue();
    if (_$9.isEmpty(this.label.getValue())) {
      this.label.setValue(this.getDefaultName(value));
    }
  },
  playFile: function() {
    if (this.input.field.files) {
      this.playSelectedFile();
    } else {
      this.playSavedFile();
    }
  },
  playSavedFile: async function() {
    const ref = this.model.get("value");
    try {
      let doc = await KVStore.findOne(ref);
      this.playSrc(doc.value);
    } catch (err) {
      console.error("Error while playing saved file", err);
    }
  },
  async playSelectedFile() {
    const file = this.input.field.files[0];
    if (file) {
      this.playSrc(await readFile(file));
    } else {
      alert("Please select an audio file before playing it.");
    }
  },
  playSrc(src2) {
    AUDIO({ src: src2 }).play();
  },
  postInit: function() {
    this.label = Editor.create({
      model: this.model,
      param: {
        label: "l_name",
        name: "label",
        type: "text"
      },
      parent: this
    });
    this.input = Editor.create({
      model: this.model,
      param: this.model.get("type") == "url" ? {
        label: "l_url",
        type: "url",
        name: "value"
      } : this.model.get("value") != null ? {
        type: "static",
        name: "value"
      } : {
        label: "l_file",
        type: "file",
        name: "value"
      },
      parent: this
    });
    this.listenTo(this.input, "change", this.onInputChange);
  },
  render: function() {
    this.$el.append(DIV({ "class": "col-md-3" }, this.label.render().el), DIV({ "class": "col-md-6" }, this.input.render().el), DIV({ "class": "col-md-3" }, BUTTON({ "class": "btn btn-default xplay" }, T("a_play")), " ", BUTTON({ "class": "btn btn-default xdel" }, I({ "class": "fa fa-times" }))));
    if (this.model.get("type") == "file" && this.model.get("value") == null) {
      this.input.field.click();
    }
    return this;
  }
});
const ErrorSect = View$1.Base.extend({
  name: "actions$errorSect",
  events: {
    "change": "event_change"
  },
  event_change: function() {
    this.saveValues();
  },
  render: function() {
    const sounds = _$9.findWhere(Model$2.SieveActionDescList, { type: C.ACTION_LOCAL_AUDIO })["params"][0].list;
    this.$el.attr({
      "id": "errorSect",
      "class": "panel panel-default"
    }).append(HEADER({ "class": "panel-heading" }, H3(T("Error Actions"))), DIV({ "class": "panel-body" }, DIV({ "class": "checkbox" }, LABEL(INPUT({ type: "checkbox", name: "errorAction.enabled" }), T("Trigger notifications"))), DIV({ "class": "form-group" }, T("l_notification_sound"), ": ", SELECT({ "name": "errorAction.sound", "style": "width:auto" }, sounds.map(function(sound, index2) {
      return OPTION({ value: sound.value }, T(sound.label));
    }))), DIV({ "class": "form-group" }, T("Minimum time interval between notifications (in minutes): "), INPUT({ "type": "number", "style": "width: 60px;", "name": "errorAction.interval", "min": "1" })), DIV({ "class": "form-group" }, T("No. of consecutive errors to trigger notifications"), ": ", SELECT({ "name": "errorAction.minCount", "style": "width:auto" }, OPTION({ value: 1 }, "1"), OPTION({ value: 2 }, "2"), OPTION({ value: 3 }, "3"), OPTION({ value: 4 }, "4"), OPTION({ value: 5 }, "5"), OPTION({ value: 6 }, "6"), OPTION({ value: 7 }, "7"), OPTION({ value: 8 }, "8"), OPTION({ value: 9 }, "9"), OPTION({ value: 10 }, "10"))), DIV({ "class": "alert alert-info" }, T("h_error_notif_desc"))));
    this.setValues();
    return this;
  },
  saveValues: function() {
    this.$el.find("input,select").each(function() {
      const el = this;
      if (el.type == "checkbox") {
        serviceProxy.store.Prefs.set(el.name, el.checked);
      } else {
        serviceProxy.store.Prefs.set(el.name, el.value);
      }
    });
  },
  setValues: function() {
    this.$el.find("input,select").each(async function() {
      const el = this;
      if (el.type == "checkbox") {
        el.checked = await serviceProxy.store.Prefs.get(el.name);
      } else {
        el.value = await serviceProxy.store.Prefs.get(el.name);
      }
    });
  }
});
const Tones = View$1.Collection.extend({
  name: "actions$Tones",
  actions: {
    "tones add file": { fn: "action_add_file" },
    "tones add url": { fn: "action_add_url" },
    "tones save": { fn: "action_save" }
  },
  action_add_file: function() {
    const model = new Backbone$9.Model({ type: "file" });
    this.collection.add(model);
  },
  action_add_url: function() {
    const model = new Backbone$9.Model({ type: "url" });
    this.collection.add(model);
  },
  async action_save() {
    let file;
    Msg.start("save", "l_loading");
    let tones = [];
    for (let view of _$9.values(this.views)) {
      const files2 = view.input.field.files;
      const model = view.model;
      const json = model.toJSON();
      const isNewFile = !!files2;
      if (isNewFile && (file = files2[0])) {
        let dataURI = await readFile(file);
        const id2 = "tone:" + await sha1(dataURI);
        await KVStore.create({ id: id2, value: dataURI });
        json.value = id2;
      }
      tones.push(json);
    }
    const value = JSON.stringify(tones);
    let res2 = await KVStore.update("tones", { value });
    if (res2._count === 0) {
      await KVStore.create({ id: "tones", value });
    }
    const oldFileRefs = files(this.oldTones);
    const savedFileRefs = files(tones);
    const removedFiles = _$9.difference(oldFileRefs, savedFileRefs);
    for (let file2 of removedFiles) {
      await KVStore.destroy(file2);
    }
    Msg.reset();
    this.load();
    function files(tones2) {
      return tones2.filter((tone) => tone.type == "file").map((tone) => tone.value);
    }
  },
  addOne: function(model) {
    const view = new Tone({ parent: this, model }).render();
    this.$list.append(view.el);
    return view;
  },
  initCollection: function() {
    this.oldTones = [];
    this.collection = new Backbone$9.Collection();
  },
  load: async function() {
    let doc = await KVStore.findOne("tones");
    if (doc) {
      this.oldTones = JSON.parse(doc.value);
      this.collection.reset(this.oldTones);
    }
  },
  renderBase: function() {
    this.$el.attr({
      "id": "tones",
      "class": "panel panel-default"
    }).append(HEADER({ "class": "panel-heading clearfix" }, H3({ "class": "pull-left" }, "Tones"), DIV({ "class": "right" }, BUTTON({ "class": "btn btn-default btn-sm", "data-action": "tones add file" }, T("a_add_file")), BUTTON({ "class": "btn btn-default btn-sm", "data-action": "tones add url" }, T("a_add_url")))), DIV({ "class": "panel-body" }, DIV({ "class": "xlist" })), DIV({ "class": "panel-footer" }, BUTTON({ "class": "btn btn-primary", "data-action": "tones save" }, T("a_save"))));
    this.$list = this.$el.find(".xlist");
  }
});
const SettingsActions = View$1.ActionProvider.extend({
  name: "SettingsActions",
  load: function(callback) {
    this.tones.load(callback);
  },
  postInit: function() {
    this.common = new Common$1({ parent: this });
    this.errorSect = new ErrorSect({ parent: this });
    this.tones = new Tones({ parent: this });
  },
  render: function() {
    this.$el.append(this.common.render().el, this.errorSect.render().el, this.tones.render().el);
    return this;
  }
});
async function sha1(dataURI) {
  let encoder = new TextEncoder();
  let hashBuf = await crypto.subtle.digest("SHA-1", encoder.encode(dataURI));
  let hashArrBuf = Array.from(new Uint8Array(hashBuf));
  let hashHex = hashArrBuf.map((b) => b.toString(16).padStart(2, "0")).join("");
  return hashHex;
}
function readFile(file) {
  return new Promise((resolve) => {
    const reader = new FileReader();
    reader.onload = function(e) {
      resolve(e.target.result);
    };
    reader.readAsDataURL(file);
  });
}
function create_fragment$1T(ctx) {
  let elwrap;
  let current;
  elwrap = new ElWrap({ props: { el: ctx[0].el } });
  return {
    c() {
      create_component(elwrap.$$.fragment);
    },
    m(target, anchor) {
      mount_component(elwrap, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(elwrap.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(elwrap.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(elwrap, detaching);
    }
  };
}
function instance$1L($$self) {
  const parent2 = getContext$1("view:root");
  let view = new SettingsActions({ parent: parent2 }).render();
  view.load();
  return [view];
}
class ActionsExt_1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1L, create_fragment$1T, safe_not_equal, {});
  }
}
const $$8 = window.jQuery;
if (!$$8) {
  throw new Error("ADD jQuery");
}
const _$8 = window._;
if (!_$8) {
  throw new Error("ADD _");
}
const domo$7 = window.domo;
if (!domo$7) {
  throw new Error("ADD domo");
}
const Backbone$8 = window.Backbone;
if (!Backbone$8) {
  throw new Error("ADD Backbone");
}
const Common = View$1.Base.extend({
  name: "actions$Common",
  tagName: "form",
  events: {
    "change": "event_change"
  },
  event_change: function() {
    this.saveValues();
  },
  render: function() {
    this.$el.attr({
      "id": "common",
      "class": "panel panel-default"
    }).append(HEADER({ "class": "panel-heading" }, H3(T("l_advanced"))), DIV({ "class": "panel-body" }, DIV({ "class": "form-group" }, T("m_max_workers"), " ", SELECT({ name: "nworkers", style: "width:auto" }, OPTION({ value: 1 }, 1), OPTION({ value: 2 }, 2), OPTION({ value: 3 }, 3), OPTION({ value: 4 }, 4), OPTION({ value: 5 }, 5), OPTION({ value: 6 }, 6), OPTION({ value: 7 }, 7), OPTION({ value: 8 }, 8), OPTION({ value: 9 }, 9), OPTION({ value: 10 }, 10))), DIV({ "class": "form-group" }, T("m_load_page_options"), " ", SELECT({ name: "x-frame-load-in", style: "width:auto" }, OPTION({ value: "tab" }, T("l_opt_bgtab")), OPTION({ value: "window" }, T("l_opt_bgwindow")), OPTION({ value: "bg" }, T("l_opt_force_bg")), OPTION({ value: "sticky_window" }, T("l_opt_sticky_window"))), " ", A({ href: "https://distill.io/help/new-tab-chrome-extension" }, T("l_learn_more"))), DIV({ "class": "form-group" }, T("m_sticky_window_timeout"), " ", INPUT({ name: "sticky-window-timeout", type: "number", style: "width:auto" })), DIV({ "class": "form-group" }, DIV({ class: "alert alert-info" }, T("m_sticky_window_warning")), " ")));
    this.setValues();
    return this;
  },
  saveValues: function() {
    this.$el.find("input,select").each(function() {
      const el = this;
      if (el.type == "checkbox") {
        serviceProxy.store.Prefs.set(el.name, el.checked);
      } else {
        serviceProxy.store.Prefs.set(el.name, el.value);
      }
    });
  },
  setValues: function() {
    this.$el.find("input,select").each(async function() {
      const el = this;
      if (el.type == "checkbox") {
        el.checked = await serviceProxy.store.Prefs.get(el.name);
      } else {
        el.value = await serviceProxy.store.Prefs.get(el.name);
      }
    });
  }
});
const SettingsAdvanced = View$1.ActionProvider.extend({
  name: "SettingsAdvanced",
  postInit: function() {
    this.common = new Common({ parent: this });
    this.timing = new TimingSlots({ parent: this });
  },
  render: function() {
    this.$el.append(this.common.render().el, this.timing.render().el);
    return this;
  }
});
var TimingSlots = View$1.Base.extend({
  name: "TimingSlots",
  events: {
    "change": "event_change"
  },
  postInit: async function() {
    try {
      const response = await Api.api("/subscriptions", "GET", { "state.in": [40, 45] });
      const activePlan = response.data[0].plan_id;
      if (activePlan[0] == "0") {
        $$8(this.elUnavailable).removeClass("hide");
      } else {
        $$8(this.elFormParent).removeClass("hide");
        if (await serviceProxy.store.Prefs.get("sieve-slot.enabled")) {
          $$8(this.elTimeSlotData).removeClass("hide");
        }
      }
    } catch (e) {
      console.log(e);
      $$8(this.elUnavailable).removeClass("hide");
    }
  },
  render: function() {
    this.$el.attr({
      "id": "errorSect",
      "class": "panel panel-default"
    }).append(HEADER({ "class": "panel-heading" }, H3(T("l_time_slots"))), DIV({ "class": "container", "style": "width: 100%" }, this.elFormParent = DIV({ "class": "hide" }, DIV({ "class": "row", "style": "margin-top: 10px; margin-bottom: 10px;" }, DIV({ "class": "col-sm-12" }, DIV({ "class": "checkbox" }, LABEL(this.elSlotEnabled = INPUT({ type: "checkbox", name: "sieve-slot.enabled" }), T("l_time_slots_enabled"))))), this.elTimeSlotData = DIV({ "class": "hide" }, DIV({ "class": "row" }, DIV({ "class": "col-sm-4" }, this.formElemStart = DIV({ "class": "form-group" }, T("l_time_slots_start"), " ", this.elStartTime = INPUT({ name: "sieve-slot.start", type: "time", style: "width: 200px;" }))), DIV({ "class": "col-sm-4" }, this.formElemEnd = DIV({ "class": "form-group" }, T("l_time_slots_end"), " ", this.elEndTime = INPUT({ name: "sieve-slot.end", type: "time", style: "width: 200px;" }))), DIV({ "class": "col-sm-4" }, this.formElemDays = DIV({ "class": "form-group" }, T("l_time_slots_day"), " ", this.elSlotDays = SELECT({ name: "sieve-slot.days", id: "slot-days", multiple: true, style: "width: 200px; height: 120px;" }, OPTION({ value: 1 }, T("l_monday")), OPTION({ value: 2 }, T("l_tuesday")), OPTION({ value: 3 }, T("l_wednesday")), OPTION({ value: 4 }, T("l_thursday")), OPTION({ value: 5 }, T("l_friday")), OPTION({ value: 6 }, T("l_saturday")), OPTION({ value: 0 }, T("l_sunday")))))), this.elWarningMsg = DIV({ "class": "form-group" }, DIV({ class: "alert alert-info" }, T("m_day_warning")), " "))), this.elUnavailable = DIV({ "class": "form-group hide" }, DIV({ class: "alert alert-info" }, T("m_premium_only")), " ")));
    this.setValues();
    return this;
  },
  setValues: async function() {
    this.$el.find("input").each(async function() {
      if (this.type == "checkbox") {
        this.checked = await serviceProxy.store.Prefs.get(this.name);
      } else {
        this.value = await serviceProxy.store.Prefs.get(this.name);
      }
    });
    const map = await serviceProxy.store.Prefs.get("time-slot-map");
    const keys = Object.keys(map);
    const slotDays = this.$el.find("#slot-days");
    slotDays.val(keys);
    if (slotDays.val().length < 5) {
      $$8(this.elWarningMsg).show();
    } else {
      $$8(this.elWarningMsg).hide();
    }
  },
  hideForm: function() {
    $$8(this.formElemStart).hide();
    $$8(this.formElemEnd).hide();
    $$8(this.formElemDays).hide();
    $$8(this.elWarningMsg).hide();
  },
  showForm: function() {
    $$8(this.formElemStart).show();
    $$8(this.formElemEnd).show();
    $$8(this.formElemDays).show();
    $$8(this.elWarningMsg).show();
  },
  saveValues: function() {
    this.$el.find("input").each(async function() {
      const el = this;
      if (el.type == "checkbox") {
        await serviceProxy.store.Prefs.set(el.name, el.checked);
      } else {
        await serviceProxy.store.Prefs.set(el.name, el.value);
      }
    });
    const slotDays = this.$el.find("#slot-days");
    const map = {};
    const days = slotDays.val();
    for (const i2 in days) {
      const day = days[i2];
      map[day] = map[day] || [];
      map[day].push({ start: this.elStartTime.value, end: this.elEndTime.value });
    }
    serviceProxy.store.Prefs.set("time-slot-map", map);
  },
  event_change: function() {
    const slotDays = this.$el.find("#slot-days");
    if (this.elSlotEnabled.checked) {
      $$8(this.elTimeSlotData).removeClass("hide");
    } else {
      $$8(this.elTimeSlotData).addClass("hide");
    }
    if (slotDays.val().length < 5) {
      $$8(this.elWarningMsg).show();
    } else {
      $$8(this.elWarningMsg).hide();
    }
    this.saveValues();
  }
});
function create_fragment$1S(ctx) {
  let elwrap;
  let current;
  elwrap = new ElWrap({ props: { el: ctx[0].el } });
  return {
    c() {
      create_component(elwrap.$$.fragment);
    },
    m(target, anchor) {
      mount_component(elwrap, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(elwrap.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(elwrap.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(elwrap, detaching);
    }
  };
}
function instance$1K($$self) {
  const parent2 = getContext$1("view:root");
  let view = new SettingsAdvanced({ parent: parent2 }).render();
  return [view];
}
class AdvancedExt extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1K, create_fragment$1S, safe_not_equal, {});
  }
}
class SessionSelector extends Base$3 {
  constructor({ model }) {
    super();
    this.model = model;
    this.setId(model.get("session_id"));
    this.state.names = {};
    if (App.user.isLoggedIn()) {
      this.loadSessions();
    }
  }
  async loadSessions(query = {}) {
    let res2 = await Api.api("/sessions", query);
    this.state.sessions = res2.data;
    let names = res2.data.reduce((m, s) => {
      m[s.id] = s.name;
      return m;
    }, {});
    let id2 = this.state.id;
    if (id2 && !names[id2]) {
      let res3 = await Api.api(`/sessions/${id2}`);
      names[id2] = res3.name;
    }
    this.state.names = names;
  }
  onSearch(e) {
    this.loadSessions({
      "name.ilike": `%${e.target.value}%`
    });
  }
  setId(id2, e) {
    e && e.preventDefault();
    this.state.id = id2;
    this.model.set("session_id", id2);
  }
  createTpl({ id: id2, sessions, names }) {
    let loadedSessions = !!sessions;
    let team2 = get_store_value(params).team;
    return html`<div class='drowdown relative'>
      <a class='btn btn-default dropdown-toggle' data-toggle='dropdown'
        href='#'>
        Profile - ${!id2 ? "Empty" : names[id2] || "Deleted"}
        <span class='caret'></span>
      </a>
      <ul class='dropdown-menu'>
        ${loadedSessions ? [
      html`
        <li>
          <div class='ma2' @click=${(e) => (e.preventDefault(), e.stopPropagation())}>
            <input type='text' class='ba0' placeholder='Search' @input=${(e) => this.onSearch(e)}></input>
          </div>
        </li>
          <li><a href='#' @click=${(e) => this.setId(null, e)}>
              <i class='mr2 fa ${!id2 ? "fa-check" : "mr4"}'></i>
              Empty (Default)</a></li>`,
      ...sessions.map((s) => html`<li>
            <a data-id=${s.id} href='#' @click=${(e) => this.setId(s.id, e)}>
              <i class='mr2 fa ${id2 == s.id ? "fa-check" : "mr4"}'></i>
              ${s.name}
            </a>
          </li>`),
      html`
          <li class='divider'></li>

          <li><a href='#/w/${team2}/profiles/' target='_blank'>
              <span class='pl4'> Manage Profiles<span></a></li>

          <li><a href='${URL_WEBSITE}/kb/help/profiles-for-cloud-monitors' target='_blank'>
              <span class='pl4'> Learn More<span></a></li>
              `
    ] : html`<li><a>Loading...</a></li>`}
      </ul>
    </div>`;
  }
}
const async$7 = window.async;
if (!async$7) {
  throw new Error("ADD async");
}
class ClientSelector extends Base$3 {
  constructor({ model }) {
    super();
    this.model = model;
    this.state.showOptions = false;
    this.setClientId(this.getDefaultClientID());
    this.sessionSelector = new SessionSelector({ model });
    this.setProxyID(model.get("proxy_id"));
    this.state.proxyNames = {};
    if (App.user.isLoggedIn()) {
      this.loadProxies();
    }
  }
  getDefaultClientID() {
    let id2 = this.model.get("client_id") || App.clients.defaultId;
    let ids = this.model.getAccessibleClients(App.clients).map((c) => c.id);
    return ids.includes(id2) ? id2 : ids[0];
  }
  setClientId(client_id) {
    this.state.client_id = client_id;
    this.model.set("client_id", client_id);
  }
  setProxyID(proxy_id, e) {
    e && e.preventDefault();
    this.state.proxy_id = proxy_id;
    this.model.set("proxy_id", proxy_id);
  }
  async loadProxies() {
    const res2 = await Api.api("/proxies", {
      only: ["id", "name", "cost"]
    });
    let globalData = (await Api.api("/proxies/global")).data;
    globalData = globalData.filter((p) => p.available);
    this.state.proxies = [...res2.data, ...globalData];
    res2.data.reduce((m, s) => (m[s.id] = s.name, m), this.state.proxyNames);
    globalData.reduce((m, s) => (m[s.id] = s.name, m), this.state.proxyNames);
  }
  createTpl({
    client_id,
    proxyNames,
    proxies,
    proxy_id,
    showOptions
  }) {
    let $params = get_store_value(params);
    let team2 = $params.team;
    let client = App.clients.get(client_id);
    let loadedProxies = !!proxies;
    let availableClients = this.model.getAccessibleClients(App.clients);
    return html`<div class='flex align-items'>
      <select @change=${(e) => this.setClientId(e.target.value)} class='mr3'>
        ${repeat(availableClients, (c) => c.id, (c) => html`<option value=${c.id} ?selected=${c.id == client_id}>${c.getInfo()}</option>`)}
      </select>
      ${client && client.isWeb() && !showOptions ? html`<a
        @click=${(e) => this.state.showOptions = true}
        href='javascript:void 0'>Options</a>` : ""}
      ${client && client.isWeb() && showOptions ? this.sessionSelector.el : ""}
      ${showOptions && client && client.isWeb() ? html`<div class='ml3 dropdown relative'>
        <a class='dropdown-toggle btn btn-default' data-toggle='dropdown'
          href=#
          >
          Proxy - ${!proxy_id ? "Shared Pool" : proxyNames[proxy_id] || "Deleted"} <span class='caret'></span>
        </a>
        <ul class='dropdown-menu'>
        ${loadedProxies ? [
      html`<li><a href='#' @click=${(e) => this.setProxyID(null, e)}>
            <i class='mr2 fa ${!proxy_id ? "fa-check" : "mr4"}'></i>
            Shared Pool (Default)</a></li>`,
      ...proxies.map((s) => html`<li>
            <a data-id=${s.id} href='#' @click=${(e) => this.setProxyID(s.id, e)}>
              <i class='mr2 fa ${proxy_id == s.id ? "fa-check" : "mr4"}'></i>
              ${s.name}
            </a>
          </li>`),
      html`
          <li class='divider'></li>

          <li><a href='#/w/${team2}/proxies/' target='_blank'>
              <span class='pl4'> Manage Proxies<span></a></li>

          <li><a href='${URL_WEBSITE}/kb/help/monitor-webpage-using-proxy-servers/' target='_blank'>
              <span class='pl4'> Learn More<span></a></li>
          `
    ] : html`<li><a>Loading...</a></li>`}
        </ul>
      
      </div>` : ""}
    </div>`;
  }
}
const ClientManager = View$1.Collection.extend({
  name: "ClientManager",
  actions: {
    "client edit name": {
      fn: "action_edit_name"
    },
    "client remove": {
      fn: "action_remove"
    }
  },
  action_edit_name: function(id2) {
    const view = Editor.create("text");
    const model = this.collection.get(id2);
    const modal = new View$1.PromptModal({
      title: "l_name",
      parent: this.getRoot(),
      view,
      width: 500
    });
    modal.show();
    view.setValue(model.get("info"));
    $(view.field).focus();
    modal.on("save", () => {
      const value = view.getValue();
      model.save({ "info": value }, { patch: true });
      modal.remove();
      this.onReset(this.collection, {
        previousModels: this.collection.models
      });
    });
  },
  action_remove: function(id2) {
    const model = this.collection.get(id2);
    if (id2 == this.collection.defaultId) {
      return alert(T("Can't remove self"));
    } else if (model.isWeb()) {
      return alert(T("Can't remove web app"));
    } else if (confirm(T("Remove " + model.get("info") + "?"))) {
      model.save({ state: 90 }, {
        wait: true,
        success: () => {
          this.collection.remove(model);
        }
      });
    }
  },
  addOne: function(model) {
    if (model.get("type") < 3) {
      return new View$1.Base();
    }
    const info = model.get("info");
    const isThisClient = model.id == this.collection.defaultId;
    const view = new View$1.Base({
      el: P(SPAN(BUTTON({
        "class": "btn btn-default btn-xs",
        "data-action": "client edit name",
        "data-action-param": model.id
      }, I({ "class": "fa fa-edit" })), " ", BUTTON({
        "class": "btn btn-danger btn-xs",
        "data-action": "client remove",
        "data-action-param": model.id
      }, I({ "class": "fa fa-trash-o" }))), " ", SPAN({ style: isThisClient ? "font-weight: bold;" : "" }, info, isThisClient ? " (" + T("l_device_this") + ")" : ""), SMALL({}, moment(model.get("ts")).format(" (YYYY-MM-DD)"))),
      parent: this
    }).render();
    this.$el.append(view.el);
    return view;
  },
  onSave: function() {
    Msg.info("l_loading");
    async$7.eachSeries(this.collection.models, function(model, callback) {
      if (model.hasChanged("info")) {
        model.save(null, {
          error: function() {
            callback(new Error("Failed to save changes"));
          },
          success: function() {
            callback();
          }
        });
      } else {
        callback();
      }
    }, function(err) {
      Msg.reset();
    });
  },
  renderBase: function() {
  }
});
var ViewClients = {
  ClientManager,
  ClientSelector
};
function create_fragment$1R(ctx) {
  let div3;
  let div0;
  let t3;
  let div2;
  let div1;
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      div0.innerHTML = `<h3>Manage Devices</h3> 
    <small>Rename devices or remove unused ones</small>`;
      t3 = space();
      div2 = element("div");
      div1 = element("div");
      attr(div0, "class", "panel-heading");
      attr(div2, "class", "panel-body");
      attr(div3, "class", "panel panel-default");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div0);
      append(div3, t3);
      append(div3, div2);
      append(div2, div1);
      ctx[1](div1);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div3);
      ctx[1](null);
    }
  };
}
function instance$1J($$self, $$props, $$invalidate) {
  const clients = new ModelClient.Clients();
  const parent2 = getContext$1("view:root");
  let el;
  let view;
  onMount(async () => {
    await clients.fetch({
      data: {
        "state.in": [0, 30],
        "_opt": { order: ["ts"] }
      }
    });
    view = new ViewClients.ClientManager({ el, parent: parent2, collection: clients });
    view.render();
    return () => view.remove();
  });
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(0, el);
    });
  }
  return [el, div1_binding];
}
class Devices extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1J, create_fragment$1R, safe_not_equal, {});
  }
}
const $$7 = window.jQuery;
if (!$$7) {
  throw new Error("ADD jQuery");
}
const _$7 = window._;
if (!_$7) {
  throw new Error("ADD _");
}
const Backbone$7 = window.Backbone;
if (!Backbone$7) {
  throw new Error("ADD Backbone");
}
var General = View$1.ActionProvider.extend({
  name: "SettingsGeneral",
  actions: {
    "settings signout": { fn: "action_signout" },
    "settings close": { fn: "closeLoginForm" }
  },
  events: {
    "change": "event_change",
    "click .xclose": "closeLoginForm"
  },
  closeLoginForm: function() {
    this.loginView.remove();
    $$7(this.elLoginCt).remove();
    this.updateUser();
  },
  action_signout: async function() {
    await serviceProxy.auth.logout();
    location.href = serviceProxy.CFG.URL.ROOT + "/logout";
  },
  event_change: function() {
    this.saveValues();
  },
  load: function() {
    this.setValues();
  },
  render: function() {
    this.$el.append(DIV({ "class": "panel panel-default" }, HEADER({ "class": "panel-heading" }, H3("General")), DIV({ "class": "panel-body" }, DIV({ "class": "form-group" }, H4(T("l_account")), A({ "class": "btn btn-primary", "href": `${serviceProxy.CFG.URL.ROOT}/service-login?redirect=app://ui/inbox.html#inbox`, "data-action": "settings signin" }), BUTTON({ "class": "btn btn-default", "style": "margin-left: 20px;", "data-action": "settings signout" }, T("a_signout"))), DIV(T("m_ext_signin")))));
    this.elSignIn = this.$('[data-action="settings signin"]');
    this.elSyncInfo = this.$(".alert");
    return this;
  },
  saveValues: function() {
    this.$el.find("input,select").each(async function() {
      const el = this;
      if (el.type == "checkbox") {
        await serviceProxy.store.Prefs.set(el.name, el.checked);
      } else {
        await serviceProxy.store.Prefs.set(el.name, el.value);
      }
    });
  },
  setValues: function() {
    this.$el.find("input,select").each(async function() {
      const el = this;
      if (el.type == "checkbox") {
        el.checked = await serviceProxy.store.Prefs.get(el.name);
      } else {
        el.value = await serviceProxy.store.Prefs.get(el.name);
      }
    });
    this.showCred();
  },
  showCred: function() {
    if (USER.name) {
      this.elSignIn.text(SPRINTF("l_signed_in_as", `${USER.name} (${USER.email})`));
    } else {
      this.elSignIn.text(T("a_signin"));
    }
  },
  updateUser: async function() {
    let user = await serviceProxy.auth.getUser();
    _$7.extend(USER, user);
    this.showCred();
  }
});
function create_fragment$1Q(ctx) {
  let elwrap;
  let current;
  elwrap = new ElWrap({ props: { el: ctx[0].el } });
  return {
    c() {
      create_component(elwrap.$$.fragment);
    },
    m(target, anchor) {
      mount_component(elwrap, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(elwrap.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(elwrap.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(elwrap, detaching);
    }
  };
}
function instance$1I($$self) {
  const parent2 = getContext$1("view:root");
  let view = new General({ parent: parent2 }).render();
  view.load();
  return [view];
}
class GeneralExt extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1I, create_fragment$1Q, safe_not_equal, {});
  }
}
function create_default_slot$n(ctx) {
  let div7;
  let div6;
  let div4;
  let div1;
  let t3;
  let div2;
  let a0;
  let t5;
  let a1;
  let t7;
  let a2;
  let t9;
  let a3;
  let t11;
  let div3;
  let a4;
  let t12;
  let i4;
  let t13;
  let a5;
  let t14;
  let i5;
  let t15;
  let a6;
  let t16;
  let i6;
  let t17;
  let a7;
  let t18;
  let i7;
  let t19;
  let a8;
  let t20;
  let i8;
  let t21;
  let div5;
  let switch_instance;
  let current;
  var switch_value = ctx[1][ctx[0].module];
  function switch_props(ctx2) {
    return {};
  }
  if (switch_value) {
    switch_instance = new switch_value(switch_props());
  }
  return {
    c() {
      div7 = element("div");
      div6 = element("div");
      div4 = element("div");
      div1 = element("div");
      div1.innerHTML = `<button type="button" data-toggle="collapse" data-target="#sidebar" aria-expanded="false" aria-controls="sidebar" style="margin-bottom: 10px; width: 100%; outline: none !important;" class="btn btn-primary btn-text visible-xs collapsed"><span>Show Navigation</span> 
            <div>Hide Navigation</div></button>`;
      t3 = space();
      div2 = element("div");
      a0 = element("a");
      a0.innerHTML = `General<i class="fa fa-chevron-right right"></i>`;
      t5 = space();
      a1 = element("a");
      a1.innerHTML = `Actions<i class="fa fa-chevron-right right"></i>`;
      t7 = space();
      a2 = element("a");
      a2.innerHTML = `Devices<i class="fa fa-chevron-right right"></i>`;
      t9 = space();
      a3 = element("a");
      a3.innerHTML = `Advanced<i class="fa fa-chevron-right right"></i>`;
      t11 = space();
      div3 = element("div");
      a4 = element("a");
      t12 = text("Account");
      i4 = element("i");
      t13 = space();
      a5 = element("a");
      t14 = text("Alert Format");
      i5 = element("i");
      t15 = space();
      a6 = element("a");
      t16 = text("Billing");
      i6 = element("i");
      t17 = space();
      a7 = element("a");
      t18 = text("Emails and Phones");
      i7 = element("i");
      t19 = space();
      a8 = element("a");
      t20 = text("Profile");
      i8 = element("i");
      t21 = space();
      div5 = element("div");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      set_style(div1, "text-align", "center");
      attr(div1, "class", "wrapper");
      attr(a0, "href", "#/settings/general/");
      attr(a0, "class", "list-group-item");
      toggle_class(a0, "active", ctx[0].module == "general");
      attr(a1, "href", "#/settings/actions/");
      attr(a1, "class", "list-group-item");
      toggle_class(a1, "active", ctx[0].module == "actions");
      attr(a2, "href", "#/settings/devices/");
      attr(a2, "class", "list-group-item");
      toggle_class(a2, "active", ctx[0].module == "devices");
      attr(a3, "href", "#/settings/advanced/");
      attr(a3, "class", "list-group-item");
      toggle_class(a3, "active", ctx[0].module == "advanced");
      attr(div2, "class", "list-group collapse dont-collapse-sm");
      attr(i4, "class", "fa fa-external-link right");
      attr(a4, "href", URL_ROOT + "#/settings/account/");
      attr(a4, "class", "list-group-item");
      attr(a4, "target", "_blank");
      attr(i5, "class", "fa fa-external-link right");
      attr(a5, "href", URL_ROOT + "#/settings/actions/");
      attr(a5, "class", "list-group-item");
      attr(a5, "target", "_blank");
      attr(i6, "class", "fa fa-external-link right");
      attr(a6, "href", URL_ROOT + "#/settings/billing/");
      attr(a6, "class", "list-group-item");
      attr(a6, "target", "_blank");
      attr(i7, "class", "fa fa-external-link right");
      attr(a7, "href", URL_ROOT + "#/settings/emails_phones/");
      attr(a7, "class", "list-group-item");
      attr(a7, "target", "_blank");
      attr(i8, "class", "fa fa-external-link right");
      attr(a8, "href", URL_ROOT + "#/settings/profile/");
      attr(a8, "class", "list-group-item");
      attr(a8, "target", "_blank");
      attr(div3, "class", "list-group collapse dont-collapse-sm");
      attr(div4, "class", "col-sm-3");
      attr(div5, "class", "col-sm-9");
      attr(div6, "class", "row");
      attr(div7, "class", "container");
    },
    m(target, anchor) {
      insert(target, div7, anchor);
      append(div7, div6);
      append(div6, div4);
      append(div4, div1);
      append(div4, t3);
      append(div4, div2);
      append(div2, a0);
      append(div2, t5);
      append(div2, a1);
      append(div2, t7);
      append(div2, a2);
      append(div2, t9);
      append(div2, a3);
      append(div4, t11);
      append(div4, div3);
      append(div3, a4);
      append(a4, t12);
      append(a4, i4);
      append(div3, t13);
      append(div3, a5);
      append(a5, t14);
      append(a5, i5);
      append(div3, t15);
      append(div3, a6);
      append(a6, t16);
      append(a6, i6);
      append(div3, t17);
      append(div3, a7);
      append(a7, t18);
      append(a7, i7);
      append(div3, t19);
      append(div3, a8);
      append(a8, t20);
      append(a8, i8);
      append(div6, t21);
      append(div6, div5);
      if (switch_instance) {
        mount_component(switch_instance, div5, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 1) {
        toggle_class(a0, "active", ctx2[0].module == "general");
      }
      if (dirty & 1) {
        toggle_class(a1, "active", ctx2[0].module == "actions");
      }
      if (dirty & 1) {
        toggle_class(a2, "active", ctx2[0].module == "devices");
      }
      if (dirty & 1) {
        toggle_class(a3, "active", ctx2[0].module == "advanced");
      }
      if (switch_value !== (switch_value = ctx2[1][ctx2[0].module])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = new switch_value(switch_props());
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div5, null);
        } else {
          switch_instance = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div7);
      if (switch_instance)
        destroy_component(switch_instance);
    }
  };
}
function create_extra_slot$5(ctx) {
  let topbar;
  let current;
  topbar = new Topbar$1({ props: { title: "Settings" } });
  return {
    c() {
      create_component(topbar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(topbar, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(topbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(topbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(topbar, detaching);
    }
  };
}
function create_fragment$1P(ctx) {
  let layout;
  let current;
  layout = new Layout({
    props: {
      $$slots: {
        extra: [create_extra_slot$5],
        default: [create_default_slot$n]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(layout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(layout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const layout_changes = {};
      if (dirty & 5) {
        layout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layout.$set(layout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(layout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(layout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(layout, detaching);
    }
  };
}
function instance$1H($$self, $$props, $$invalidate) {
  let { params: params2 } = $$props;
  const components = {
    actions: ActionsExt_1,
    advanced: AdvancedExt,
    devices: Devices,
    general: GeneralExt
  };
  $$self.$$set = ($$props2) => {
    if ("params" in $$props2)
      $$invalidate(0, params2 = $$props2.params);
  };
  return [params2, components];
}
class Index_ext extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1H, create_fragment$1P, safe_not_equal, { params: 0 });
  }
}
var ConfirmBtn_svelte_svelte_type_style_lang = "";
function create_if_block$P(ctx) {
  let ul;
  let t0;
  let li0;
  let a0;
  let t1;
  let t2;
  let li1;
  let a1;
  let t3;
  let mounted;
  let dispose;
  let if_block = ctx[2] && create_if_block_1$v(ctx);
  return {
    c() {
      ul = element("ul");
      if (if_block)
        if_block.c();
      t0 = space();
      li0 = element("li");
      a0 = element("a");
      t1 = text("No");
      t2 = space();
      li1 = element("li");
      a1 = element("a");
      t3 = text("Yes");
      attr(a0, "href", href$3);
      attr(a1, "href", href$3);
      attr(a1, "class", "del svelte-wvb0dh");
      attr(ul, "class", "dropdown-menu");
      toggle_class(ul, "dropdown-menu-right", ctx[0]);
    },
    m(target, anchor) {
      insert(target, ul, anchor);
      if (if_block)
        if_block.m(ul, null);
      append(ul, t0);
      append(ul, li0);
      append(li0, a0);
      append(a0, t1);
      append(ul, t2);
      append(ul, li1);
      append(li1, a1);
      append(a1, t3);
      if (!mounted) {
        dispose = [
          listen(a0, "click", ctx[6]),
          listen(a1, "click", ctx[11]),
          listen(a1, "click", ctx[6])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1$v(ctx2);
          if_block.c();
          if_block.m(ul, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 1) {
        toggle_class(ul, "dropdown-menu-right", ctx2[0]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(ul);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_1$v(ctx) {
  let li;
  let t;
  return {
    c() {
      li = element("li");
      t = text(ctx[2]);
      attr(li, "class", "dropdown-header");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, t);
    },
    p(ctx2, dirty) {
      if (dirty & 4)
        set_data(t, ctx2[2]);
    },
    d(detaching) {
      if (detaching)
        detach(li);
    }
  };
}
function create_fragment$1O(ctx) {
  let div;
  let button;
  let button_class_value;
  let t;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[10].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[9], null);
  let if_block = ctx[4] && create_if_block$P(ctx);
  return {
    c() {
      div = element("div");
      button = element("button");
      if (default_slot)
        default_slot.c();
      t = space();
      if (if_block)
        if_block.c();
      attr(button, "class", button_class_value = "btn btn-default " + ctx[1] + " svelte-wvb0dh");
      button.disabled = ctx[4];
      attr(div, "class", "dropdown open inline");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      if (default_slot) {
        default_slot.m(button, null);
      }
      append(div, t);
      if (if_block)
        if_block.m(div, null);
      ctx[12](div);
      current = true;
      if (!mounted) {
        dispose = [
          listen(window, "keydown", ctx[7]),
          listen(window, "mousedown", ctx[8]),
          listen(button, "click", ctx[5])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 512)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[9], !current ? get_all_dirty_from_scope(ctx2[9]) : get_slot_changes(default_slot_template, ctx2[9], dirty, null), null);
        }
      }
      if (!current || dirty & 2 && button_class_value !== (button_class_value = "btn btn-default " + ctx2[1] + " svelte-wvb0dh")) {
        attr(button, "class", button_class_value);
      }
      if (!current || dirty & 16) {
        button.disabled = ctx2[4];
      }
      if (ctx2[4]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$P(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d();
      ctx[12](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
let href$3 = "#";
function instance$1G($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { alignRight = false } = $$props;
  let { class: clazz = "" } = $$props;
  let { msg = "" } = $$props;
  let el;
  let confirm2 = false;
  function onConfirm(e) {
    $$invalidate(4, confirm2 = true);
    e.preventDefault();
  }
  function onAClick(e) {
    e.preventDefault();
    $$invalidate(4, confirm2 = false);
  }
  function onKeydown(e) {
    if (e.key === "Escape") {
      $$invalidate(4, confirm2 = false);
    }
  }
  function onMouseDown(e) {
    if (!el.contains(e.target)) {
      $$invalidate(4, confirm2 = false);
    }
  }
  function click_handler2(event) {
    bubble.call(this, $$self, event);
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(3, el);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("alignRight" in $$props2)
      $$invalidate(0, alignRight = $$props2.alignRight);
    if ("class" in $$props2)
      $$invalidate(1, clazz = $$props2.class);
    if ("msg" in $$props2)
      $$invalidate(2, msg = $$props2.msg);
    if ("$$scope" in $$props2)
      $$invalidate(9, $$scope = $$props2.$$scope);
  };
  return [
    alignRight,
    clazz,
    msg,
    el,
    confirm2,
    onConfirm,
    onAClick,
    onKeydown,
    onMouseDown,
    $$scope,
    slots,
    click_handler2,
    div_binding
  ];
}
class ConfirmBtn extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1G, create_fragment$1O, safe_not_equal, { alignRight: 0, class: 1, msg: 2 });
  }
}
function portal(el, target = "body") {
  let targetEl;
  async function update(newTarget) {
    target = newTarget;
    if (typeof target === "string") {
      targetEl = document.querySelector(target);
      if (targetEl === null) {
        await tick();
        targetEl = document.querySelector(target);
      }
      if (targetEl === null) {
        throw new Error(`No element found matching css selector: "${target}"`);
      }
    } else if (target instanceof HTMLElement) {
      targetEl = target;
    } else {
      throw new TypeError(`Unknown portal target type: ${target === null ? "null" : typeof target}. Allowed types: string (CSS selector) or HTMLElement.`);
    }
    targetEl.appendChild(el);
    el.hidden = false;
  }
  function destroy() {
    if (el.parentNode) {
      el.parentNode.removeChild(el);
    }
  }
  update(target);
  return { update, destroy };
}
var Modal_svelte_svelte_type_style_lang$1 = "";
const get_buttons_slot_changes = (dirty) => ({});
const get_buttons_slot_context = (ctx) => ({});
const get_header_slot_changes$2 = (dirty) => ({});
const get_header_slot_context$2 = (ctx) => ({});
function create_fragment$1N(ctx) {
  let div5;
  let div4;
  let div3;
  let div0;
  let button0;
  let t1;
  let h4;
  let t2;
  let div1;
  let t3;
  let div2;
  let t4;
  let button1;
  let current;
  let mounted;
  let dispose;
  const header_slot_template = ctx[5].header;
  const header_slot = create_slot(header_slot_template, ctx, ctx[4], get_header_slot_context$2);
  const default_slot_template = ctx[5].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[4], null);
  const buttons_slot_template = ctx[5].buttons;
  const buttons_slot = create_slot(buttons_slot_template, ctx, ctx[4], get_buttons_slot_context);
  return {
    c() {
      div5 = element("div");
      div4 = element("div");
      div3 = element("div");
      div0 = element("div");
      button0 = element("button");
      button0.innerHTML = `<span aria-hidden="true">\xD7</span>`;
      t1 = space();
      h4 = element("h4");
      if (header_slot)
        header_slot.c();
      t2 = space();
      div1 = element("div");
      if (default_slot)
        default_slot.c();
      t3 = space();
      div2 = element("div");
      if (buttons_slot)
        buttons_slot.c();
      t4 = space();
      button1 = element("button");
      button1.textContent = `${T("a_cancel")}`;
      attr(button0, "type", "button");
      attr(button0, "class", "close");
      attr(button0, "data-dismiss", "modal");
      attr(button0, "aria-label", "Close");
      attr(h4, "class", "modal-title");
      attr(div0, "class", "modal-header");
      attr(div1, "class", "modal-body");
      attr(button1, "type", "button");
      attr(button1, "class", "btn btn-default");
      button1.autofocus = true;
      attr(div2, "class", "modal-footer flex svelte-2d6d73");
      attr(div3, "class", "modal-content");
      attr(div4, "class", "modal-dialog");
      attr(div4, "role", "document");
      attr(div5, "class", "modal svelte-2d6d73");
      attr(div5, "tabindex", "-1");
      attr(div5, "role", "dialog");
      set_style(div5, "display", "block");
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div4);
      append(div4, div3);
      append(div3, div0);
      append(div0, button0);
      append(div0, t1);
      append(div0, h4);
      if (header_slot) {
        header_slot.m(h4, null);
      }
      append(div3, t2);
      append(div3, div1);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      append(div3, t3);
      append(div3, div2);
      if (buttons_slot) {
        buttons_slot.m(div2, null);
      }
      append(div2, t4);
      append(div2, button1);
      ctx[7](div5);
      current = true;
      button1.focus();
      if (!mounted) {
        dispose = [
          listen(window, "keydown", ctx[3]),
          listen(button0, "click", ctx[2]),
          listen(button1, "click", ctx[2]),
          listen(div4, "click", click_handler),
          listen(div5, "click", ctx[6]),
          action_destroyer(portal.call(null, div5))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (header_slot) {
        if (header_slot.p && (!current || dirty & 16)) {
          update_slot_base(header_slot, header_slot_template, ctx2, ctx2[4], !current ? get_all_dirty_from_scope(ctx2[4]) : get_slot_changes(header_slot_template, ctx2[4], dirty, get_header_slot_changes$2), get_header_slot_context$2);
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 16)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[4], !current ? get_all_dirty_from_scope(ctx2[4]) : get_slot_changes(default_slot_template, ctx2[4], dirty, null), null);
        }
      }
      if (buttons_slot) {
        if (buttons_slot.p && (!current || dirty & 16)) {
          update_slot_base(buttons_slot, buttons_slot_template, ctx2, ctx2[4], !current ? get_all_dirty_from_scope(ctx2[4]) : get_slot_changes(buttons_slot_template, ctx2[4], dirty, get_buttons_slot_changes), get_buttons_slot_context);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(header_slot, local);
      transition_in(default_slot, local);
      transition_in(buttons_slot, local);
      current = true;
    },
    o(local) {
      transition_out(header_slot, local);
      transition_out(default_slot, local);
      transition_out(buttons_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div5);
      if (header_slot)
        header_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      if (buttons_slot)
        buttons_slot.d(detaching);
      ctx[7](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
const click_handler = (e) => e.stopPropagation();
function instance$1F($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { closeOnClickOut = false } = $$props;
  const dispatch = createEventDispatcher();
  const onClose = () => dispatch("close");
  let modal;
  const onKeydown = (e) => {
    if (e.key === "Escape") {
      onClose();
      return;
    }
    if (e.key === "Tab") {
      const nodes = modal.querySelectorAll("*");
      const tabbable = Array.from(nodes).filter((n) => n.tabIndex >= 0);
      let index2 = tabbable.indexOf(document.activeElement);
      if (index2 === -1 && e.shiftKey)
        index2 = 0;
      index2 += tabbable.length + (e.shiftKey ? -1 : 1);
      index2 %= tabbable.length;
      tabbable[index2].focus();
      e.preventDefault();
    }
  };
  const lastFocused = document.activeElement;
  if (lastFocused) {
    onDestroy(() => {
      lastFocused.focus();
    });
  }
  const click_handler_1 = (e) => closeOnClickOut && onClose();
  function div5_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      modal = $$value;
      $$invalidate(1, modal);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("closeOnClickOut" in $$props2)
      $$invalidate(0, closeOnClickOut = $$props2.closeOnClickOut);
    if ("$$scope" in $$props2)
      $$invalidate(4, $$scope = $$props2.$$scope);
  };
  return [
    closeOnClickOut,
    modal,
    onClose,
    onKeydown,
    $$scope,
    slots,
    click_handler_1,
    div5_binding
  ];
}
class Modal$2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1F, create_fragment$1N, safe_not_equal, { closeOnClickOut: 0 });
  }
}
function create_if_block$O(ctx) {
  let div;
  let t0;
  let t1_value = (ctx[2].message || JSON.stringify(ctx[2])) + "";
  let t1;
  let t2;
  return {
    c() {
      div = element("div");
      t0 = text("Please try again later. Error: ");
      t1 = text(t1_value);
      t2 = text(".");
      attr(div, "class", "error");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      append(div, t2);
    },
    p(ctx2, dirty) {
      if (dirty & 4 && t1_value !== (t1_value = (ctx2[2].message || JSON.stringify(ctx2[2])) + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_default_slot$m(ctx) {
  let div;
  let t;
  let current;
  const default_slot_template = ctx[5].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[8], null);
  let if_block = ctx[2] && create_if_block$O(ctx);
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      t = space();
      if (if_block)
        if_block.c();
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      append(div, t);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 256)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[8], !current ? get_all_dirty_from_scope(ctx2[8]) : get_slot_changes(default_slot_template, ctx2[8], dirty, null), null);
        }
      }
      if (ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$O(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d();
    }
  };
}
function create_header_slot$4(ctx) {
  let div;
  let t;
  return {
    c() {
      div = element("div");
      t = text(ctx[0]);
      attr(div, "slot", "header");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & 1)
        set_data(t, ctx2[0]);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_buttons_slot$1(ctx) {
  let div;
  let button;
  let t_value = T(ctx[1] ? "l_loading" : "a_save") + "";
  let t;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button = element("button");
      t = text(t_value);
      attr(button, "type", "button");
      attr(button, "class", "btn btn-primary");
      button.disabled = ctx[1];
      attr(div, "slot", "buttons");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      append(button, t);
      if (!mounted) {
        dispose = listen(button, "click", ctx[3]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t_value !== (t_value = T(ctx2[1] ? "l_loading" : "a_save") + ""))
        set_data(t, t_value);
      if (dirty & 2) {
        button.disabled = ctx2[1];
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$1M(ctx) {
  let modal;
  let current;
  modal = new Modal$2({
    props: {
      $$slots: {
        buttons: [create_buttons_slot$1],
        header: [create_header_slot$4],
        default: [create_default_slot$m]
      },
      $$scope: { ctx }
    }
  });
  modal.$on("close", ctx[6]);
  modal.$on("save", ctx[7]);
  return {
    c() {
      create_component(modal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modal_changes = {};
      if (dirty & 263) {
        modal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal.$set(modal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal, detaching);
    }
  };
}
function instance$1E($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { title = "Edit" } = $$props;
  let { onSave } = $$props;
  let saving = false;
  let error = false;
  async function onSaveClick() {
    $$invalidate(1, saving = true);
    $$invalidate(2, error = false);
    try {
      await onSave();
      $$invalidate(1, saving = false);
    } catch (e) {
      console.error(e);
      $$invalidate(2, error = e);
    }
  }
  function close_handler(event) {
    bubble.call(this, $$self, event);
  }
  function save_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("onSave" in $$props2)
      $$invalidate(4, onSave = $$props2.onSave);
    if ("$$scope" in $$props2)
      $$invalidate(8, $$scope = $$props2.$$scope);
  };
  return [
    title,
    saving,
    error,
    onSaveClick,
    onSave,
    slots,
    close_handler,
    save_handler,
    $$scope
  ];
}
class SaveModal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1E, create_fragment$1M, safe_not_equal, { title: 0, onSave: 4 });
  }
}
function create_if_block_2$i(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "checkbox");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      input.checked = ctx[0].permissions.edit;
      if (!mounted) {
        dispose = [
          listen(input, "change", ctx[7]),
          listen(input, "change", ctx[8])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1) {
        input.checked = ctx2[0].permissions.edit;
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_1$u(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "checkbox");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      input.checked = ctx[0].permissions.admin;
      if (!mounted) {
        dispose = [
          listen(input, "change", ctx[9]),
          listen(input, "change", ctx[10])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1) {
        input.checked = ctx2[0].permissions.admin;
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$N(ctx) {
  let confirmbtn;
  let current;
  confirmbtn = new ConfirmBtn({
    props: {
      $$slots: { default: [create_default_slot$l] },
      $$scope: { ctx }
    }
  });
  confirmbtn.$on("click", ctx[4]);
  return {
    c() {
      create_component(confirmbtn.$$.fragment);
    },
    m(target, anchor) {
      mount_component(confirmbtn, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const confirmbtn_changes = {};
      if (dirty & 4096) {
        confirmbtn_changes.$$scope = { dirty, ctx: ctx2 };
      }
      confirmbtn.$set(confirmbtn_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(confirmbtn.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(confirmbtn.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(confirmbtn, detaching);
    }
  };
}
function create_default_slot$l(ctx) {
  let t;
  return {
    c() {
      t = text("Remove User");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_fragment$1L(ctx) {
  let tr;
  let td0;
  let t0_value = ctx[0].full_name + "";
  let t0;
  let t1;
  let td1;
  let t2_value = ctx[0].email + "";
  let t2;
  let t3;
  let td2;
  let t4;
  let td3;
  let t5;
  let td4;
  let current;
  let if_block0 = !ctx[3] && ctx[1].permissions.admin && create_if_block_2$i(ctx);
  let if_block1 = !ctx[3] && ctx[1].permissions.admin && create_if_block_1$u(ctx);
  let if_block2 = ctx[0].id != ctx[2].id && ctx[1].permissions.admin && create_if_block$N(ctx);
  return {
    c() {
      tr = element("tr");
      td0 = element("td");
      t0 = text(t0_value);
      t1 = space();
      td1 = element("td");
      t2 = text(t2_value);
      t3 = space();
      td2 = element("td");
      if (if_block0)
        if_block0.c();
      t4 = space();
      td3 = element("td");
      if (if_block1)
        if_block1.c();
      t5 = space();
      td4 = element("td");
      if (if_block2)
        if_block2.c();
      attr(td0, "class", "pa3");
      set_style(td0, "border-bottom", "solid 1px #ccc");
      attr(td1, "class", "pa3");
      set_style(td1, "border-bottom", "solid 1px #ccc");
      attr(td2, "class", "pa3");
      set_style(td2, "border-bottom", "solid 1px #ccc");
      set_style(td3, "padding", "5px");
      set_style(td3, "border-bottom", "solid 1px #ccc");
      set_style(td4, "padding", "5px");
      set_style(td4, "border-bottom", "solid 1px #ccc");
      set_style(tr, "height", "50px");
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td0);
      append(td0, t0);
      append(tr, t1);
      append(tr, td1);
      append(td1, t2);
      append(tr, t3);
      append(tr, td2);
      if (if_block0)
        if_block0.m(td2, null);
      append(tr, t4);
      append(tr, td3);
      if (if_block1)
        if_block1.m(td3, null);
      append(tr, t5);
      append(tr, td4);
      if (if_block2)
        if_block2.m(td4, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & 1) && t0_value !== (t0_value = ctx2[0].full_name + ""))
        set_data(t0, t0_value);
      if ((!current || dirty & 1) && t2_value !== (t2_value = ctx2[0].email + ""))
        set_data(t2, t2_value);
      if (!ctx2[3] && ctx2[1].permissions.admin) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_2$i(ctx2);
          if_block0.c();
          if_block0.m(td2, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (!ctx2[3] && ctx2[1].permissions.admin) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_1$u(ctx2);
          if_block1.c();
          if_block1.m(td3, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (ctx2[0].id != ctx2[2].id && ctx2[1].permissions.admin) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & 3) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block$N(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(td4, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(tr);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
    }
  };
}
function instance$1D($$self, $$props, $$invalidate) {
  let { group } = $$props;
  let { user } = $$props;
  let { reload } = $$props;
  const USER2 = getContext$1("user");
  const isSelf = user.id == USER2.id;
  async function onRemoveClick() {
    await Api.api(`/groups/${group.id}/unsubscribe/${user.id}`, "DELETE");
    reload();
  }
  async function onChangeRole(e, context) {
    if (context == "admin") {
      if (e.target.checked) {
        await saveRole(user.id, { admin: true, edit: true });
      } else {
        await saveRole(user.id, { admin: false, edit: true });
      }
    } else if (context == "edit") {
      if (e.target.checked) {
        await saveRole(user.id, { admin: false, edit: true });
      } else {
        await saveRole(user.id, { admin: false, edit: false });
      }
    }
    reload();
  }
  async function saveRole(id2, permissions) {
    try {
      await Api.api(`/groups/${group.id}/role/${id2}`, "PUT", permissions);
      reload();
    } catch (e) {
      console.error(e);
    }
  }
  const change_handler = (e) => onChangeRole(e, "edit");
  function input_change_handler() {
    user.permissions.edit = this.checked;
    $$invalidate(0, user);
  }
  const change_handler_1 = (e) => onChangeRole(e, "admin");
  function input_change_handler_1() {
    user.permissions.admin = this.checked;
    $$invalidate(0, user);
  }
  $$self.$$set = ($$props2) => {
    if ("group" in $$props2)
      $$invalidate(1, group = $$props2.group);
    if ("user" in $$props2)
      $$invalidate(0, user = $$props2.user);
    if ("reload" in $$props2)
      $$invalidate(6, reload = $$props2.reload);
  };
  return [
    user,
    group,
    USER2,
    isSelf,
    onRemoveClick,
    onChangeRole,
    reload,
    change_handler,
    input_change_handler,
    change_handler_1,
    input_change_handler_1
  ];
}
class TeamUser extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1D, create_fragment$1L, safe_not_equal, { group: 1, user: 0, reload: 6 });
  }
}
var Team_svelte_svelte_type_style_lang = "";
function get_each_context$q(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i2];
  return child_ctx;
}
function create_catch_block$c(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$c(ctx) {
  let div9;
  let div3;
  let div0;
  let t0;
  let div1;
  let button;
  let t2;
  let div2;
  let t3;
  let div8;
  let div4;
  let t4;
  let div6;
  let div5;
  let h4;
  let t5;
  let t6_value = ctx[1].name + "";
  let t6;
  let t7;
  let t8;
  let table;
  let thead;
  let t18;
  let tbody;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t19;
  let t20;
  let div7;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[1].permissions.admin && create_if_block_2$h(ctx);
  let each_value = ctx[0];
  const get_key = (ctx2) => ctx2[8].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$q(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$q(key, child_ctx));
  }
  let if_block1 = ctx[1].permissions.admin && create_if_block_1$t(ctx);
  return {
    c() {
      div9 = element("div");
      div3 = element("div");
      div0 = element("div");
      t0 = space();
      div1 = element("div");
      button = element("button");
      button.innerHTML = `<i class="fa fa-caret-left mr2" aria-hidden="true"></i> Back`;
      t2 = space();
      div2 = element("div");
      t3 = space();
      div8 = element("div");
      div4 = element("div");
      t4 = space();
      div6 = element("div");
      div5 = element("div");
      h4 = element("h4");
      t5 = text("Team: ");
      t6 = text(t6_value);
      t7 = space();
      if (if_block0)
        if_block0.c();
      t8 = space();
      table = element("table");
      thead = element("thead");
      thead.innerHTML = `<tr><th class="pa3 svelte-15nnkot">Name</th> 
                <th class="pa3 svelte-15nnkot">Email</th> 
                <th class="pa3 svelte-15nnkot">Edit</th> 
                <th class="pa3 svelte-15nnkot">Admin</th> 
                <th class="pa3 svelte-15nnkot" style="width: 300px;">Remove</th></tr>`;
      t18 = space();
      tbody = element("tbody");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t19 = space();
      if (if_block1)
        if_block1.c();
      t20 = space();
      div7 = element("div");
      attr(div0, "class", "col-md-2");
      attr(button, "class", "btn btn-default");
      attr(button, "type", "button");
      attr(div1, "class", "col-md-2");
      attr(div2, "class", "col-md-8");
      attr(div3, "class", "row");
      attr(div4, "class", "col-md-2");
      attr(div5, "class", "page-header");
      set_style(table, "width", "100%");
      set_style(table, "margin-bottom", "40px");
      attr(div6, "class", "col-md-8");
      attr(div7, "class", "col-md-2");
      attr(div8, "class", "row");
      attr(div9, "class", "container-fluid");
    },
    m(target, anchor) {
      insert(target, div9, anchor);
      append(div9, div3);
      append(div3, div0);
      append(div3, t0);
      append(div3, div1);
      append(div1, button);
      append(div3, t2);
      append(div3, div2);
      append(div9, t3);
      append(div9, div8);
      append(div8, div4);
      append(div8, t4);
      append(div8, div6);
      append(div6, div5);
      append(div5, h4);
      append(h4, t5);
      append(h4, t6);
      append(h4, t7);
      if (if_block0)
        if_block0.m(h4, null);
      append(div6, t8);
      append(div6, table);
      append(table, thead);
      append(table, t18);
      append(table, tbody);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(tbody, null);
      }
      append(div6, t19);
      if (if_block1)
        if_block1.m(div6, null);
      append(div8, t20);
      append(div8, div7);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[11]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if ((!current || dirty & 2) && t6_value !== (t6_value = ctx2[1].name + ""))
        set_data(t6, t6_value);
      if (ctx2[1].permissions.admin) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_2$h(ctx2);
          if_block0.c();
          if_block0.m(h4, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty & 131) {
        each_value = ctx2[0];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, tbody, outro_and_destroy_block, create_each_block$q, null, get_each_context$q);
        check_outros();
      }
      if (ctx2[1].permissions.admin) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_1$t(ctx2);
          if_block1.c();
          if_block1.m(div6, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div9);
      if (if_block0)
        if_block0.d();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      if (if_block1)
        if_block1.d();
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_2$h(ctx) {
  let a;
  let mounted;
  let dispose;
  return {
    c() {
      a = element("a");
      a.textContent = "Edit";
      attr(a, "class", "f6");
      attr(a, "href", "#");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      if (!mounted) {
        dispose = listen(a, "click", ctx[5]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(a);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block$q(key_1, ctx) {
  let first;
  let teamuser;
  let current;
  teamuser = new TeamUser({
    props: {
      user: ctx[8],
      group: ctx[1],
      reload: ctx[7]
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(teamuser.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(teamuser, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const teamuser_changes = {};
      if (dirty & 1)
        teamuser_changes.user = ctx[8];
      if (dirty & 2)
        teamuser_changes.group = ctx[1];
      teamuser.$set(teamuser_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(teamuser.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(teamuser.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      destroy_component(teamuser, detaching);
    }
  };
}
function create_if_block_1$t(ctx) {
  let input;
  return {
    c() {
      input = element("input");
      attr(input, "placeholder", "Add User");
      attr(input, "type", "text");
      attr(input, "autocomplete", "off");
      attr(input, "class", "form-control");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      ctx[12](input);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(input);
      ctx[12](null);
    }
  };
}
function create_pending_block$c(ctx) {
  let t;
  return {
    c() {
      t = text("Loading...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_1$8(ctx) {
  let await_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$c,
    then: create_then_block$c,
    catch: create_catch_block$c,
    blocks: [, , ,]
  };
  handle_promise(ctx[4], info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function create_extra_slot$4(ctx) {
  let topbar;
  let current;
  topbar = new Topbar$1({ props: { title: "Manage Team" } });
  return {
    c() {
      create_component(topbar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(topbar, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(topbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(topbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(topbar, detaching);
    }
  };
}
function create_if_block$M(ctx) {
  let savemodal;
  let current;
  savemodal = new SaveModal({
    props: {
      title: "Edit Team Name",
      onSave: ctx[6],
      $$slots: { default: [create_default_slot$k] },
      $$scope: { ctx }
    }
  });
  savemodal.$on("close", ctx[14]);
  return {
    c() {
      create_component(savemodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(savemodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const savemodal_changes = {};
      if (dirty & 1048578) {
        savemodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      savemodal.$set(savemodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(savemodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(savemodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(savemodal, detaching);
    }
  };
}
function create_default_slot$k(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      input.autofocus = true;
      attr(input, "class", "form-control");
      attr(input, "type", "text");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(input, ctx[1].name);
      input.focus();
      if (!mounted) {
        dispose = listen(input, "input", ctx[13]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 2 && input.value !== ctx2[1].name) {
        set_input_value(input, ctx2[1].name);
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$1K(ctx) {
  let layout;
  let t;
  let if_block_anchor;
  let current;
  layout = new Layout({
    props: {
      $$slots: {
        extra: [create_extra_slot$4],
        default: [create_default_slot_1$8]
      },
      $$scope: { ctx }
    }
  });
  let if_block = ctx[2] && create_if_block$M(ctx);
  return {
    c() {
      create_component(layout.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(layout, target, anchor);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const layout_changes = {};
      if (dirty & 1048587) {
        layout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layout.$set(layout_changes);
      if (ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$M(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(layout.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(layout.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      destroy_component(layout, detaching);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$1C($$self, $$props, $$invalidate) {
  let $user;
  let { params: params2 = null } = $$props;
  const user = getContext$1("user");
  component_subscribe($$self, user, (value) => $$invalidate(10, $user = value));
  let users = [];
  let nonMembers = [];
  let group;
  let promiseLoad = reload();
  let editingName = false;
  let elUserInput;
  afterUpdate(async () => {
    await promiseLoad;
    window.$(elUserInput).atwho({
      at: "",
      data: nonMembers,
      displayTpl: "<li data-id=${id} data-full_name=${full_name}>${full_name} - ${email}</li>",
      searchKey: "full_name",
      callbacks: {
        beforeInsert: (value, $li) => {
          subscribe2($li.data("id"));
          return "";
        }
      }
    });
  });
  function changeName(e) {
    e.preventDefault();
    $$invalidate(2, editingName = true);
  }
  async function onSaveName() {
    $$invalidate(2, editingName = false);
    await Api.api(`/groups/${group.id}`, "PATCH", { name: group.name });
  }
  async function reload() {
    $$invalidate(1, group = await Api.api(`/groups/${params2.id}`));
    const resUsersGroup = await Api.api(`/groups/${group.id}/users`);
    $$invalidate(0, users = resUsersGroup.data);
    const resUsersAll = await Api.api(`/accounts/users`);
    let usersAll = resUsersAll.data;
    let ids = users.map((u) => u.id);
    nonMembers = usersAll.filter((u) => !ids.includes(u.id));
  }
  async function subscribe2(user_id) {
    try {
      const response = await Api.api(`/groups/${group.id}/subscribe`, "POST", { user_id, admin: false, edit: true });
      await reload();
    } catch (e) {
      console.error(e);
    }
  }
  const click_handler2 = (e) => history.back();
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elUserInput = $$value;
      $$invalidate(3, elUserInput);
    });
  }
  function input_input_handler() {
    group.name = this.value;
    $$invalidate(1, group);
  }
  const close_handler = (e) => $$invalidate(2, editingName = false);
  $$self.$$set = ($$props2) => {
    if ("params" in $$props2)
      $$invalidate(9, params2 = $$props2.params);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1024) {
      !!$user.account_id;
    }
  };
  return [
    users,
    group,
    editingName,
    elUserInput,
    promiseLoad,
    changeName,
    onSaveName,
    reload,
    user,
    params2,
    $user,
    click_handler2,
    input_binding,
    input_input_handler,
    close_handler
  ];
}
class Team extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1C, create_fragment$1K, safe_not_equal, { params: 9 });
  }
}
function create_fragment$1J(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "This account is not subscribed to an Enterprise plan. If your company has an Enterprise account with us or need to get one, please contact support.";
      attr(div, "class", "alert alert-info ma4");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
class EnterpriseOnly extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$1J, safe_not_equal, {});
  }
}
var index_svelte_svelte_type_style_lang = "";
function get_each_context$p(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[18] = list[i2];
  return child_ctx;
}
function create_else_block$t(ctx) {
  let div12;
  let div11;
  let div10;
  let div0;
  let t0;
  let div8;
  let div5;
  let t8;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t9;
  let form;
  let div6;
  let input;
  let t10;
  let t11;
  let div7;
  let button;
  let t13;
  let div9;
  let current;
  let mounted;
  let dispose;
  let each_value = ctx[0];
  const get_key = (ctx2) => ctx2[18].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$p(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$p(key, child_ctx));
  }
  let each_1_else = null;
  if (!each_value.length) {
    each_1_else = create_else_block_1$5();
  }
  let if_block = ctx[1] && create_if_block_1$s();
  return {
    c() {
      div12 = element("div");
      div11 = element("div");
      div10 = element("div");
      div0 = element("div");
      t0 = space();
      div8 = element("div");
      div5 = element("div");
      div5.innerHTML = `<div class="col-md-4"><h4>Team Name</h4></div> 
              <div class="col-md-2 text-center"><h4>Role</h4></div> 
              <div class="col-md-3 text-center"><h4>Leave Team</h4></div> 
              <div class="col-md-3 text-center"><h4>Delete Team</h4></div>`;
      t8 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      if (each_1_else) {
        each_1_else.c();
      }
      t9 = space();
      form = element("form");
      div6 = element("div");
      input = element("input");
      t10 = space();
      if (if_block)
        if_block.c();
      t11 = space();
      div7 = element("div");
      button = element("button");
      button.textContent = "Create New Team";
      t13 = space();
      div9 = element("div");
      attr(div0, "class", "col-md-2");
      attr(div5, "class", "row team svelte-grlz0z");
      attr(div5, "data-id", "");
      attr(input, "type", "text");
      attr(input, "class", "form-control");
      attr(input, "placeholder", "New Team Name");
      attr(div6, "class", "col-md-6");
      attr(button, "class", "btn btn-primary");
      attr(button, "type", "button");
      attr(div7, "class", "col-md-3 text-center");
      attr(form, "class", "row team svelte-grlz0z");
      attr(div8, "class", "col-md-8");
      attr(div9, "class", "col-md-2");
      attr(div10, "class", "row");
      attr(div11, "class", "group-table container-fluid");
      attr(div12, "class", "add-group");
      toggle_class(div12, "hide", !ctx[3]);
    },
    m(target, anchor) {
      insert(target, div12, anchor);
      append(div12, div11);
      append(div11, div10);
      append(div10, div0);
      append(div10, t0);
      append(div10, div8);
      append(div8, div5);
      append(div8, t8);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(div8, null);
      }
      if (each_1_else) {
        each_1_else.m(div8, null);
      }
      append(div8, t9);
      append(div8, form);
      append(form, div6);
      append(div6, input);
      set_input_value(input, ctx[2].name);
      append(div6, t10);
      if (if_block)
        if_block.m(div6, null);
      append(form, t11);
      append(form, div7);
      append(div7, button);
      append(div10, t13);
      append(div10, div9);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input, "input", ctx[12]),
          listen(button, "click", ctx[13]),
          listen(form, "submit", ctx[14])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 97) {
        each_value = ctx2[0];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div8, outro_and_destroy_block, create_each_block$p, t9, get_each_context$p);
        check_outros();
        if (!each_value.length && each_1_else) {
          each_1_else.p(ctx2, dirty);
        } else if (!each_value.length) {
          each_1_else = create_else_block_1$5();
          each_1_else.c();
          each_1_else.m(div8, t9);
        } else if (each_1_else) {
          each_1_else.d(1);
          each_1_else = null;
        }
      }
      if (dirty & 4 && input.value !== ctx2[2].name) {
        set_input_value(input, ctx2[2].name);
      }
      if (ctx2[1]) {
        if (if_block)
          ;
        else {
          if_block = create_if_block_1$s();
          if_block.c();
          if_block.m(div6, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 8) {
        toggle_class(div12, "hide", !ctx2[3]);
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div12);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      if (each_1_else)
        each_1_else.d();
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$L(ctx) {
  let entonly;
  let current;
  entonly = new EnterpriseOnly({});
  return {
    c() {
      create_component(entonly.$$.fragment);
    },
    m(target, anchor) {
      mount_component(entonly, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(entonly.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(entonly.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(entonly, detaching);
    }
  };
}
function create_else_block_1$5(ctx) {
  let div1;
  return {
    c() {
      div1 = element("div");
      div1.innerHTML = `<div class="col-md-9 alert alert-info ml3 mt2 mb2">Not part of any team. To be part of an existing team, please ask team admin to add you to the group.</div> 
              `;
      attr(div1, "class", "row team svelte-grlz0z");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div1);
    }
  };
}
function create_default_slot_2$3(ctx) {
  let t;
  return {
    c() {
      t = text("Leave");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_2$g(ctx) {
  let confirmbtn;
  let current;
  function click_handler_1(...args) {
    return ctx[11](ctx[18], ...args);
  }
  confirmbtn = new ConfirmBtn({
    props: {
      $$slots: { default: [create_default_slot_1$7] },
      $$scope: { ctx }
    }
  });
  confirmbtn.$on("click", click_handler_1);
  return {
    c() {
      create_component(confirmbtn.$$.fragment);
    },
    m(target, anchor) {
      mount_component(confirmbtn, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const confirmbtn_changes = {};
      if (dirty & 2097152) {
        confirmbtn_changes.$$scope = { dirty, ctx };
      }
      confirmbtn.$set(confirmbtn_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(confirmbtn.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(confirmbtn.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(confirmbtn, detaching);
    }
  };
}
function create_default_slot_1$7(ctx) {
  let t;
  return {
    c() {
      t = text("Delete");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_each_block$p(key_1, ctx) {
  let div4;
  let div0;
  let a;
  let t0_value = ctx[18].name + "";
  let t0;
  let a_href_value;
  let t1;
  let div1;
  let t2_value = checkRole(ctx[18]) + "";
  let t2;
  let t3;
  let div2;
  let confirmbtn;
  let t4;
  let div3;
  let t5;
  let current;
  function click_handler2(...args) {
    return ctx[10](ctx[18], ...args);
  }
  confirmbtn = new ConfirmBtn({
    props: {
      $$slots: { default: [create_default_slot_2$3] },
      $$scope: { ctx }
    }
  });
  confirmbtn.$on("click", click_handler2);
  let if_block = ctx[18].permissions.admin && create_if_block_2$g(ctx);
  return {
    key: key_1,
    first: null,
    c() {
      div4 = element("div");
      div0 = element("div");
      a = element("a");
      t0 = text(t0_value);
      t1 = space();
      div1 = element("div");
      t2 = text(t2_value);
      t3 = space();
      div2 = element("div");
      create_component(confirmbtn.$$.fragment);
      t4 = space();
      div3 = element("div");
      if (if_block)
        if_block.c();
      t5 = space();
      attr(a, "href", a_href_value = "#/teams/" + ctx[18].id);
      attr(div0, "class", "col-md-4");
      attr(div1, "class", "col-md-2 text-center ");
      attr(div2, "class", "col-md-3 text-center remove-user");
      attr(div3, "class", "col-md-3 text-center remove-user");
      attr(div4, "class", "row team svelte-grlz0z");
      this.first = div4;
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div0);
      append(div0, a);
      append(a, t0);
      append(div4, t1);
      append(div4, div1);
      append(div1, t2);
      append(div4, t3);
      append(div4, div2);
      mount_component(confirmbtn, div2, null);
      append(div4, t4);
      append(div4, div3);
      if (if_block)
        if_block.m(div3, null);
      append(div4, t5);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty & 1) && t0_value !== (t0_value = ctx[18].name + ""))
        set_data(t0, t0_value);
      if (!current || dirty & 1 && a_href_value !== (a_href_value = "#/teams/" + ctx[18].id)) {
        attr(a, "href", a_href_value);
      }
      if ((!current || dirty & 1) && t2_value !== (t2_value = checkRole(ctx[18]) + ""))
        set_data(t2, t2_value);
      const confirmbtn_changes = {};
      if (dirty & 2097152) {
        confirmbtn_changes.$$scope = { dirty, ctx };
      }
      confirmbtn.$set(confirmbtn_changes);
      if (ctx[18].permissions.admin) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_2$g(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div3, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(confirmbtn.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(confirmbtn.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div4);
      destroy_component(confirmbtn);
      if (if_block)
        if_block.d();
    }
  };
}
function create_if_block_1$s(ctx) {
  let p;
  return {
    c() {
      p = element("p");
      p.textContent = "Please enter a team name.";
      attr(p, "class", "error");
    },
    m(target, anchor) {
      insert(target, p, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
function create_default_slot$j(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$L, create_else_block$t];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!ctx2[3])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_extra_slot$3(ctx) {
  let topbar;
  let current;
  topbar = new Topbar$1({ props: { title: "Teams" } });
  return {
    c() {
      create_component(topbar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(topbar, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(topbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(topbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(topbar, detaching);
    }
  };
}
function create_fragment$1I(ctx) {
  let layout;
  let current;
  layout = new Layout({
    props: {
      $$slots: {
        extra: [create_extra_slot$3],
        default: [create_default_slot$j]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(layout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(layout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const layout_changes = {};
      if (dirty & 2097167) {
        layout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layout.$set(layout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(layout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(layout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(layout, detaching);
    }
  };
}
function checkRole({ permissions }) {
  if (permissions.admin) {
    return "Admin";
  } else if (permissions.edit) {
    return "Editor";
  } else {
    return "Viewer";
  }
}
function instance$1B($$self, $$props, $$invalidate) {
  let $user;
  let { params: params2 = null } = $$props;
  const user = getContext$1("user");
  component_subscribe($$self, user, (value) => $$invalidate(9, $user = value));
  let groups = [];
  let errEmptyTeam = false;
  let state = { name: "" };
  let isEnterprise = $user.account_id;
  fetchGroups();
  function validate() {
    $$invalidate(1, errEmptyTeam = false);
    let name = state.name;
    name = name.trim();
    if (!name || name == "") {
      $$invalidate(1, errEmptyTeam = true);
      return false;
    }
    return true;
  }
  async function fetchGroups() {
    let res2 = await Api.api("/groups", "GET", {
      user: { id: $user.id },
      _opt: { order: ["ts"] }
    });
    $$invalidate(0, groups = res2.data);
  }
  async function leaveGroup(id2) {
    await Api.api(`/groups/${id2}/unsubscribe`, "POST");
    fetchGroups();
  }
  async function deleteGroup(id2) {
    await Api.api(`/groups/${id2}`, "DELETE");
    fetchGroups();
  }
  function resetFieldData() {
    document.getElementById("new-team-field").value = "";
    $$invalidate(2, state.name = "", state);
  }
  async function addGroup() {
    const name = state.name;
    if (validate()) {
      await Api.api(`/groups`, "POST", { name });
      fetchGroups();
      resetFieldData();
    }
  }
  const click_handler2 = (group, e) => leaveGroup(group.id);
  const click_handler_1 = (group, e) => deleteGroup(group.id);
  function input_input_handler() {
    state.name = this.value;
    $$invalidate(2, state);
  }
  const click_handler_2 = () => addGroup();
  const submit_handler = (e) => addGroup();
  $$self.$$set = ($$props2) => {
    if ("params" in $$props2)
      $$invalidate(8, params2 = $$props2.params);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 512) {
      $$invalidate(3, isEnterprise = !!$user.account_id);
    }
  };
  return [
    groups,
    errEmptyTeam,
    state,
    isEnterprise,
    user,
    leaveGroup,
    deleteGroup,
    addGroup,
    params2,
    $user,
    click_handler2,
    click_handler_1,
    input_input_handler,
    click_handler_2,
    submit_handler
  ];
}
class Teams extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1B, create_fragment$1I, safe_not_equal, { params: 8 });
  }
}
function get_then_context(ctx) {
  ctx[3] = ctx[5][0];
  ctx[4] = ctx[5][1];
}
function create_catch_block$b(ctx) {
  return { c: noop, m: noop, p: noop, d: noop };
}
function create_then_block$b(ctx) {
  get_then_context(ctx);
  let div15;
  let div0;
  let t0;
  let a0;
  let t1;
  let t2;
  let table;
  let thead0;
  let t3;
  let thead1;
  let t9;
  let tbody;
  let tr1;
  let td0;
  let t11;
  let td1;
  let div1;
  let t12_value = ctx[3].item + "";
  let t12;
  let t13;
  let td2;
  let div2;
  let t14_value = ctx[4].item + "";
  let t14;
  let t15;
  let tr2;
  let td3;
  let t17;
  let td4;
  let div3;
  let t18_value = ctx[3].run + "";
  let t18;
  let t19;
  let td5;
  let div4;
  let t20_value = ctx[4].run + "";
  let t20;
  let t21;
  let tr3;
  let td6;
  let t23;
  let td7;
  let div5;
  let t24_value = ctx[3].sms + "";
  let t24;
  let t25;
  let td8;
  let div6;
  let t26_value = ctx[4].sms + "";
  let t26;
  let t27;
  let tr4;
  let td9;
  let t29;
  let td10;
  let div7;
  let t30_value = ctx[3].email + "";
  let t30;
  let t31;
  let td11;
  let div8;
  let t32_value = ctx[4].email + "";
  let t32;
  let t33;
  let tr5;
  let td12;
  let t35;
  let td13;
  let div9;
  let t36_value = ctx[3].action + "";
  let t36;
  let t37;
  let td14;
  let div10;
  let t38_value = ctx[4].action + "";
  let t38;
  let t39;
  let tr6;
  let td15;
  let t41;
  let td16;
  let div11;
  let t42_value = ctx[3].push + "";
  let t42;
  let t43;
  let td17;
  let div12;
  let t44_value = ctx[4].push + "";
  let t44;
  let t45;
  let div14;
  return {
    c() {
      div15 = element("div");
      div0 = element("div");
      t0 = text("Resource usage based on your ");
      a0 = element("a");
      t1 = text("current plan");
      t2 = space();
      table = element("table");
      thead0 = element("thead");
      t3 = space();
      thead1 = element("thead");
      thead1.innerHTML = `<tr><th>Resource</th> 
        <th>Quantity</th> 
        <th>Usage</th></tr>`;
      t9 = space();
      tbody = element("tbody");
      tr1 = element("tr");
      td0 = element("td");
      td0.textContent = "Monitors";
      t11 = space();
      td1 = element("td");
      div1 = element("div");
      t12 = text(t12_value);
      t13 = space();
      td2 = element("td");
      div2 = element("div");
      t14 = text(t14_value);
      t15 = space();
      tr2 = element("tr");
      td3 = element("td");
      td3.textContent = "Checks";
      t17 = space();
      td4 = element("td");
      div3 = element("div");
      t18 = text(t18_value);
      t19 = space();
      td5 = element("td");
      div4 = element("div");
      t20 = text(t20_value);
      t21 = space();
      tr3 = element("tr");
      td6 = element("td");
      td6.textContent = "SMSes";
      t23 = space();
      td7 = element("td");
      div5 = element("div");
      t24 = text(t24_value);
      t25 = space();
      td8 = element("td");
      div6 = element("div");
      t26 = text(t26_value);
      t27 = space();
      tr4 = element("tr");
      td9 = element("td");
      td9.textContent = "Emails";
      t29 = space();
      td10 = element("td");
      div7 = element("div");
      t30 = text(t30_value);
      t31 = space();
      td11 = element("td");
      div8 = element("div");
      t32 = text(t32_value);
      t33 = space();
      tr5 = element("tr");
      td12 = element("td");
      td12.textContent = "Actions (webhooks)";
      t35 = space();
      td13 = element("td");
      div9 = element("div");
      t36 = text(t36_value);
      t37 = space();
      td14 = element("td");
      div10 = element("div");
      t38 = text(t38_value);
      t39 = space();
      tr6 = element("tr");
      td15 = element("td");
      td15.textContent = "Push";
      t41 = space();
      td16 = element("td");
      div11 = element("div");
      t42 = text(t42_value);
      t43 = space();
      td17 = element("td");
      div12 = element("div");
      t44 = text(t44_value);
      t45 = space();
      div14 = element("div");
      div14.innerHTML = `Checks made using browser extensions are unlimited and not counted. <a href="https://distill.io/kb/help/cloud-local-monitors/">Learn More</a> 
    <div>In cloud, checks are counted in units of 7 seconds. If a check takes upto 7s, it is counted as
      one. If it takes more than 7s and less than 15s, it is counted as two.</div>`;
      attr(a0, "href", urls.billing);
      attr(div0, "class", "xblock mb-8 p-4");
      attr(div1, "class", "xitem");
      attr(div2, "class", "xitem");
      attr(div3, "class", "xcheck");
      attr(div4, "class", "xcheck");
      attr(div5, "class", "xsms");
      attr(div6, "class", "xsms");
      attr(div7, "class", "xemail");
      attr(div8, "class", "xemail");
      attr(div9, "class", "xaction");
      attr(div10, "class", "xaction");
      attr(div11, "class", "xpush");
      attr(div12, "class", "xpush");
      attr(table, "class", "table table-bordered xblock xblock-thin");
      attr(div14, "class", "xblock");
      attr(div15, "id", "availability");
    },
    m(target, anchor) {
      insert(target, div15, anchor);
      append(div15, div0);
      append(div0, t0);
      append(div0, a0);
      append(a0, t1);
      append(div15, t2);
      append(div15, table);
      append(table, thead0);
      append(table, t3);
      append(table, thead1);
      append(table, t9);
      append(table, tbody);
      append(tbody, tr1);
      append(tr1, td0);
      append(tr1, t11);
      append(tr1, td1);
      append(td1, div1);
      append(div1, t12);
      append(tr1, t13);
      append(tr1, td2);
      append(td2, div2);
      append(div2, t14);
      append(tbody, t15);
      append(tbody, tr2);
      append(tr2, td3);
      append(tr2, t17);
      append(tr2, td4);
      append(td4, div3);
      append(div3, t18);
      append(tr2, t19);
      append(tr2, td5);
      append(td5, div4);
      append(div4, t20);
      append(tbody, t21);
      append(tbody, tr3);
      append(tr3, td6);
      append(tr3, t23);
      append(tr3, td7);
      append(td7, div5);
      append(div5, t24);
      append(tr3, t25);
      append(tr3, td8);
      append(td8, div6);
      append(div6, t26);
      append(tbody, t27);
      append(tbody, tr4);
      append(tr4, td9);
      append(tr4, t29);
      append(tr4, td10);
      append(td10, div7);
      append(div7, t30);
      append(tr4, t31);
      append(tr4, td11);
      append(td11, div8);
      append(div8, t32);
      append(tbody, t33);
      append(tbody, tr5);
      append(tr5, td12);
      append(tr5, t35);
      append(tr5, td13);
      append(td13, div9);
      append(div9, t36);
      append(tr5, t37);
      append(tr5, td14);
      append(td14, div10);
      append(div10, t38);
      append(tbody, t39);
      append(tbody, tr6);
      append(tr6, td15);
      append(tr6, t41);
      append(tr6, td16);
      append(td16, div11);
      append(div11, t42);
      append(tr6, t43);
      append(tr6, td17);
      append(td17, div12);
      append(div12, t44);
      append(div15, t45);
      append(div15, div14);
    },
    p(ctx2, dirty) {
      get_then_context(ctx2);
    },
    d(detaching) {
      if (detaching)
        detach(div15);
    }
  };
}
function create_pending_block$b(ctx) {
  let t;
  return {
    c() {
      t = text("Loading...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_fragment$1H(ctx) {
  let await_block_anchor;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$b,
    then: create_then_block$b,
    catch: create_catch_block$b,
    value: 5
  };
  handle_promise(ctx[0], info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function getTsMonthQuery() {
  const date = new Date();
  const year = date.getFullYear();
  const month = date.getMonth() + 1;
  return `${year}-${month}-1`;
}
function instance$1A($$self) {
  let api = getContext$1("api");
  async function getMonthlyUsage() {
    let usage = {
      item: 0,
      run: 0,
      sms: 0,
      email: 0,
      action: 0,
      push: 0
    };
    const res2 = await api(`/users/usage/monthly?ts_month=${getTsMonthQuery()}`);
    if (res2.count !== 0) {
      usage = res2.data[0];
    }
    const { count: count2 } = await api("/users/sieve-count");
    usage.item = count2;
    return usage;
  }
  const resPromise = Promise.all([api("/users/constraints"), getMonthlyUsage()]);
  return [resPromise];
}
class Avail extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1A, create_fragment$1H, safe_not_equal, {});
  }
}
function get_each_context$o(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i2];
  return child_ctx;
}
function get_each_context_1$3(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i2];
  return child_ctx;
}
function create_catch_block$a(ctx) {
  return { c: noop, m: noop, p: noop, d: noop };
}
function create_then_block$a(ctx) {
  let table;
  let thead;
  let t11;
  let tbody;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_value = ctx[4].data;
  const get_key = (ctx2) => ctx2[5].ts;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$o(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$o(key, child_ctx));
  }
  return {
    c() {
      table = element("table");
      thead = element("thead");
      thead.innerHTML = `<tr><th>Date</th> 
      <th>Checks</th> 
      <th>Emails</th> 
      <th>SMSes</th> 
      <th>Webhooks</th> 
      <th>Push</th></tr>`;
      t11 = space();
      tbody = element("tbody");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(table, "id", "daily");
      attr(table, "class", "table table-bordered xblock xblock-thin");
    },
    m(target, anchor) {
      insert(target, table, anchor);
      append(table, thead);
      append(table, t11);
      append(table, tbody);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(tbody, null);
      }
    },
    p(ctx2, dirty) {
      if (dirty & 3) {
        each_value = ctx2[4].data;
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, tbody, destroy_block, create_each_block$o, null, get_each_context$o);
      }
    },
    d(detaching) {
      if (detaching)
        detach(table);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
    }
  };
}
function create_each_block_1$3(ctx) {
  let td;
  let div;
  let t_value = ctx[5][ctx[8]] + "";
  let t;
  return {
    c() {
      td = element("td");
      div = element("div");
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, td, anchor);
      append(td, div);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[5][ctx2[8]] + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(td);
    }
  };
}
function create_each_block$o(key_1, ctx) {
  let tr;
  let t;
  let each_value_1 = ctx[1];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$3(get_each_context_1$3(ctx, each_value_1, i2));
  }
  return {
    key: key_1,
    first: null,
    c() {
      tr = element("tr");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t = space();
      this.first = tr;
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(tr, null);
      }
      append(tr, t);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 3) {
        each_value_1 = ctx[1];
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$3(ctx, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_1$3(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(tr, t);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    d(detaching) {
      if (detaching)
        detach(tr);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_pending_block$a(ctx) {
  let t;
  return {
    c() {
      t = text("Loading...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_fragment$1G(ctx) {
  let await_block_anchor;
  let promise;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$a,
    then: create_then_block$a,
    catch: create_catch_block$a,
    value: 4
  };
  handle_promise(promise = ctx[0], info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      info.ctx = ctx;
      if (dirty & 1 && promise !== (promise = ctx[0]) && handle_promise(promise, info))
        ;
      else {
        update_await_block_branch(info, ctx, dirty);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function instance$1z($$self, $$props, $$invalidate) {
  let { cycle } = $$props;
  let api = getContext$1("api");
  let resPromise;
  const NAMES = ["ts", "run", "email", "sms", "action", "push"];
  $$self.$$set = ($$props2) => {
    if ("cycle" in $$props2)
      $$invalidate(2, cycle = $$props2.cycle);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4) {
      $$invalidate(0, resPromise = api("/users/usage/" + cycle, "GET"));
    }
  };
  return [resPromise, NAMES, cycle];
}
class Usage extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1z, create_fragment$1G, safe_not_equal, { cycle: 2 });
  }
}
function create_else_block$s(ctx) {
  let usage;
  let current;
  usage = new Usage({ props: { cycle: ctx[0] } });
  return {
    c() {
      create_component(usage.$$.fragment);
    },
    m(target, anchor) {
      mount_component(usage, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const usage_changes = {};
      if (dirty & 1)
        usage_changes.cycle = ctx2[0];
      usage.$set(usage_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(usage.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(usage.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(usage, detaching);
    }
  };
}
function create_if_block$K(ctx) {
  let avail;
  let current;
  avail = new Avail({});
  return {
    c() {
      create_component(avail.$$.fragment);
    },
    m(target, anchor) {
      mount_component(avail, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(avail.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(avail.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(avail, detaching);
    }
  };
}
function create_default_slot$i(ctx) {
  let div4;
  let div3;
  let div1;
  let div0;
  let a0;
  let t1;
  let a1;
  let t3;
  let a2;
  let t5;
  let div2;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block$K, create_else_block$s];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0] == "availability")
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div4 = element("div");
      div3 = element("div");
      div1 = element("div");
      div0 = element("div");
      a0 = element("a");
      a0.innerHTML = `Available Resources<i class="fa fa-chevron-right right"></i>`;
      t1 = space();
      a1 = element("a");
      a1.innerHTML = `Daily Usage<i class="fa fa-chevron-right right"></i>`;
      t3 = space();
      a2 = element("a");
      a2.innerHTML = `Monthly Usage<i class="fa fa-chevron-right right"></i>`;
      t5 = space();
      div2 = element("div");
      if_block.c();
      attr(a0, "href", "#/usage/availability/");
      attr(a0, "class", "list-group-item");
      toggle_class(a0, "active", ctx[0] == "availability");
      attr(a1, "href", "#/usage/daily/");
      attr(a1, "class", "list-group-item");
      toggle_class(a1, "active", ctx[0] == "daily");
      attr(a2, "href", "#/usage/monthly/");
      attr(a2, "class", "list-group-item");
      toggle_class(a2, "active", ctx[0] == "monthly");
      attr(div0, "id", "sidebar");
      attr(div0, "class", "list-group");
      attr(div1, "class", "col-sm-3");
      attr(div2, "class", "col-sm-9");
      attr(div3, "class", "row");
      attr(div4, "class", "container");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div3);
      append(div3, div1);
      append(div1, div0);
      append(div0, a0);
      append(div0, t1);
      append(div0, a1);
      append(div0, t3);
      append(div0, a2);
      append(div3, t5);
      append(div3, div2);
      if_blocks[current_block_type_index].m(div2, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 1) {
        toggle_class(a0, "active", ctx2[0] == "availability");
      }
      if (dirty & 1) {
        toggle_class(a1, "active", ctx2[0] == "daily");
      }
      if (dirty & 1) {
        toggle_class(a2, "active", ctx2[0] == "monthly");
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div2, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div4);
      if_blocks[current_block_type_index].d();
    }
  };
}
function create_extra_slot$2(ctx) {
  let topbar;
  let current;
  topbar = new Topbar$1({});
  return {
    c() {
      create_component(topbar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(topbar, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(topbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(topbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(topbar, detaching);
    }
  };
}
function create_fragment$1F(ctx) {
  let layout;
  let current;
  layout = new Layout({
    props: {
      $$slots: {
        extra: [create_extra_slot$2],
        default: [create_default_slot$i]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(layout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(layout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const layout_changes = {};
      if (dirty & 5) {
        layout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layout.$set(layout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(layout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(layout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(layout, detaching);
    }
  };
}
function instance$1y($$self, $$props, $$invalidate) {
  let { params: params2 } = $$props;
  let module;
  $$self.$$set = ($$props2) => {
    if ("params" in $$props2)
      $$invalidate(1, params2 = $$props2.params);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2) {
      $$invalidate(0, module = params2.module);
    }
  };
  return [module, params2];
}
class Usage_1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1y, create_fragment$1F, safe_not_equal, { params: 1 });
  }
}
function parse$2(str, loose) {
  if (str instanceof RegExp)
    return { keys: false, pattern: str };
  var c, o, tmp, ext, keys = [], pattern = "", arr = str.split("/");
  arr[0] || arr.shift();
  while (tmp = arr.shift()) {
    c = tmp[0];
    if (c === "*") {
      keys.push("wild");
      pattern += "/(.*)";
    } else if (c === ":") {
      o = tmp.indexOf("?", 1);
      ext = tmp.indexOf(".", 1);
      keys.push(tmp.substring(1, !!~o ? o : !!~ext ? ext : tmp.length));
      pattern += !!~o && !~ext ? "(?:/([^/]+?))?" : "/([^/]+?)";
      if (!!~ext)
        pattern += (!!~o ? "?" : "") + "\\" + tmp.substring(ext);
    } else {
      pattern += "/" + tmp;
    }
  }
  return {
    keys,
    pattern: new RegExp("^" + pattern + (loose ? "(?=$|/)" : "/?$"), "i")
  };
}
function getAugmentedNamespace(n) {
  if (n.__esModule)
    return n;
  var a = Object.defineProperty({}, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
var shams = function hasSymbols() {
  if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
    return false;
  }
  if (typeof Symbol.iterator === "symbol") {
    return true;
  }
  var obj = {};
  var sym = Symbol("test");
  var symObj = Object(sym);
  if (typeof sym === "string") {
    return false;
  }
  if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
    return false;
  }
  if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
    return false;
  }
  var symVal = 42;
  obj[sym] = symVal;
  for (sym in obj) {
    return false;
  }
  if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
    return false;
  }
  if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
    return false;
  }
  var syms = Object.getOwnPropertySymbols(obj);
  if (syms.length !== 1 || syms[0] !== sym) {
    return false;
  }
  if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
    return false;
  }
  if (typeof Object.getOwnPropertyDescriptor === "function") {
    var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
    if (descriptor.value !== symVal || descriptor.enumerable !== true) {
      return false;
    }
  }
  return true;
};
var origSymbol = typeof Symbol !== "undefined" && Symbol;
var hasSymbolSham = shams;
var hasSymbols$1 = function hasNativeSymbols() {
  if (typeof origSymbol !== "function") {
    return false;
  }
  if (typeof Symbol !== "function") {
    return false;
  }
  if (typeof origSymbol("foo") !== "symbol") {
    return false;
  }
  if (typeof Symbol("bar") !== "symbol") {
    return false;
  }
  return hasSymbolSham();
};
var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
var slice = Array.prototype.slice;
var toStr$1 = Object.prototype.toString;
var funcType = "[object Function]";
var implementation$1 = function bind(that) {
  var target = this;
  if (typeof target !== "function" || toStr$1.call(target) !== funcType) {
    throw new TypeError(ERROR_MESSAGE + target);
  }
  var args = slice.call(arguments, 1);
  var bound;
  var binder = function() {
    if (this instanceof bound) {
      var result = target.apply(this, args.concat(slice.call(arguments)));
      if (Object(result) === result) {
        return result;
      }
      return this;
    } else {
      return target.apply(that, args.concat(slice.call(arguments)));
    }
  };
  var boundLength = Math.max(0, target.length - args.length);
  var boundArgs = [];
  for (var i2 = 0; i2 < boundLength; i2++) {
    boundArgs.push("$" + i2);
  }
  bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
  if (target.prototype) {
    var Empty = function Empty2() {
    };
    Empty.prototype = target.prototype;
    bound.prototype = new Empty();
    Empty.prototype = null;
  }
  return bound;
};
var implementation = implementation$1;
var functionBind = Function.prototype.bind || implementation;
var bind$1 = functionBind;
var src = bind$1.call(Function.call, Object.prototype.hasOwnProperty);
var undefined$1;
var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError$1 = TypeError;
var getEvalledConstructor = function(expressionSyntax) {
  try {
    return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
  } catch (e) {
  }
};
var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
  try {
    $gOPD({}, "");
  } catch (e) {
    $gOPD = null;
  }
}
var throwTypeError = function() {
  throw new $TypeError$1();
};
var ThrowTypeError = $gOPD ? function() {
  try {
    arguments.callee;
    return throwTypeError;
  } catch (calleeThrows) {
    try {
      return $gOPD(arguments, "callee").get;
    } catch (gOPDthrows) {
      return throwTypeError;
    }
  }
}() : throwTypeError;
var hasSymbols2 = hasSymbols$1();
var getProto = Object.getPrototypeOf || function(x) {
  return x.__proto__;
};
var needsEval = {};
var TypedArray = typeof Uint8Array === "undefined" ? undefined$1 : getProto(Uint8Array);
var INTRINSICS = {
  "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
  "%ArrayIteratorPrototype%": hasSymbols2 ? getProto([][Symbol.iterator]()) : undefined$1,
  "%AsyncFromSyncIteratorPrototype%": undefined$1,
  "%AsyncFunction%": needsEval,
  "%AsyncGenerator%": needsEval,
  "%AsyncGeneratorFunction%": needsEval,
  "%AsyncIteratorPrototype%": needsEval,
  "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
  "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": Error,
  "%eval%": eval,
  "%EvalError%": EvalError,
  "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
  "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
  "%Function%": $Function,
  "%GeneratorFunction%": needsEval,
  "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
  "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
  "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols2 ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
  "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
  "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
  "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols2 ? undefined$1 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
  "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
  "%RangeError%": RangeError,
  "%ReferenceError%": ReferenceError,
  "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
  "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols2 ? undefined$1 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols2 ? getProto(""[Symbol.iterator]()) : undefined$1,
  "%Symbol%": hasSymbols2 ? Symbol : undefined$1,
  "%SyntaxError%": $SyntaxError,
  "%ThrowTypeError%": ThrowTypeError,
  "%TypedArray%": TypedArray,
  "%TypeError%": $TypeError$1,
  "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
  "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
  "%URIError%": URIError,
  "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
  "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
  "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet
};
var doEval = function doEval2(name) {
  var value;
  if (name === "%AsyncFunction%") {
    value = getEvalledConstructor("async function () {}");
  } else if (name === "%GeneratorFunction%") {
    value = getEvalledConstructor("function* () {}");
  } else if (name === "%AsyncGeneratorFunction%") {
    value = getEvalledConstructor("async function* () {}");
  } else if (name === "%AsyncGenerator%") {
    var fn = doEval2("%AsyncGeneratorFunction%");
    if (fn) {
      value = fn.prototype;
    }
  } else if (name === "%AsyncIteratorPrototype%") {
    var gen = doEval2("%AsyncGenerator%");
    if (gen) {
      value = getProto(gen.prototype);
    }
  }
  INTRINSICS[name] = value;
  return value;
};
var LEGACY_ALIASES = {
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
};
var bind2 = functionBind;
var hasOwn$1 = src;
var $concat$1 = bind2.call(Function.call, Array.prototype.concat);
var $spliceApply = bind2.call(Function.apply, Array.prototype.splice);
var $replace$1 = bind2.call(Function.call, String.prototype.replace);
var $strSlice = bind2.call(Function.call, String.prototype.slice);
var $exec = bind2.call(Function.call, RegExp.prototype.exec);
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = function stringToPath2(string) {
  var first = $strSlice(string, 0, 1);
  var last = $strSlice(string, -1);
  if (first === "%" && last !== "%") {
    throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
  } else if (last === "%" && first !== "%") {
    throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
  }
  var result = [];
  $replace$1(string, rePropName, function(match, number, quote2, subString) {
    result[result.length] = quote2 ? $replace$1(subString, reEscapeChar, "$1") : number || match;
  });
  return result;
};
var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
  var intrinsicName = name;
  var alias;
  if (hasOwn$1(LEGACY_ALIASES, intrinsicName)) {
    alias = LEGACY_ALIASES[intrinsicName];
    intrinsicName = "%" + alias[0] + "%";
  }
  if (hasOwn$1(INTRINSICS, intrinsicName)) {
    var value = INTRINSICS[intrinsicName];
    if (value === needsEval) {
      value = doEval(intrinsicName);
    }
    if (typeof value === "undefined" && !allowMissing) {
      throw new $TypeError$1("intrinsic " + name + " exists, but is not available. Please file an issue!");
    }
    return {
      alias,
      name: intrinsicName,
      value
    };
  }
  throw new $SyntaxError("intrinsic " + name + " does not exist!");
};
var getIntrinsic = function GetIntrinsic(name, allowMissing) {
  if (typeof name !== "string" || name.length === 0) {
    throw new $TypeError$1("intrinsic name must be a non-empty string");
  }
  if (arguments.length > 1 && typeof allowMissing !== "boolean") {
    throw new $TypeError$1('"allowMissing" argument must be a boolean');
  }
  if ($exec(/^%?[^%]*%?$/g, name) === null) {
    throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  }
  var parts = stringToPath(name);
  var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
  var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
  var intrinsicRealName = intrinsic.name;
  var value = intrinsic.value;
  var skipFurtherCaching = false;
  var alias = intrinsic.alias;
  if (alias) {
    intrinsicBaseName = alias[0];
    $spliceApply(parts, $concat$1([0, 1], alias));
  }
  for (var i2 = 1, isOwn = true; i2 < parts.length; i2 += 1) {
    var part = parts[i2];
    var first = $strSlice(part, 0, 1);
    var last = $strSlice(part, -1);
    if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
      throw new $SyntaxError("property names with quotes must have matching quotes");
    }
    if (part === "constructor" || !isOwn) {
      skipFurtherCaching = true;
    }
    intrinsicBaseName += "." + part;
    intrinsicRealName = "%" + intrinsicBaseName + "%";
    if (hasOwn$1(INTRINSICS, intrinsicRealName)) {
      value = INTRINSICS[intrinsicRealName];
    } else if (value != null) {
      if (!(part in value)) {
        if (!allowMissing) {
          throw new $TypeError$1("base intrinsic for " + name + " exists, but the property is not available.");
        }
        return void 0;
      }
      if ($gOPD && i2 + 1 >= parts.length) {
        var desc = $gOPD(value, part);
        isOwn = !!desc;
        if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
          value = desc.get;
        } else {
          value = value[part];
        }
      } else {
        isOwn = hasOwn$1(value, part);
        value = value[part];
      }
      if (isOwn && !skipFurtherCaching) {
        INTRINSICS[intrinsicRealName] = value;
      }
    }
  }
  return value;
};
var callBind$1 = { exports: {} };
(function(module) {
  var bind3 = functionBind;
  var GetIntrinsic3 = getIntrinsic;
  var $apply = GetIntrinsic3("%Function.prototype.apply%");
  var $call = GetIntrinsic3("%Function.prototype.call%");
  var $reflectApply = GetIntrinsic3("%Reflect.apply%", true) || bind3.call($call, $apply);
  var $gOPD2 = GetIntrinsic3("%Object.getOwnPropertyDescriptor%", true);
  var $defineProperty = GetIntrinsic3("%Object.defineProperty%", true);
  var $max = GetIntrinsic3("%Math.max%");
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", { value: 1 });
    } catch (e) {
      $defineProperty = null;
    }
  }
  module.exports = function callBind2(originalFunction) {
    var func = $reflectApply(bind3, $call, arguments);
    if ($gOPD2 && $defineProperty) {
      var desc = $gOPD2(func, "length");
      if (desc.configurable) {
        $defineProperty(func, "length", { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) });
      }
    }
    return func;
  };
  var applyBind = function applyBind2() {
    return $reflectApply(bind3, $apply, arguments);
  };
  if ($defineProperty) {
    $defineProperty(module.exports, "apply", { value: applyBind });
  } else {
    module.exports.apply = applyBind;
  }
})(callBind$1);
var GetIntrinsic$1 = getIntrinsic;
var callBind = callBind$1.exports;
var $indexOf = callBind(GetIntrinsic$1("String.prototype.indexOf"));
var callBound$1 = function callBoundIntrinsic(name, allowMissing) {
  var intrinsic = GetIntrinsic$1(name, !!allowMissing);
  if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
    return callBind(intrinsic);
  }
  return intrinsic;
};
var __viteBrowserExternal = {};
var __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
var require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var hasMap = typeof Map === "function" && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === "function" && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var $match = String.prototype.match;
var $slice = String.prototype.slice;
var $replace = String.prototype.replace;
var $toUpperCase = String.prototype.toUpperCase;
var $toLowerCase = String.prototype.toLowerCase;
var $test = RegExp.prototype.test;
var $concat = Array.prototype.concat;
var $join = Array.prototype.join;
var $arrSlice = Array.prototype.slice;
var $floor = Math.floor;
var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
var gOPS = Object.getOwnPropertySymbols;
var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
var isEnumerable = Object.prototype.propertyIsEnumerable;
var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
  return O.__proto__;
} : null);
function addNumericSeparator(num, str) {
  if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
    return str;
  }
  var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
  if (typeof num === "number") {
    var int = num < 0 ? -$floor(-num) : $floor(num);
    if (int !== num) {
      var intStr = String(int);
      var dec = $slice.call(str, intStr.length + 1);
      return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
    }
  }
  return $replace.call(str, sepRegex, "$&_");
}
var utilInspect = require$$0;
var inspectCustom = utilInspect.custom;
var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
var objectInspect = function inspect_(obj, options, depth, seen) {
  var opts = options || {};
  if (has$3(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
    throw new TypeError('option "quoteStyle" must be "single" or "double"');
  }
  if (has$3(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
    throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
  }
  var customInspect = has$3(opts, "customInspect") ? opts.customInspect : true;
  if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
    throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
  }
  if (has$3(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
    throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
  }
  if (has$3(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
    throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
  }
  var numericSeparator = opts.numericSeparator;
  if (typeof obj === "undefined") {
    return "undefined";
  }
  if (obj === null) {
    return "null";
  }
  if (typeof obj === "boolean") {
    return obj ? "true" : "false";
  }
  if (typeof obj === "string") {
    return inspectString(obj, opts);
  }
  if (typeof obj === "number") {
    if (obj === 0) {
      return Infinity / obj > 0 ? "0" : "-0";
    }
    var str = String(obj);
    return numericSeparator ? addNumericSeparator(obj, str) : str;
  }
  if (typeof obj === "bigint") {
    var bigIntStr = String(obj) + "n";
    return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
  }
  var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
  if (typeof depth === "undefined") {
    depth = 0;
  }
  if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
    return isArray$3(obj) ? "[Array]" : "[Object]";
  }
  var indent = getIndent(opts, depth);
  if (typeof seen === "undefined") {
    seen = [];
  } else if (indexOf(seen, obj) >= 0) {
    return "[Circular]";
  }
  function inspect2(value, from, noIndent) {
    if (from) {
      seen = $arrSlice.call(seen);
      seen.push(from);
    }
    if (noIndent) {
      var newOpts = {
        depth: opts.depth
      };
      if (has$3(opts, "quoteStyle")) {
        newOpts.quoteStyle = opts.quoteStyle;
      }
      return inspect_(value, newOpts, depth + 1, seen);
    }
    return inspect_(value, opts, depth + 1, seen);
  }
  if (typeof obj === "function" && !isRegExp$1(obj)) {
    var name = nameOf(obj);
    var keys = arrObjKeys(obj, inspect2);
    return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
  }
  if (isSymbol(obj)) {
    var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
    return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
  }
  if (isElement(obj)) {
    var s = "<" + $toLowerCase.call(String(obj.nodeName));
    var attrs = obj.attributes || [];
    for (var i2 = 0; i2 < attrs.length; i2++) {
      s += " " + attrs[i2].name + "=" + wrapQuotes(quote(attrs[i2].value), "double", opts);
    }
    s += ">";
    if (obj.childNodes && obj.childNodes.length) {
      s += "...";
    }
    s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
    return s;
  }
  if (isArray$3(obj)) {
    if (obj.length === 0) {
      return "[]";
    }
    var xs = arrObjKeys(obj, inspect2);
    if (indent && !singleLineValues(xs)) {
      return "[" + indentedJoin(xs, indent) + "]";
    }
    return "[ " + $join.call(xs, ", ") + " ]";
  }
  if (isError(obj)) {
    var parts = arrObjKeys(obj, inspect2);
    if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
      return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect2(obj.cause), parts), ", ") + " }";
    }
    if (parts.length === 0) {
      return "[" + String(obj) + "]";
    }
    return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
  }
  if (typeof obj === "object" && customInspect) {
    if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
      return utilInspect(obj, { depth: maxDepth - depth });
    } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
      return obj.inspect();
    }
  }
  if (isMap(obj)) {
    var mapParts = [];
    mapForEach.call(obj, function(value, key) {
      mapParts.push(inspect2(key, obj, true) + " => " + inspect2(value, obj));
    });
    return collectionOf("Map", mapSize.call(obj), mapParts, indent);
  }
  if (isSet(obj)) {
    var setParts = [];
    setForEach.call(obj, function(value) {
      setParts.push(inspect2(value, obj));
    });
    return collectionOf("Set", setSize.call(obj), setParts, indent);
  }
  if (isWeakMap(obj)) {
    return weakCollectionOf("WeakMap");
  }
  if (isWeakSet(obj)) {
    return weakCollectionOf("WeakSet");
  }
  if (isWeakRef(obj)) {
    return weakCollectionOf("WeakRef");
  }
  if (isNumber(obj)) {
    return markBoxed(inspect2(Number(obj)));
  }
  if (isBigInt(obj)) {
    return markBoxed(inspect2(bigIntValueOf.call(obj)));
  }
  if (isBoolean(obj)) {
    return markBoxed(booleanValueOf.call(obj));
  }
  if (isString(obj)) {
    return markBoxed(inspect2(String(obj)));
  }
  if (!isDate(obj) && !isRegExp$1(obj)) {
    var ys = arrObjKeys(obj, inspect2);
    var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
    var protoTag = obj instanceof Object ? "" : "null prototype";
    var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
    var constructorTag = isPlainObject || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
    var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
    if (ys.length === 0) {
      return tag + "{}";
    }
    if (indent) {
      return tag + "{" + indentedJoin(ys, indent) + "}";
    }
    return tag + "{ " + $join.call(ys, ", ") + " }";
  }
  return String(obj);
};
function wrapQuotes(s, defaultStyle, opts) {
  var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
  return quoteChar + s + quoteChar;
}
function quote(s) {
  return $replace.call(String(s), /"/g, "&quot;");
}
function isArray$3(obj) {
  return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isDate(obj) {
  return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isRegExp$1(obj) {
  return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isError(obj) {
  return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isString(obj) {
  return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isNumber(obj) {
  return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isBoolean(obj) {
  return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isSymbol(obj) {
  if (hasShammedSymbols) {
    return obj && typeof obj === "object" && obj instanceof Symbol;
  }
  if (typeof obj === "symbol") {
    return true;
  }
  if (!obj || typeof obj !== "object" || !symToString) {
    return false;
  }
  try {
    symToString.call(obj);
    return true;
  } catch (e) {
  }
  return false;
}
function isBigInt(obj) {
  if (!obj || typeof obj !== "object" || !bigIntValueOf) {
    return false;
  }
  try {
    bigIntValueOf.call(obj);
    return true;
  } catch (e) {
  }
  return false;
}
var hasOwn = Object.prototype.hasOwnProperty || function(key) {
  return key in this;
};
function has$3(obj, key) {
  return hasOwn.call(obj, key);
}
function toStr(obj) {
  return objectToString.call(obj);
}
function nameOf(f) {
  if (f.name) {
    return f.name;
  }
  var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
  if (m) {
    return m[1];
  }
  return null;
}
function indexOf(xs, x) {
  if (xs.indexOf) {
    return xs.indexOf(x);
  }
  for (var i2 = 0, l = xs.length; i2 < l; i2++) {
    if (xs[i2] === x) {
      return i2;
    }
  }
  return -1;
}
function isMap(x) {
  if (!mapSize || !x || typeof x !== "object") {
    return false;
  }
  try {
    mapSize.call(x);
    try {
      setSize.call(x);
    } catch (s) {
      return true;
    }
    return x instanceof Map;
  } catch (e) {
  }
  return false;
}
function isWeakMap(x) {
  if (!weakMapHas || !x || typeof x !== "object") {
    return false;
  }
  try {
    weakMapHas.call(x, weakMapHas);
    try {
      weakSetHas.call(x, weakSetHas);
    } catch (s) {
      return true;
    }
    return x instanceof WeakMap;
  } catch (e) {
  }
  return false;
}
function isWeakRef(x) {
  if (!weakRefDeref || !x || typeof x !== "object") {
    return false;
  }
  try {
    weakRefDeref.call(x);
    return true;
  } catch (e) {
  }
  return false;
}
function isSet(x) {
  if (!setSize || !x || typeof x !== "object") {
    return false;
  }
  try {
    setSize.call(x);
    try {
      mapSize.call(x);
    } catch (m) {
      return true;
    }
    return x instanceof Set;
  } catch (e) {
  }
  return false;
}
function isWeakSet(x) {
  if (!weakSetHas || !x || typeof x !== "object") {
    return false;
  }
  try {
    weakSetHas.call(x, weakSetHas);
    try {
      weakMapHas.call(x, weakMapHas);
    } catch (s) {
      return true;
    }
    return x instanceof WeakSet;
  } catch (e) {
  }
  return false;
}
function isElement(x) {
  if (!x || typeof x !== "object") {
    return false;
  }
  if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
    return true;
  }
  return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
}
function inspectString(str, opts) {
  if (str.length > opts.maxStringLength) {
    var remaining = str.length - opts.maxStringLength;
    var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
    return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
  }
  var s = $replace.call($replace.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
  return wrapQuotes(s, "single", opts);
}
function lowbyte(c) {
  var n = c.charCodeAt(0);
  var x = {
    8: "b",
    9: "t",
    10: "n",
    12: "f",
    13: "r"
  }[n];
  if (x) {
    return "\\" + x;
  }
  return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
}
function markBoxed(str) {
  return "Object(" + str + ")";
}
function weakCollectionOf(type) {
  return type + " { ? }";
}
function collectionOf(type, size, entries, indent) {
  var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
  return type + " (" + size + ") {" + joinedEntries + "}";
}
function singleLineValues(xs) {
  for (var i2 = 0; i2 < xs.length; i2++) {
    if (indexOf(xs[i2], "\n") >= 0) {
      return false;
    }
  }
  return true;
}
function getIndent(opts, depth) {
  var baseIndent;
  if (opts.indent === "	") {
    baseIndent = "	";
  } else if (typeof opts.indent === "number" && opts.indent > 0) {
    baseIndent = $join.call(Array(opts.indent + 1), " ");
  } else {
    return null;
  }
  return {
    base: baseIndent,
    prev: $join.call(Array(depth + 1), baseIndent)
  };
}
function indentedJoin(xs, indent) {
  if (xs.length === 0) {
    return "";
  }
  var lineJoiner = "\n" + indent.prev + indent.base;
  return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
}
function arrObjKeys(obj, inspect2) {
  var isArr = isArray$3(obj);
  var xs = [];
  if (isArr) {
    xs.length = obj.length;
    for (var i2 = 0; i2 < obj.length; i2++) {
      xs[i2] = has$3(obj, i2) ? inspect2(obj[i2], obj) : "";
    }
  }
  var syms = typeof gOPS === "function" ? gOPS(obj) : [];
  var symMap;
  if (hasShammedSymbols) {
    symMap = {};
    for (var k = 0; k < syms.length; k++) {
      symMap["$" + syms[k]] = syms[k];
    }
  }
  for (var key in obj) {
    if (!has$3(obj, key)) {
      continue;
    }
    if (isArr && String(Number(key)) === key && key < obj.length) {
      continue;
    }
    if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
      continue;
    } else if ($test.call(/[^\w$]/, key)) {
      xs.push(inspect2(key, obj) + ": " + inspect2(obj[key], obj));
    } else {
      xs.push(key + ": " + inspect2(obj[key], obj));
    }
  }
  if (typeof gOPS === "function") {
    for (var j = 0; j < syms.length; j++) {
      if (isEnumerable.call(obj, syms[j])) {
        xs.push("[" + inspect2(syms[j]) + "]: " + inspect2(obj[syms[j]], obj));
      }
    }
  }
  return xs;
}
var GetIntrinsic2 = getIntrinsic;
var callBound = callBound$1;
var inspect = objectInspect;
var $TypeError = GetIntrinsic2("%TypeError%");
var $WeakMap = GetIntrinsic2("%WeakMap%", true);
var $Map = GetIntrinsic2("%Map%", true);
var $weakMapGet = callBound("WeakMap.prototype.get", true);
var $weakMapSet = callBound("WeakMap.prototype.set", true);
var $weakMapHas = callBound("WeakMap.prototype.has", true);
var $mapGet = callBound("Map.prototype.get", true);
var $mapSet = callBound("Map.prototype.set", true);
var $mapHas = callBound("Map.prototype.has", true);
var listGetNode = function(list, key) {
  for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
    if (curr.key === key) {
      prev.next = curr.next;
      curr.next = list.next;
      list.next = curr;
      return curr;
    }
  }
};
var listGet = function(objects, key) {
  var node2 = listGetNode(objects, key);
  return node2 && node2.value;
};
var listSet = function(objects, key, value) {
  var node2 = listGetNode(objects, key);
  if (node2) {
    node2.value = value;
  } else {
    objects.next = {
      key,
      next: objects.next,
      value
    };
  }
};
var listHas = function(objects, key) {
  return !!listGetNode(objects, key);
};
var sideChannel = function getSideChannel() {
  var $wm;
  var $m;
  var $o;
  var channel = {
    assert: function(key) {
      if (!channel.has(key)) {
        throw new $TypeError("Side channel does not contain " + inspect(key));
      }
    },
    get: function(key) {
      if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
        if ($wm) {
          return $weakMapGet($wm, key);
        }
      } else if ($Map) {
        if ($m) {
          return $mapGet($m, key);
        }
      } else {
        if ($o) {
          return listGet($o, key);
        }
      }
    },
    has: function(key) {
      if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
        if ($wm) {
          return $weakMapHas($wm, key);
        }
      } else if ($Map) {
        if ($m) {
          return $mapHas($m, key);
        }
      } else {
        if ($o) {
          return listHas($o, key);
        }
      }
      return false;
    },
    set: function(key, value) {
      if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
        if (!$wm) {
          $wm = new $WeakMap();
        }
        $weakMapSet($wm, key, value);
      } else if ($Map) {
        if (!$m) {
          $m = new $Map();
        }
        $mapSet($m, key, value);
      } else {
        if (!$o) {
          $o = { key: {}, next: null };
        }
        listSet($o, key, value);
      }
    }
  };
  return channel;
};
var replace = String.prototype.replace;
var percentTwenties = /%20/g;
var Format = {
  RFC1738: "RFC1738",
  RFC3986: "RFC3986"
};
var formats$3 = {
  "default": Format.RFC3986,
  formatters: {
    RFC1738: function(value) {
      return replace.call(value, percentTwenties, "+");
    },
    RFC3986: function(value) {
      return String(value);
    }
  },
  RFC1738: Format.RFC1738,
  RFC3986: Format.RFC3986
};
var formats$2 = formats$3;
var has$2 = Object.prototype.hasOwnProperty;
var isArray$2 = Array.isArray;
var hexTable = function() {
  var array = [];
  for (var i2 = 0; i2 < 256; ++i2) {
    array.push("%" + ((i2 < 16 ? "0" : "") + i2.toString(16)).toUpperCase());
  }
  return array;
}();
var compactQueue = function compactQueue2(queue) {
  while (queue.length > 1) {
    var item = queue.pop();
    var obj = item.obj[item.prop];
    if (isArray$2(obj)) {
      var compacted = [];
      for (var j = 0; j < obj.length; ++j) {
        if (typeof obj[j] !== "undefined") {
          compacted.push(obj[j]);
        }
      }
      item.obj[item.prop] = compacted;
    }
  }
};
var arrayToObject = function arrayToObject2(source, options) {
  var obj = options && options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
  for (var i2 = 0; i2 < source.length; ++i2) {
    if (typeof source[i2] !== "undefined") {
      obj[i2] = source[i2];
    }
  }
  return obj;
};
var merge$2 = function merge(target, source, options) {
  if (!source) {
    return target;
  }
  if (typeof source !== "object") {
    if (isArray$2(target)) {
      target.push(source);
    } else if (target && typeof target === "object") {
      if (options && (options.plainObjects || options.allowPrototypes) || !has$2.call(Object.prototype, source)) {
        target[source] = true;
      }
    } else {
      return [target, source];
    }
    return target;
  }
  if (!target || typeof target !== "object") {
    return [target].concat(source);
  }
  var mergeTarget = target;
  if (isArray$2(target) && !isArray$2(source)) {
    mergeTarget = arrayToObject(target, options);
  }
  if (isArray$2(target) && isArray$2(source)) {
    source.forEach(function(item, i2) {
      if (has$2.call(target, i2)) {
        var targetItem = target[i2];
        if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
          target[i2] = merge(targetItem, item, options);
        } else {
          target.push(item);
        }
      } else {
        target[i2] = item;
      }
    });
    return target;
  }
  return Object.keys(source).reduce(function(acc, key) {
    var value = source[key];
    if (has$2.call(acc, key)) {
      acc[key] = merge(acc[key], value, options);
    } else {
      acc[key] = value;
    }
    return acc;
  }, mergeTarget);
};
var assign = function assignSingleSource(target, source) {
  return Object.keys(source).reduce(function(acc, key) {
    acc[key] = source[key];
    return acc;
  }, target);
};
var decode = function(str, decoder, charset) {
  var strWithoutPlus = str.replace(/\+/g, " ");
  if (charset === "iso-8859-1") {
    return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
  }
  try {
    return decodeURIComponent(strWithoutPlus);
  } catch (e) {
    return strWithoutPlus;
  }
};
var encode = function encode2(str, defaultEncoder, charset, kind, format) {
  if (str.length === 0) {
    return str;
  }
  var string = str;
  if (typeof str === "symbol") {
    string = Symbol.prototype.toString.call(str);
  } else if (typeof str !== "string") {
    string = String(str);
  }
  if (charset === "iso-8859-1") {
    return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
      return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
    });
  }
  var out = "";
  for (var i2 = 0; i2 < string.length; ++i2) {
    var c = string.charCodeAt(i2);
    if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || format === formats$2.RFC1738 && (c === 40 || c === 41)) {
      out += string.charAt(i2);
      continue;
    }
    if (c < 128) {
      out = out + hexTable[c];
      continue;
    }
    if (c < 2048) {
      out = out + (hexTable[192 | c >> 6] + hexTable[128 | c & 63]);
      continue;
    }
    if (c < 55296 || c >= 57344) {
      out = out + (hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63]);
      continue;
    }
    i2 += 1;
    c = 65536 + ((c & 1023) << 10 | string.charCodeAt(i2) & 1023);
    out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
  }
  return out;
};
var compact = function compact2(value) {
  var queue = [{ obj: { o: value }, prop: "o" }];
  var refs = [];
  for (var i2 = 0; i2 < queue.length; ++i2) {
    var item = queue[i2];
    var obj = item.obj[item.prop];
    var keys = Object.keys(obj);
    for (var j = 0; j < keys.length; ++j) {
      var key = keys[j];
      var val = obj[key];
      if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
        queue.push({ obj, prop: key });
        refs.push(val);
      }
    }
  }
  compactQueue(queue);
  return value;
};
var isRegExp = function isRegExp2(obj) {
  return Object.prototype.toString.call(obj) === "[object RegExp]";
};
var isBuffer = function isBuffer2(obj) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};
var combine = function combine2(a, b) {
  return [].concat(a, b);
};
var maybeMap = function maybeMap2(val, fn) {
  if (isArray$2(val)) {
    var mapped = [];
    for (var i2 = 0; i2 < val.length; i2 += 1) {
      mapped.push(fn(val[i2]));
    }
    return mapped;
  }
  return fn(val);
};
var utils$2 = {
  arrayToObject,
  assign,
  combine,
  compact,
  decode,
  encode,
  isBuffer,
  isRegExp,
  maybeMap,
  merge: merge$2
};
var getSideChannel2 = sideChannel;
var utils$1 = utils$2;
var formats$1 = formats$3;
var has$1 = Object.prototype.hasOwnProperty;
var arrayPrefixGenerators = {
  brackets: function brackets(prefix) {
    return prefix + "[]";
  },
  comma: "comma",
  indices: function indices(prefix, key) {
    return prefix + "[" + key + "]";
  },
  repeat: function repeat2(prefix) {
    return prefix;
  }
};
var isArray$1 = Array.isArray;
var split = String.prototype.split;
var push = Array.prototype.push;
var pushToArray = function(arr, valueOrArray) {
  push.apply(arr, isArray$1(valueOrArray) ? valueOrArray : [valueOrArray]);
};
var toISO = Date.prototype.toISOString;
var defaultFormat = formats$1["default"];
var defaults$1 = {
  addQueryPrefix: false,
  allowDots: false,
  charset: "utf-8",
  charsetSentinel: false,
  delimiter: "&",
  encode: true,
  encoder: utils$1.encode,
  encodeValuesOnly: false,
  format: defaultFormat,
  formatter: formats$1.formatters[defaultFormat],
  indices: false,
  serializeDate: function serializeDate(date) {
    return toISO.call(date);
  },
  skipNulls: false,
  strictNullHandling: false
};
var isNonNullishPrimitive = function isNonNullishPrimitive2(v) {
  return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
};
var sentinel = {};
var stringify$1 = function stringify(object2, prefix, generateArrayPrefix, commaRoundTrip, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate2, format, formatter, encodeValuesOnly, charset, sideChannel2) {
  var obj = object2;
  var tmpSc = sideChannel2;
  var step = 0;
  var findFlag = false;
  while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
    var pos = tmpSc.get(object2);
    step += 1;
    if (typeof pos !== "undefined") {
      if (pos === step) {
        throw new RangeError("Cyclic object value");
      } else {
        findFlag = true;
      }
    }
    if (typeof tmpSc.get(sentinel) === "undefined") {
      step = 0;
    }
  }
  if (typeof filter === "function") {
    obj = filter(prefix, obj);
  } else if (obj instanceof Date) {
    obj = serializeDate2(obj);
  } else if (generateArrayPrefix === "comma" && isArray$1(obj)) {
    obj = utils$1.maybeMap(obj, function(value2) {
      if (value2 instanceof Date) {
        return serializeDate2(value2);
      }
      return value2;
    });
  }
  if (obj === null) {
    if (strictNullHandling) {
      return encoder && !encodeValuesOnly ? encoder(prefix, defaults$1.encoder, charset, "key", format) : prefix;
    }
    obj = "";
  }
  if (isNonNullishPrimitive(obj) || utils$1.isBuffer(obj)) {
    if (encoder) {
      var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults$1.encoder, charset, "key", format);
      if (generateArrayPrefix === "comma" && encodeValuesOnly) {
        var valuesArray = split.call(String(obj), ",");
        var valuesJoined = "";
        for (var i2 = 0; i2 < valuesArray.length; ++i2) {
          valuesJoined += (i2 === 0 ? "" : ",") + formatter(encoder(valuesArray[i2], defaults$1.encoder, charset, "value", format));
        }
        return [formatter(keyValue) + (commaRoundTrip && isArray$1(obj) && valuesArray.length === 1 ? "[]" : "") + "=" + valuesJoined];
      }
      return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults$1.encoder, charset, "value", format))];
    }
    return [formatter(prefix) + "=" + formatter(String(obj))];
  }
  var values = [];
  if (typeof obj === "undefined") {
    return values;
  }
  var objKeys;
  if (generateArrayPrefix === "comma" && isArray$1(obj)) {
    objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
  } else if (isArray$1(filter)) {
    objKeys = filter;
  } else {
    var keys = Object.keys(obj);
    objKeys = sort ? keys.sort(sort) : keys;
  }
  var adjustedPrefix = commaRoundTrip && isArray$1(obj) && obj.length === 1 ? prefix + "[]" : prefix;
  for (var j = 0; j < objKeys.length; ++j) {
    var key = objKeys[j];
    var value = typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key];
    if (skipNulls && value === null) {
      continue;
    }
    var keyPrefix = isArray$1(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, key) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + key : "[" + key + "]");
    sideChannel2.set(object2, step);
    var valueSideChannel = getSideChannel2();
    valueSideChannel.set(sentinel, sideChannel2);
    pushToArray(values, stringify(value, keyPrefix, generateArrayPrefix, commaRoundTrip, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate2, format, formatter, encodeValuesOnly, charset, valueSideChannel));
  }
  return values;
};
var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
  if (!opts) {
    return defaults$1;
  }
  if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
    throw new TypeError("Encoder has to be a function.");
  }
  var charset = opts.charset || defaults$1.charset;
  if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  }
  var format = formats$1["default"];
  if (typeof opts.format !== "undefined") {
    if (!has$1.call(formats$1.formatters, opts.format)) {
      throw new TypeError("Unknown format option provided.");
    }
    format = opts.format;
  }
  var formatter = formats$1.formatters[format];
  var filter = defaults$1.filter;
  if (typeof opts.filter === "function" || isArray$1(opts.filter)) {
    filter = opts.filter;
  }
  return {
    addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults$1.addQueryPrefix,
    allowDots: typeof opts.allowDots === "undefined" ? defaults$1.allowDots : !!opts.allowDots,
    charset,
    charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults$1.charsetSentinel,
    delimiter: typeof opts.delimiter === "undefined" ? defaults$1.delimiter : opts.delimiter,
    encode: typeof opts.encode === "boolean" ? opts.encode : defaults$1.encode,
    encoder: typeof opts.encoder === "function" ? opts.encoder : defaults$1.encoder,
    encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults$1.encodeValuesOnly,
    filter,
    format,
    formatter,
    serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults$1.serializeDate,
    skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults$1.skipNulls,
    sort: typeof opts.sort === "function" ? opts.sort : null,
    strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults$1.strictNullHandling
  };
};
var stringify_1 = function(object2, opts) {
  var obj = object2;
  var options = normalizeStringifyOptions(opts);
  var objKeys;
  var filter;
  if (typeof options.filter === "function") {
    filter = options.filter;
    obj = filter("", obj);
  } else if (isArray$1(options.filter)) {
    filter = options.filter;
    objKeys = filter;
  }
  var keys = [];
  if (typeof obj !== "object" || obj === null) {
    return "";
  }
  var arrayFormat;
  if (opts && opts.arrayFormat in arrayPrefixGenerators) {
    arrayFormat = opts.arrayFormat;
  } else if (opts && "indices" in opts) {
    arrayFormat = opts.indices ? "indices" : "repeat";
  } else {
    arrayFormat = "indices";
  }
  var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
  if (opts && "commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
    throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
  }
  var commaRoundTrip = generateArrayPrefix === "comma" && opts && opts.commaRoundTrip;
  if (!objKeys) {
    objKeys = Object.keys(obj);
  }
  if (options.sort) {
    objKeys.sort(options.sort);
  }
  var sideChannel2 = getSideChannel2();
  for (var i2 = 0; i2 < objKeys.length; ++i2) {
    var key = objKeys[i2];
    if (options.skipNulls && obj[key] === null) {
      continue;
    }
    pushToArray(keys, stringify$1(obj[key], key, generateArrayPrefix, commaRoundTrip, options.strictNullHandling, options.skipNulls, options.encode ? options.encoder : null, options.filter, options.sort, options.allowDots, options.serializeDate, options.format, options.formatter, options.encodeValuesOnly, options.charset, sideChannel2));
  }
  var joined = keys.join(options.delimiter);
  var prefix = options.addQueryPrefix === true ? "?" : "";
  if (options.charsetSentinel) {
    if (options.charset === "iso-8859-1") {
      prefix += "utf8=%26%2310003%3B&";
    } else {
      prefix += "utf8=%E2%9C%93&";
    }
  }
  return joined.length > 0 ? prefix + joined : "";
};
var utils = utils$2;
var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;
var defaults = {
  allowDots: false,
  allowPrototypes: false,
  allowSparse: false,
  arrayLimit: 20,
  charset: "utf-8",
  charsetSentinel: false,
  comma: false,
  decoder: utils.decode,
  delimiter: "&",
  depth: 5,
  ignoreQueryPrefix: false,
  interpretNumericEntities: false,
  parameterLimit: 1e3,
  parseArrays: true,
  plainObjects: false,
  strictNullHandling: false
};
var interpretNumericEntities = function(str) {
  return str.replace(/&#(\d+);/g, function($0, numberStr) {
    return String.fromCharCode(parseInt(numberStr, 10));
  });
};
var parseArrayValue = function(val, options) {
  if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
    return val.split(",");
  }
  return val;
};
var isoSentinel = "utf8=%26%2310003%3B";
var charsetSentinel = "utf8=%E2%9C%93";
var parseValues = function parseQueryStringValues(str, options) {
  var obj = {};
  var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
  var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
  var parts = cleanStr.split(options.delimiter, limit);
  var skipIndex = -1;
  var i2;
  var charset = options.charset;
  if (options.charsetSentinel) {
    for (i2 = 0; i2 < parts.length; ++i2) {
      if (parts[i2].indexOf("utf8=") === 0) {
        if (parts[i2] === charsetSentinel) {
          charset = "utf-8";
        } else if (parts[i2] === isoSentinel) {
          charset = "iso-8859-1";
        }
        skipIndex = i2;
        i2 = parts.length;
      }
    }
  }
  for (i2 = 0; i2 < parts.length; ++i2) {
    if (i2 === skipIndex) {
      continue;
    }
    var part = parts[i2];
    var bracketEqualsPos = part.indexOf("]=");
    var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
    var key, val;
    if (pos === -1) {
      key = options.decoder(part, defaults.decoder, charset, "key");
      val = options.strictNullHandling ? null : "";
    } else {
      key = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
      val = utils.maybeMap(parseArrayValue(part.slice(pos + 1), options), function(encodedVal) {
        return options.decoder(encodedVal, defaults.decoder, charset, "value");
      });
    }
    if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
      val = interpretNumericEntities(val);
    }
    if (part.indexOf("[]=") > -1) {
      val = isArray(val) ? [val] : val;
    }
    if (has.call(obj, key)) {
      obj[key] = utils.combine(obj[key], val);
    } else {
      obj[key] = val;
    }
  }
  return obj;
};
var parseObject = function(chain, val, options, valuesParsed) {
  var leaf = valuesParsed ? val : parseArrayValue(val, options);
  for (var i2 = chain.length - 1; i2 >= 0; --i2) {
    var obj;
    var root = chain[i2];
    if (root === "[]" && options.parseArrays) {
      obj = [].concat(leaf);
    } else {
      obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
      var index2 = parseInt(cleanRoot, 10);
      if (!options.parseArrays && cleanRoot === "") {
        obj = { 0: leaf };
      } else if (!isNaN(index2) && root !== cleanRoot && String(index2) === cleanRoot && index2 >= 0 && (options.parseArrays && index2 <= options.arrayLimit)) {
        obj = [];
        obj[index2] = leaf;
      } else if (cleanRoot !== "__proto__") {
        obj[cleanRoot] = leaf;
      }
    }
    leaf = obj;
  }
  return leaf;
};
var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
  if (!givenKey) {
    return;
  }
  var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
  var brackets2 = /(\[[^[\]]*])/;
  var child = /(\[[^[\]]*])/g;
  var segment = options.depth > 0 && brackets2.exec(key);
  var parent2 = segment ? key.slice(0, segment.index) : key;
  var keys = [];
  if (parent2) {
    if (!options.plainObjects && has.call(Object.prototype, parent2)) {
      if (!options.allowPrototypes) {
        return;
      }
    }
    keys.push(parent2);
  }
  var i2 = 0;
  while (options.depth > 0 && (segment = child.exec(key)) !== null && i2 < options.depth) {
    i2 += 1;
    if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
      if (!options.allowPrototypes) {
        return;
      }
    }
    keys.push(segment[1]);
  }
  if (segment) {
    keys.push("[" + key.slice(segment.index) + "]");
  }
  return parseObject(keys, val, options, valuesParsed);
};
var normalizeParseOptions = function normalizeParseOptions2(opts) {
  if (!opts) {
    return defaults;
  }
  if (opts.decoder !== null && opts.decoder !== void 0 && typeof opts.decoder !== "function") {
    throw new TypeError("Decoder has to be a function.");
  }
  if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  }
  var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
  return {
    allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
    allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
    allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
    arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
    charset,
    charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
    comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
    decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
    delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
    depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
    ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
    interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
    parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
    parseArrays: opts.parseArrays !== false,
    plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
    strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
  };
};
var parse$1 = function(str, opts) {
  var options = normalizeParseOptions(opts);
  if (str === "" || str === null || typeof str === "undefined") {
    return options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
  }
  var tempObj = typeof str === "string" ? parseValues(str, options) : str;
  var obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
  var keys = Object.keys(tempObj);
  for (var i2 = 0; i2 < keys.length; ++i2) {
    var key = keys[i2];
    var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
    obj = utils.merge(obj, newObj, options);
  }
  if (options.allowSparse === true) {
    return obj;
  }
  return utils.compact(obj);
};
var stringify2 = stringify_1;
var parse = parse$1;
var formats = formats$3;
var lib = {
  formats,
  parse,
  stringify: stringify2
};
class ClientMsgs extends base.PagedCollection {
  constructor() {
    super(...arguments);
    __publicField(this, "url", "/public/clients/messages");
  }
  isEmpty() {
    return this.models.length == 0;
  }
}
class UserMsgs extends base.PagedCollection {
  constructor() {
    super(...arguments);
    __publicField(this, "url", "/users/messages");
  }
}
let clientMsgs = new ClientMsgs();
let userMsgs = new UserMsgs([], {
  orderBy: "-ts",
  limit: 25
});
let count = derived([clientMsgs, userMsgs], ([$1, $2]) => $1.length + $2.length);
let flash = derived([clientMsgs, userMsgs], ([$1, $2]) => $1.find((m) => m.get("flash")) || $2.find((m) => m.get("flash")));
const route = writable({
  prefix: "all"
});
const domo$6 = window.domo;
if (!domo$6) {
  throw new Error("ADD domo");
}
const async$6 = window.async;
if (!async$6) {
  throw new Error("ADD async");
}
const FeedEntry$1 = View$1.Base.extend({
  name: "FeedEntry",
  className: "mb3 bb b--black-20",
  render: function() {
    const attrs = this.model.attributes;
    let date = attrs.pubdate || attrs.date;
    let preview;
    this.$el.append(H4({ "class": "mb2" }, A({
      "class": "black-80",
      href: attrs.link
    }, attrs.title)), DIV({ "class": "mb2 black-40" }, moment(date).format("LLL")), preview = DIV({ "class": "summary mb2" }));
    $(preview).html(attrs.description || attrs.summary || "");
    return this;
  }
});
const FeedEntryList = View$1.Collection.extend({
  name: "FeedEntryList",
  addOne: function(model) {
    const view = new FeedEntry$1({
      parent: this,
      model
    }).render();
    this.$el.append(view.el);
    return view;
  }
});
const Feed$1 = View$1.Base.extend({
  name: "Feed",
  render: function() {
    const attrs = this.model.attributes;
    this.$el.append(H3(A({ href: attrs.link }, attrs.title)), DIV({ "class": "pb2 mb2 bb b--black-20" }, attrs.description || attrs.summary || ""), new FeedEntryList({
      parent: this,
      collection: this.model.get("entries")
    }).render().el);
    return this;
  }
});
var View = {
  Feed: Feed$1,
  FeedEntry: FeedEntry$1,
  FeedEntryList
};
const FeedEntry = base.Model.extend();
const FeedEntryCollection = base.Collection.extend({
  model: FeedEntry
});
const Feed = base.Model.extend({
  parse: function(response) {
    response.entries = new FeedEntryCollection(response.entries);
    return response;
  }
});
var Model$1 = {
  Feed,
  FeedEntry,
  FeedEntryCollection
};
const get_tvi_right_content_slot_changes = (dirty) => ({});
const get_tvi_right_content_slot_context = (ctx) => ({});
const get_tvi_label_slot_changes = (dirty) => ({});
const get_tvi_label_slot_context = (ctx) => ({});
const get_tvi_icon_slot_changes = (dirty) => ({});
const get_tvi_icon_slot_context = (ctx) => ({});
const get_tvi_checkbox_slot_changes = (dirty) => ({});
const get_tvi_checkbox_slot_context = (ctx) => ({});
const get_tvi_expandable_slot_changes = (dirty) => ({});
const get_tvi_expandable_slot_context = (ctx) => ({});
function create_if_block$J(ctx) {
  let current;
  const tvi_expandable_slot_template = ctx[9]["tvi-expandable"];
  const tvi_expandable_slot = create_slot(tvi_expandable_slot_template, ctx, ctx[8], get_tvi_expandable_slot_context);
  return {
    c() {
      if (tvi_expandable_slot)
        tvi_expandable_slot.c();
    },
    m(target, anchor) {
      if (tvi_expandable_slot) {
        tvi_expandable_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (tvi_expandable_slot) {
        if (tvi_expandable_slot.p && (!current || dirty & 256)) {
          update_slot_base(tvi_expandable_slot, tvi_expandable_slot_template, ctx2, ctx2[8], !current ? get_all_dirty_from_scope(ctx2[8]) : get_slot_changes(tvi_expandable_slot_template, ctx2[8], dirty, get_tvi_expandable_slot_changes), get_tvi_expandable_slot_context);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(tvi_expandable_slot, local);
      current = true;
    },
    o(local) {
      transition_out(tvi_expandable_slot, local);
      current = false;
    },
    d(detaching) {
      if (tvi_expandable_slot)
        tvi_expandable_slot.d(detaching);
    }
  };
}
function fallback_block$2(ctx) {
  let t_value = ctx[5].label + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 32 && t_value !== (t_value = ctx2[5].label + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_fragment$1E(ctx) {
  let div7;
  let div5;
  let div4;
  let div0;
  let show_if = ctx[5].isExpandable();
  let t0;
  let div1;
  let t1;
  let div2;
  let t2;
  let div3;
  let div4_class_value;
  let div4_disabled_value;
  let t3;
  let div6;
  let div6_class_value;
  let action_action;
  let current;
  let mounted;
  let dispose;
  let if_block = show_if && create_if_block$J(ctx);
  const tvi_checkbox_slot_template = ctx[9]["tvi-checkbox"];
  const tvi_checkbox_slot = create_slot(tvi_checkbox_slot_template, ctx, ctx[8], get_tvi_checkbox_slot_context);
  const tvi_icon_slot_template = ctx[9]["tvi-icon"];
  const tvi_icon_slot = create_slot(tvi_icon_slot_template, ctx, ctx[8], get_tvi_icon_slot_context);
  const tvi_label_slot_template = ctx[9]["tvi-label"];
  const tvi_label_slot = create_slot(tvi_label_slot_template, ctx, ctx[8], get_tvi_label_slot_context);
  const tvi_label_slot_or_fallback = tvi_label_slot || fallback_block$2(ctx);
  const tvi_right_content_slot_template = ctx[9]["tvi-right-content"];
  const tvi_right_content_slot = create_slot(tvi_right_content_slot_template, ctx, ctx[8], get_tvi_right_content_slot_context);
  return {
    c() {
      div7 = element("div");
      div5 = element("div");
      div4 = element("div");
      div0 = element("div");
      if (if_block)
        if_block.c();
      t0 = space();
      div1 = element("div");
      if (tvi_checkbox_slot)
        tvi_checkbox_slot.c();
      t1 = space();
      div2 = element("div");
      if (tvi_icon_slot)
        tvi_icon_slot.c();
      t2 = space();
      div3 = element("div");
      if (tvi_label_slot_or_fallback)
        tvi_label_slot_or_fallback.c();
      t3 = space();
      div6 = element("div");
      if (tvi_right_content_slot)
        tvi_right_content_slot.c();
      attr(div0, "class", "tv-caret");
      toggle_class(div1, "tv-checkbox", ctx[5].isCheckable());
      toggle_class(div2, "tv-icon", ctx[2]);
      attr(div3, "class", "tv-label");
      attr(div4, "class", div4_class_value = `tv-flex tv-flex-row ${ctx[3] === "medium" ? "tv-md" : ctx[3] === "small" ? "tv-sm" : "tv-lg"}`);
      attr(div4, "disabled", div4_disabled_value = ctx[5].isDisabled());
      attr(div4, "tabindex", ctx[1]);
      set_style(div4, "padding-left", "calc(" + ctx[5].getNodeLevel() + "*16px - 4px)");
      attr(div5, "class", "tv-key");
      attr(div6, "class", div6_class_value = `tv-key-meta tv-flex tv-flex-row tv-flex-wrap tv-tree-item ${ctx[3] === "medium" ? "tv-md" : ctx[3] === "small" ? "tv-sm" : "tv-lg"}`);
      attr(div7, "class", "tv-flex tv-container w-full tv-tree-item");
      toggle_class(div7, "tv-hover-select", ctx[5].selected);
    },
    m(target, anchor) {
      insert(target, div7, anchor);
      append(div7, div5);
      append(div5, div4);
      append(div4, div0);
      if (if_block)
        if_block.m(div0, null);
      append(div4, t0);
      append(div4, div1);
      if (tvi_checkbox_slot) {
        tvi_checkbox_slot.m(div1, null);
      }
      append(div4, t1);
      append(div4, div2);
      if (tvi_icon_slot) {
        tvi_icon_slot.m(div2, null);
      }
      append(div4, t2);
      append(div4, div3);
      if (tvi_label_slot_or_fallback) {
        tvi_label_slot_or_fallback.m(div3, null);
      }
      append(div7, t3);
      append(div7, div6);
      if (tvi_right_content_slot) {
        tvi_right_content_slot.m(div6, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(div3, "click", ctx[6]),
          action_destroyer(action_action = ctx[4].call(null, div7, ctx[5]))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 32)
        show_if = ctx2[5].isExpandable();
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 32) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$J(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div0, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (tvi_checkbox_slot) {
        if (tvi_checkbox_slot.p && (!current || dirty & 256)) {
          update_slot_base(tvi_checkbox_slot, tvi_checkbox_slot_template, ctx2, ctx2[8], !current ? get_all_dirty_from_scope(ctx2[8]) : get_slot_changes(tvi_checkbox_slot_template, ctx2[8], dirty, get_tvi_checkbox_slot_changes), get_tvi_checkbox_slot_context);
        }
      }
      if (dirty & 32) {
        toggle_class(div1, "tv-checkbox", ctx2[5].isCheckable());
      }
      if (tvi_icon_slot) {
        if (tvi_icon_slot.p && (!current || dirty & 256)) {
          update_slot_base(tvi_icon_slot, tvi_icon_slot_template, ctx2, ctx2[8], !current ? get_all_dirty_from_scope(ctx2[8]) : get_slot_changes(tvi_icon_slot_template, ctx2[8], dirty, get_tvi_icon_slot_changes), get_tvi_icon_slot_context);
        }
      }
      if (dirty & 4) {
        toggle_class(div2, "tv-icon", ctx2[2]);
      }
      if (tvi_label_slot) {
        if (tvi_label_slot.p && (!current || dirty & 256)) {
          update_slot_base(tvi_label_slot, tvi_label_slot_template, ctx2, ctx2[8], !current ? get_all_dirty_from_scope(ctx2[8]) : get_slot_changes(tvi_label_slot_template, ctx2[8], dirty, get_tvi_label_slot_changes), get_tvi_label_slot_context);
        }
      } else {
        if (tvi_label_slot_or_fallback && tvi_label_slot_or_fallback.p && (!current || dirty & 32)) {
          tvi_label_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & 8 && div4_class_value !== (div4_class_value = `tv-flex tv-flex-row ${ctx2[3] === "medium" ? "tv-md" : ctx2[3] === "small" ? "tv-sm" : "tv-lg"}`)) {
        attr(div4, "class", div4_class_value);
      }
      if (!current || dirty & 32 && div4_disabled_value !== (div4_disabled_value = ctx2[5].isDisabled())) {
        attr(div4, "disabled", div4_disabled_value);
      }
      if (!current || dirty & 2) {
        attr(div4, "tabindex", ctx2[1]);
      }
      if (!current || dirty & 32) {
        set_style(div4, "padding-left", "calc(" + ctx2[5].getNodeLevel() + "*16px - 4px)");
      }
      if (tvi_right_content_slot) {
        if (tvi_right_content_slot.p && (!current || dirty & 256)) {
          update_slot_base(tvi_right_content_slot, tvi_right_content_slot_template, ctx2, ctx2[8], !current ? get_all_dirty_from_scope(ctx2[8]) : get_slot_changes(tvi_right_content_slot_template, ctx2[8], dirty, get_tvi_right_content_slot_changes), get_tvi_right_content_slot_context);
        }
      }
      if (!current || dirty & 8 && div6_class_value !== (div6_class_value = `tv-key-meta tv-flex tv-flex-row tv-flex-wrap tv-tree-item ${ctx2[3] === "medium" ? "tv-md" : ctx2[3] === "small" ? "tv-sm" : "tv-lg"}`)) {
        attr(div6, "class", div6_class_value);
      }
      if (action_action && is_function(action_action.update) && dirty & 32)
        action_action.update.call(null, ctx2[5]);
      if (dirty & 32) {
        toggle_class(div7, "tv-hover-select", ctx2[5].selected);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(tvi_checkbox_slot, local);
      transition_in(tvi_icon_slot, local);
      transition_in(tvi_label_slot_or_fallback, local);
      transition_in(tvi_right_content_slot, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(tvi_checkbox_slot, local);
      transition_out(tvi_icon_slot, local);
      transition_out(tvi_label_slot_or_fallback, local);
      transition_out(tvi_right_content_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div7);
      if (if_block)
        if_block.d();
      if (tvi_checkbox_slot)
        tvi_checkbox_slot.d(detaching);
      if (tvi_icon_slot)
        tvi_icon_slot.d(detaching);
      if (tvi_label_slot_or_fallback)
        tvi_label_slot_or_fallback.d(detaching);
      if (tvi_right_content_slot)
        tvi_right_content_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$1x($$self, $$props, $$invalidate) {
  let $node, $$unsubscribe_node = noop, $$subscribe_node = () => ($$unsubscribe_node(), $$unsubscribe_node = subscribe(node2, ($$value) => $$invalidate(5, $node = $$value)), node2);
  $$self.$$.on_destroy.push(() => $$unsubscribe_node());
  let { $$slots: slots = {}, $$scope } = $$props;
  let { node: node2 } = $$props;
  $$subscribe_node();
  let { tabindex = "-1" } = $$props;
  let { isIcon = false } = $$props;
  let { size = "medium" } = $$props;
  let { action } = $$props;
  const dispatch = createEventDispatcher();
  function onClick(e) {
    e.preventDefault();
    dispatch("click", { e, node: node2 });
  }
  let { showRoot } = $$props;
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$subscribe_node($$invalidate(0, node2 = $$props2.node));
    if ("tabindex" in $$props2)
      $$invalidate(1, tabindex = $$props2.tabindex);
    if ("isIcon" in $$props2)
      $$invalidate(2, isIcon = $$props2.isIcon);
    if ("size" in $$props2)
      $$invalidate(3, size = $$props2.size);
    if ("action" in $$props2)
      $$invalidate(4, action = $$props2.action);
    if ("showRoot" in $$props2)
      $$invalidate(7, showRoot = $$props2.showRoot);
    if ("$$scope" in $$props2)
      $$invalidate(8, $$scope = $$props2.$$scope);
  };
  return [node2, tabindex, isIcon, size, action, $node, onClick, showRoot, $$scope, slots];
}
class TreeviewItem extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1x, create_fragment$1E, safe_not_equal, {
      node: 0,
      tabindex: 1,
      isIcon: 2,
      size: 3,
      action: 4,
      showRoot: 7
    });
  }
}
function get_each_context$n(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list[i2];
  return child_ctx;
}
const get_expandable_slot_changes_1 = (dirty) => ({ node: dirty & 16 });
const get_expandable_slot_context_1 = (ctx) => ({
  slot: "expandable",
  node: ctx[4]
});
const get_checkbox_slot_changes_1 = (dirty) => ({ node: dirty & 16 });
const get_checkbox_slot_context_1 = (ctx) => ({ slot: "checkbox", node: ctx[4] });
const get_icon_slot_changes_1 = (dirty) => ({ node: dirty & 16 });
const get_icon_slot_context_1 = (ctx) => ({ slot: "icon", node: ctx[4] });
const get_label_slot_changes_1 = (dirty) => ({ node: dirty & 16 });
const get_label_slot_context_1 = (ctx) => ({ slot: "label", node: ctx[4] });
const get_right_content_slot_changes_1 = (dirty) => ({ node: dirty & 16 });
const get_right_content_slot_context_1 = (ctx) => ({
  slot: "right-content",
  node: ctx[4]
});
const get_expandable_slot_changes$1 = (dirty) => ({ node: dirty & 16 });
const get_expandable_slot_context$1 = (ctx) => ({ node: ctx[4] });
const get_checkbox_slot_changes$1 = (dirty) => ({ node: dirty & 16 });
const get_checkbox_slot_context$1 = (ctx) => ({ node: ctx[4] });
const get_icon_slot_changes$3 = (dirty) => ({ node: dirty & 16 });
const get_icon_slot_context$3 = (ctx) => ({ node: ctx[4] });
const get_label_slot_changes$2 = (dirty) => ({ node: dirty & 16 });
const get_label_slot_context$2 = (ctx) => ({ slot: "tvi-label", node: ctx[4] });
const get_right_content_slot_changes = (dirty) => ({ node: dirty & 16 });
const get_right_content_slot_context = (ctx) => ({ node: ctx[4] });
function create_tvi_expandable_slot(ctx) {
  let div;
  let current;
  const expandable_slot_template = ctx[9].expandable;
  const expandable_slot = create_slot(expandable_slot_template, ctx, ctx[12], get_expandable_slot_context$1);
  return {
    c() {
      div = element("div");
      if (expandable_slot)
        expandable_slot.c();
      attr(div, "slot", "tvi-expandable");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (expandable_slot) {
        expandable_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (expandable_slot) {
        if (expandable_slot.p && (!current || dirty & 4112)) {
          update_slot_base(expandable_slot, expandable_slot_template, ctx2, ctx2[12], !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(expandable_slot_template, ctx2[12], dirty, get_expandable_slot_changes$1), get_expandable_slot_context$1);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(expandable_slot, local);
      current = true;
    },
    o(local) {
      transition_out(expandable_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (expandable_slot)
        expandable_slot.d(detaching);
    }
  };
}
function create_tvi_checkbox_slot(ctx) {
  let div;
  let current;
  const checkbox_slot_template = ctx[9].checkbox;
  const checkbox_slot = create_slot(checkbox_slot_template, ctx, ctx[12], get_checkbox_slot_context$1);
  return {
    c() {
      div = element("div");
      if (checkbox_slot)
        checkbox_slot.c();
      attr(div, "slot", "tvi-checkbox");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (checkbox_slot) {
        checkbox_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (checkbox_slot) {
        if (checkbox_slot.p && (!current || dirty & 4112)) {
          update_slot_base(checkbox_slot, checkbox_slot_template, ctx2, ctx2[12], !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(checkbox_slot_template, ctx2[12], dirty, get_checkbox_slot_changes$1), get_checkbox_slot_context$1);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(checkbox_slot, local);
      current = true;
    },
    o(local) {
      transition_out(checkbox_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (checkbox_slot)
        checkbox_slot.d(detaching);
    }
  };
}
function create_tvi_icon_slot(ctx) {
  let div;
  let current;
  const icon_slot_template = ctx[9].icon;
  const icon_slot = create_slot(icon_slot_template, ctx, ctx[12], get_icon_slot_context$3);
  return {
    c() {
      div = element("div");
      if (icon_slot)
        icon_slot.c();
      attr(div, "slot", "tvi-icon");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (icon_slot) {
        icon_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & 4112)) {
          update_slot_base(icon_slot, icon_slot_template, ctx2, ctx2[12], !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(icon_slot_template, ctx2[12], dirty, get_icon_slot_changes$3), get_icon_slot_context$3);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon_slot, local);
      current = true;
    },
    o(local) {
      transition_out(icon_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (icon_slot)
        icon_slot.d(detaching);
    }
  };
}
function create_tvi_label_slot(ctx) {
  let current;
  const label_slot_template = ctx[9].label;
  const label_slot = create_slot(label_slot_template, ctx, ctx[12], get_label_slot_context$2);
  return {
    c() {
      if (label_slot)
        label_slot.c();
    },
    m(target, anchor) {
      if (label_slot) {
        label_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (label_slot) {
        if (label_slot.p && (!current || dirty & 4112)) {
          update_slot_base(label_slot, label_slot_template, ctx2, ctx2[12], !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(label_slot_template, ctx2[12], dirty, get_label_slot_changes$2), get_label_slot_context$2);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(label_slot, local);
      current = true;
    },
    o(local) {
      transition_out(label_slot, local);
      current = false;
    },
    d(detaching) {
      if (label_slot)
        label_slot.d(detaching);
    }
  };
}
function create_tvi_right_content_slot(ctx) {
  let div;
  let current;
  const right_content_slot_template = ctx[9]["right-content"];
  const right_content_slot = create_slot(right_content_slot_template, ctx, ctx[12], get_right_content_slot_context);
  return {
    c() {
      div = element("div");
      if (right_content_slot)
        right_content_slot.c();
      attr(div, "slot", "tvi-right-content");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (right_content_slot) {
        right_content_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (right_content_slot) {
        if (right_content_slot.p && (!current || dirty & 4112)) {
          update_slot_base(right_content_slot, right_content_slot_template, ctx2, ctx2[12], !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(right_content_slot_template, ctx2[12], dirty, get_right_content_slot_changes), get_right_content_slot_context);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(right_content_slot, local);
      current = true;
    },
    o(local) {
      transition_out(right_content_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (right_content_slot)
        right_content_slot.d(detaching);
    }
  };
}
function create_if_block$I(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_1$r, create_else_block$r];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[7])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_else_block$r(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ctx[6];
  const get_key = (ctx2) => ctx2[14].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$n(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$n(key, child_ctx));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 4187) {
        each_value = ctx2[6];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$n, each_1_anchor, get_each_context$n);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_if_block_1$r(ctx) {
  let div;
  let t;
  return {
    c() {
      div = element("div");
      t = text("Loading...");
      set_style(div, "padding-left", "calc(" + (ctx[5].getNodeLevel() + 1) + "*16px - 4px)");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & 32) {
        set_style(div, "padding-left", "calc(" + (ctx2[5].getNodeLevel() + 1) + "*16px - 4px)");
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_expandable_slot$1(ctx) {
  let current;
  const expandable_slot_template = ctx[9].expandable;
  const expandable_slot = create_slot(expandable_slot_template, ctx, ctx[12], get_expandable_slot_context_1);
  return {
    c() {
      if (expandable_slot)
        expandable_slot.c();
    },
    m(target, anchor) {
      if (expandable_slot) {
        expandable_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (expandable_slot) {
        if (expandable_slot.p && (!current || dirty & 4112)) {
          update_slot_base(expandable_slot, expandable_slot_template, ctx2, ctx2[12], !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(expandable_slot_template, ctx2[12], dirty, get_expandable_slot_changes_1), get_expandable_slot_context_1);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(expandable_slot, local);
      current = true;
    },
    o(local) {
      transition_out(expandable_slot, local);
      current = false;
    },
    d(detaching) {
      if (expandable_slot)
        expandable_slot.d(detaching);
    }
  };
}
function create_checkbox_slot$1(ctx) {
  let current;
  const checkbox_slot_template = ctx[9].checkbox;
  const checkbox_slot = create_slot(checkbox_slot_template, ctx, ctx[12], get_checkbox_slot_context_1);
  return {
    c() {
      if (checkbox_slot)
        checkbox_slot.c();
    },
    m(target, anchor) {
      if (checkbox_slot) {
        checkbox_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (checkbox_slot) {
        if (checkbox_slot.p && (!current || dirty & 4112)) {
          update_slot_base(checkbox_slot, checkbox_slot_template, ctx2, ctx2[12], !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(checkbox_slot_template, ctx2[12], dirty, get_checkbox_slot_changes_1), get_checkbox_slot_context_1);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(checkbox_slot, local);
      current = true;
    },
    o(local) {
      transition_out(checkbox_slot, local);
      current = false;
    },
    d(detaching) {
      if (checkbox_slot)
        checkbox_slot.d(detaching);
    }
  };
}
function create_icon_slot$6(ctx) {
  let current;
  const icon_slot_template = ctx[9].icon;
  const icon_slot = create_slot(icon_slot_template, ctx, ctx[12], get_icon_slot_context_1);
  return {
    c() {
      if (icon_slot)
        icon_slot.c();
    },
    m(target, anchor) {
      if (icon_slot) {
        icon_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & 4112)) {
          update_slot_base(icon_slot, icon_slot_template, ctx2, ctx2[12], !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(icon_slot_template, ctx2[12], dirty, get_icon_slot_changes_1), get_icon_slot_context_1);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon_slot, local);
      current = true;
    },
    o(local) {
      transition_out(icon_slot, local);
      current = false;
    },
    d(detaching) {
      if (icon_slot)
        icon_slot.d(detaching);
    }
  };
}
function create_label_slot$3(ctx) {
  let current;
  const label_slot_template = ctx[9].label;
  const label_slot = create_slot(label_slot_template, ctx, ctx[12], get_label_slot_context_1);
  return {
    c() {
      if (label_slot)
        label_slot.c();
    },
    m(target, anchor) {
      if (label_slot) {
        label_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (label_slot) {
        if (label_slot.p && (!current || dirty & 4112)) {
          update_slot_base(label_slot, label_slot_template, ctx2, ctx2[12], !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(label_slot_template, ctx2[12], dirty, get_label_slot_changes_1), get_label_slot_context_1);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(label_slot, local);
      current = true;
    },
    o(local) {
      transition_out(label_slot, local);
      current = false;
    },
    d(detaching) {
      if (label_slot)
        label_slot.d(detaching);
    }
  };
}
function create_right_content_slot$1(ctx) {
  let current;
  const right_content_slot_template = ctx[9]["right-content"];
  const right_content_slot = create_slot(right_content_slot_template, ctx, ctx[12], get_right_content_slot_context_1);
  return {
    c() {
      if (right_content_slot)
        right_content_slot.c();
    },
    m(target, anchor) {
      if (right_content_slot) {
        right_content_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (right_content_slot) {
        if (right_content_slot.p && (!current || dirty & 4112)) {
          update_slot_base(right_content_slot, right_content_slot_template, ctx2, ctx2[12], !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(right_content_slot_template, ctx2[12], dirty, get_right_content_slot_changes_1), get_right_content_slot_context_1);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(right_content_slot, local);
      current = true;
    },
    o(local) {
      transition_out(right_content_slot, local);
      current = false;
    },
    d(detaching) {
      if (right_content_slot)
        right_content_slot.d(detaching);
    }
  };
}
function create_each_block$n(key_1, ctx) {
  let first;
  let treenode;
  let current;
  treenode = new TreeNode({
    props: {
      node: ctx[14],
      isIcon: ctx[1],
      size: ctx[3],
      action: ctx[0],
      $$slots: {
        "right-content": [
          create_right_content_slot$1,
          ({ node: node2 }) => ({ 4: node2 }),
          ({ node: node2 }) => node2 ? 16 : 0
        ],
        label: [
          create_label_slot$3,
          ({ node: node2 }) => ({ 4: node2 }),
          ({ node: node2 }) => node2 ? 16 : 0
        ],
        icon: [
          create_icon_slot$6,
          ({ node: node2 }) => ({ 4: node2 }),
          ({ node: node2 }) => node2 ? 16 : 0
        ],
        checkbox: [
          create_checkbox_slot$1,
          ({ node: node2 }) => ({ 4: node2 }),
          ({ node: node2 }) => node2 ? 16 : 0
        ],
        expandable: [
          create_expandable_slot$1,
          ({ node: node2 }) => ({ 4: node2 }),
          ({ node: node2 }) => node2 ? 16 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  treenode.$on("click", ctx[11]);
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(treenode.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(treenode, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const treenode_changes = {};
      if (dirty & 64)
        treenode_changes.node = ctx[14];
      if (dirty & 2)
        treenode_changes.isIcon = ctx[1];
      if (dirty & 8)
        treenode_changes.size = ctx[3];
      if (dirty & 1)
        treenode_changes.action = ctx[0];
      if (dirty & 4112) {
        treenode_changes.$$scope = { dirty, ctx };
      }
      treenode.$set(treenode_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(treenode.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(treenode.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      destroy_component(treenode, detaching);
    }
  };
}
function create_fragment$1D(ctx) {
  let treeviewitem;
  let t;
  let show_if = ctx[5].isExpanded();
  let if_block_anchor;
  let current;
  treeviewitem = new TreeviewItem({
    props: {
      tabindex: ctx[5].getSelected() || ctx[8] ? "0" : "-1",
      node: ctx[5],
      isIcon: ctx[1],
      size: ctx[3],
      showRoot: ctx[8] ? ctx[2] : true,
      action: ctx[0],
      $$slots: {
        "tvi-right-content": [create_tvi_right_content_slot],
        "tvi-label": [create_tvi_label_slot],
        "tvi-icon": [create_tvi_icon_slot],
        "tvi-checkbox": [create_tvi_checkbox_slot],
        "tvi-expandable": [create_tvi_expandable_slot]
      },
      $$scope: { ctx }
    }
  });
  treeviewitem.$on("click", ctx[10]);
  let if_block = show_if && create_if_block$I(ctx);
  return {
    c() {
      create_component(treeviewitem.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(treeviewitem, target, anchor);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const treeviewitem_changes = {};
      if (dirty & 288)
        treeviewitem_changes.tabindex = ctx2[5].getSelected() || ctx2[8] ? "0" : "-1";
      if (dirty & 32)
        treeviewitem_changes.node = ctx2[5];
      if (dirty & 2)
        treeviewitem_changes.isIcon = ctx2[1];
      if (dirty & 8)
        treeviewitem_changes.size = ctx2[3];
      if (dirty & 260)
        treeviewitem_changes.showRoot = ctx2[8] ? ctx2[2] : true;
      if (dirty & 1)
        treeviewitem_changes.action = ctx2[0];
      if (dirty & 4112) {
        treeviewitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      treeviewitem.$set(treeviewitem_changes);
      if (dirty & 32)
        show_if = ctx2[5].isExpanded();
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 32) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$I(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(treeviewitem.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(treeviewitem.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      destroy_component(treeviewitem, detaching);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$1w($$self, $$props, $$invalidate) {
  let _root;
  let $node, $$unsubscribe_node = noop, $$subscribe_node = () => ($$unsubscribe_node(), $$unsubscribe_node = subscribe(node2, ($$value) => $$invalidate(5, $node = $$value)), node2);
  $$self.$$.on_destroy.push(() => $$unsubscribe_node());
  let { $$slots: slots = {}, $$scope } = $$props;
  let { node: node2 } = $$props;
  $$subscribe_node();
  let { action } = $$props;
  let { isIcon } = $$props;
  let { showRoot = true } = $$props;
  let { size = "medium" } = $$props;
  let children = [];
  let loading2 = false;
  async function getChildren(node3) {
    if (node3.isExpanded()) {
      if (children.length === 0) {
        $$invalidate(7, loading2 = true);
      }
      $$invalidate(6, children = await node3.getChildren());
      $$invalidate(7, loading2 = false);
    } else {
      $$invalidate(6, children = []);
    }
  }
  function click_handler2(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$subscribe_node($$invalidate(4, node2 = $$props2.node));
    if ("action" in $$props2)
      $$invalidate(0, action = $$props2.action);
    if ("isIcon" in $$props2)
      $$invalidate(1, isIcon = $$props2.isIcon);
    if ("showRoot" in $$props2)
      $$invalidate(2, showRoot = $$props2.showRoot);
    if ("size" in $$props2)
      $$invalidate(3, size = $$props2.size);
    if ("$$scope" in $$props2)
      $$invalidate(12, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 32) {
      $$invalidate(8, _root = $node.isRoot());
    }
    if ($$self.$$.dirty & 32) {
      getChildren($node);
    }
  };
  return [
    action,
    isIcon,
    showRoot,
    size,
    node2,
    $node,
    children,
    loading2,
    _root,
    slots,
    click_handler2,
    click_handler_1,
    $$scope
  ];
}
class TreeNode extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1w, create_fragment$1D, safe_not_equal, {
      node: 4,
      action: 0,
      isIcon: 1,
      showRoot: 2,
      size: 3
    });
  }
}
function create_else_block$q(ctx) {
  let svg;
  let path;
  let mounted;
  let dispose;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "fill-rule", "evenodd");
      attr(path, "d", "M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z");
      attr(path, "clip-rule", "evenodd");
      attr(svg, "class", "tv-svg");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "viewBox", "0 0 20 20");
      attr(svg, "fill", "currentColor");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
      if (!mounted) {
        dispose = listen(svg, "click", ctx[5]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$H(ctx) {
  let svg;
  let path;
  let mounted;
  let dispose;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "fill-rule", "evenodd");
      attr(path, "d", "M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z");
      attr(path, "clip-rule", "evenodd");
      attr(svg, "class", "tv-svg");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "viewBox", "0 0 20 20");
      attr(svg, "fill", "currentColor");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
      if (!mounted) {
        dispose = listen(svg, "click", ctx[4]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$1C(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (!ctx2[1])
      return create_if_block$H;
    return create_else_block$q;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$1v($$self, $$props, $$invalidate) {
  let $node, $$unsubscribe_node = noop, $$subscribe_node = () => ($$unsubscribe_node(), $$unsubscribe_node = subscribe(node2, ($$value) => $$invalidate(3, $node = $$value)), node2);
  $$self.$$.on_destroy.push(() => $$unsubscribe_node());
  let { node: node2 } = $$props;
  $$subscribe_node();
  let expanded;
  const dispatch = createEventDispatcher();
  function click(e) {
    $$invalidate(1, expanded = !expanded);
    node2.setExpanded(expanded);
    dispatch("expanded", { expanded, node: node2 });
  }
  const click_handler2 = (e) => click();
  const click_handler_1 = (e) => click();
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$subscribe_node($$invalidate(0, node2 = $$props2.node));
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 8) {
      $$invalidate(1, expanded = $node.isExpanded());
    }
  };
  return [node2, expanded, click, $node, click_handler2, click_handler_1];
}
class Expandable extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1v, create_fragment$1C, safe_not_equal, { node: 0 });
  }
}
Object.freeze({
  none: "none",
  single: "single",
  multi: "multi"
});
const CheckState = Object.freeze({
  none: "none",
  indeterminate: "indeterminate",
  selected: "selected"
});
function create_fragment$1B(ctx) {
  let input_1;
  let mounted;
  let dispose;
  return {
    c() {
      input_1 = element("input");
      attr(input_1, "class", "");
      input_1.checked = ctx[2];
      attr(input_1, "type", "checkbox");
      attr(input_1, "tabindex", "-1");
      input_1.disabled = ctx[0];
    },
    m(target, anchor) {
      insert(target, input_1, anchor);
      ctx[5](input_1);
      if (!mounted) {
        dispose = listen(input_1, "click", ctx[3]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 4) {
        input_1.checked = ctx2[2];
      }
      if (dirty & 1) {
        input_1.disabled = ctx2[0];
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(input_1);
      ctx[5](null);
      mounted = false;
      dispose();
    }
  };
}
function instance$1u($$self, $$props, $$invalidate) {
  let checked;
  let { disabled = false } = $$props;
  let { node: node2 } = $$props;
  let input;
  const dispatch = createEventDispatcher();
  onMount(() => {
    $$invalidate(1, input.indeterminate = node2.checkState === CheckState.indeterminate, input);
  });
  function click(e) {
    $$invalidate(2, checked = !checked);
    $$invalidate(4, node2.checkState = checked ? CheckState.selected : CheckState.none, node2);
    dispatch("checked", { checked, node: node2 });
  }
  function input_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      input = $$value;
      $$invalidate(1, input), $$invalidate(4, node2);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("disabled" in $$props2)
      $$invalidate(0, disabled = $$props2.disabled);
    if ("node" in $$props2)
      $$invalidate(4, node2 = $$props2.node);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 16) {
      $$invalidate(2, checked = node2.checkState === CheckState.none ? false : true);
    }
    if ($$self.$$.dirty & 18) {
      if (input) {
        $$invalidate(1, input.indeterminate = node2.checkState === CheckState.indeterminate, input);
      }
    }
  };
  return [disabled, input, checked, click, node2, input_1_binding];
}
class Checkbox extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1u, create_fragment$1B, safe_not_equal, { disabled: 0, node: 4 });
  }
}
function classes(...classArray) {
  if (!classArray)
    return "";
  return classArray.filter((cls) => !!cls).join(" ");
}
const get_expandable_slot_changes = (dirty) => ({ node: dirty & 262144 });
const get_expandable_slot_context = (ctx) => ({ node: ctx[18] });
const get_checkbox_slot_changes = (dirty) => ({ node: dirty & 262144 });
const get_checkbox_slot_context = (ctx) => ({ node: ctx[18] });
const get_icon_slot_changes$2 = (dirty) => ({ node: dirty & 262144 });
const get_icon_slot_context$2 = (ctx) => ({ node: ctx[18] });
const get_label_slot_changes$1 = (dirty) => ({ node: dirty & 262144 });
const get_label_slot_context$1 = (ctx) => ({ node: ctx[18] });
const get_meta_slot_changes = (dirty) => ({ node: dirty & 262144 });
const get_meta_slot_context = (ctx) => ({ node: ctx[18] });
function create_if_block_2$f(ctx) {
  let current;
  const expandable_slot_template = ctx[11].expandable;
  const expandable_slot = create_slot(expandable_slot_template, ctx, ctx[12], get_expandable_slot_context);
  const expandable_slot_or_fallback = expandable_slot || fallback_block_2(ctx);
  return {
    c() {
      if (expandable_slot_or_fallback)
        expandable_slot_or_fallback.c();
    },
    m(target, anchor) {
      if (expandable_slot_or_fallback) {
        expandable_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (expandable_slot) {
        if (expandable_slot.p && (!current || dirty & 266240)) {
          update_slot_base(expandable_slot, expandable_slot_template, ctx2, ctx2[12], !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(expandable_slot_template, ctx2[12], dirty, get_expandable_slot_changes), get_expandable_slot_context);
        }
      } else {
        if (expandable_slot_or_fallback && expandable_slot_or_fallback.p && (!current || dirty & 262144)) {
          expandable_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(expandable_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(expandable_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (expandable_slot_or_fallback)
        expandable_slot_or_fallback.d(detaching);
    }
  };
}
function fallback_block_2(ctx) {
  let expandable;
  let current;
  expandable = new Expandable({ props: { node: ctx[18] } });
  expandable.$on("expanded", ctx[10]);
  return {
    c() {
      create_component(expandable.$$.fragment);
    },
    m(target, anchor) {
      mount_component(expandable, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const expandable_changes = {};
      if (dirty & 262144)
        expandable_changes.node = ctx2[18];
      expandable.$set(expandable_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(expandable.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(expandable.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(expandable, detaching);
    }
  };
}
function create_expandable_slot(ctx) {
  let div;
  let show_if = ctx[18].isExpandable();
  let current;
  let if_block = show_if && create_if_block_2$f(ctx);
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "slot", "expandable");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 262144)
        show_if = ctx2[18].isExpandable();
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 262144) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_2$f(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
    }
  };
}
function create_if_block_1$q(ctx) {
  let current;
  const checkbox_slot_template = ctx[11].checkbox;
  const checkbox_slot = create_slot(checkbox_slot_template, ctx, ctx[12], get_checkbox_slot_context);
  const checkbox_slot_or_fallback = checkbox_slot || fallback_block_1(ctx);
  return {
    c() {
      if (checkbox_slot_or_fallback)
        checkbox_slot_or_fallback.c();
    },
    m(target, anchor) {
      if (checkbox_slot_or_fallback) {
        checkbox_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (checkbox_slot) {
        if (checkbox_slot.p && (!current || dirty & 266240)) {
          update_slot_base(checkbox_slot, checkbox_slot_template, ctx2, ctx2[12], !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(checkbox_slot_template, ctx2[12], dirty, get_checkbox_slot_changes), get_checkbox_slot_context);
        }
      } else {
        if (checkbox_slot_or_fallback && checkbox_slot_or_fallback.p && (!current || dirty & 262144)) {
          checkbox_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(checkbox_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(checkbox_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (checkbox_slot_or_fallback)
        checkbox_slot_or_fallback.d(detaching);
    }
  };
}
function fallback_block_1(ctx) {
  let checkbox;
  let current;
  checkbox = new Checkbox({
    props: {
      node: ctx[18],
      disabled: ctx[18].isDisabled()
    }
  });
  checkbox.$on("checked", ctx[7]);
  return {
    c() {
      create_component(checkbox.$$.fragment);
    },
    m(target, anchor) {
      mount_component(checkbox, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const checkbox_changes = {};
      if (dirty & 262144)
        checkbox_changes.node = ctx2[18];
      if (dirty & 262144)
        checkbox_changes.disabled = ctx2[18].isDisabled();
      checkbox.$set(checkbox_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(checkbox.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(checkbox.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(checkbox, detaching);
    }
  };
}
function create_checkbox_slot(ctx) {
  let div;
  let show_if = ctx[18].isCheckable();
  let current;
  let if_block = show_if && create_if_block_1$q(ctx);
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "slot", "checkbox");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 262144)
        show_if = ctx2[18].isCheckable();
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 262144) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$q(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
    }
  };
}
function create_if_block$G(ctx) {
  let current;
  const icon_slot_template = ctx[11].icon;
  const icon_slot = create_slot(icon_slot_template, ctx, ctx[12], get_icon_slot_context$2);
  return {
    c() {
      if (icon_slot)
        icon_slot.c();
    },
    m(target, anchor) {
      if (icon_slot) {
        icon_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & 266240)) {
          update_slot_base(icon_slot, icon_slot_template, ctx2, ctx2[12], !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(icon_slot_template, ctx2[12], dirty, get_icon_slot_changes$2), get_icon_slot_context$2);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon_slot, local);
      current = true;
    },
    o(local) {
      transition_out(icon_slot, local);
      current = false;
    },
    d(detaching) {
      if (icon_slot)
        icon_slot.d(detaching);
    }
  };
}
function create_icon_slot$5(ctx) {
  let div;
  let current;
  let if_block = ctx[5] && create_if_block$G(ctx);
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "slot", "icon");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[5]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 32) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$G(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
    }
  };
}
function fallback_block$1(ctx) {
  let t_value = ctx[18].label + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 262144 && t_value !== (t_value = ctx2[18].label + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_label_slot$2(ctx) {
  let div;
  let current;
  const label_slot_template = ctx[11].label;
  const label_slot = create_slot(label_slot_template, ctx, ctx[12], get_label_slot_context$1);
  const label_slot_or_fallback = label_slot || fallback_block$1(ctx);
  return {
    c() {
      div = element("div");
      if (label_slot_or_fallback)
        label_slot_or_fallback.c();
      attr(div, "slot", "label");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (label_slot_or_fallback) {
        label_slot_or_fallback.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (label_slot) {
        if (label_slot.p && (!current || dirty & 266240)) {
          update_slot_base(label_slot, label_slot_template, ctx2, ctx2[12], !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(label_slot_template, ctx2[12], dirty, get_label_slot_changes$1), get_label_slot_context$1);
        }
      } else {
        if (label_slot_or_fallback && label_slot_or_fallback.p && (!current || dirty & 262144)) {
          label_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(label_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(label_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (label_slot_or_fallback)
        label_slot_or_fallback.d(detaching);
    }
  };
}
function create_right_content_slot(ctx) {
  let div;
  let current;
  const meta_slot_template = ctx[11].meta;
  const meta_slot = create_slot(meta_slot_template, ctx, ctx[12], get_meta_slot_context);
  return {
    c() {
      div = element("div");
      if (meta_slot)
        meta_slot.c();
      attr(div, "slot", "right-content");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (meta_slot) {
        meta_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (meta_slot) {
        if (meta_slot.p && (!current || dirty & 266240)) {
          update_slot_base(meta_slot, meta_slot_template, ctx2, ctx2[12], !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(meta_slot_template, ctx2[12], dirty, get_meta_slot_changes), get_meta_slot_context);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(meta_slot, local);
      current = true;
    },
    o(local) {
      transition_out(meta_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (meta_slot)
        meta_slot.d(detaching);
    }
  };
}
function create_fragment$1A(ctx) {
  let div;
  let treenode;
  let div_class_value;
  let current;
  let mounted;
  let dispose;
  treenode = new TreeNode({
    props: {
      node: ctx[6],
      size: ctx[4],
      isIcon: ctx[5],
      action: ctx[1],
      $$slots: {
        "right-content": [
          create_right_content_slot,
          ({ node: node2 }) => ({ 18: node2 }),
          ({ node: node2 }) => node2 ? 262144 : 0
        ],
        label: [
          create_label_slot$2,
          ({ node: node2 }) => ({ 18: node2 }),
          ({ node: node2 }) => node2 ? 262144 : 0
        ],
        icon: [
          create_icon_slot$5,
          ({ node: node2 }) => ({ 18: node2 }),
          ({ node: node2 }) => node2 ? 262144 : 0
        ],
        checkbox: [
          create_checkbox_slot,
          ({ node: node2 }) => ({ 18: node2 }),
          ({ node: node2 }) => node2 ? 262144 : 0
        ],
        expandable: [
          create_expandable_slot,
          ({ node: node2 }) => ({ 18: node2 }),
          ({ node: node2 }) => node2 ? 262144 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  treenode.$on("click", ctx[9]);
  return {
    c() {
      div = element("div");
      create_component(treenode.$$.fragment);
      attr(div, "class", div_class_value = classes(ctx[2]));
      attr(div, "showroot", ctx[3]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(treenode, div, null);
      current = true;
      if (!mounted) {
        dispose = listen(div, "keydown", ctx[8]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const treenode_changes = {};
      if (dirty & 64)
        treenode_changes.node = ctx2[6];
      if (dirty & 16)
        treenode_changes.size = ctx2[4];
      if (dirty & 32)
        treenode_changes.isIcon = ctx2[5];
      if (dirty & 2)
        treenode_changes.action = ctx2[1];
      if (dirty & 266272) {
        treenode_changes.$$scope = { dirty, ctx: ctx2 };
      }
      treenode.$set(treenode_changes);
      if (!current || dirty & 4 && div_class_value !== (div_class_value = classes(ctx2[2]))) {
        attr(div, "class", div_class_value);
      }
      if (!current || dirty & 8) {
        attr(div, "showroot", ctx2[3]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(treenode.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(treenode.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(treenode);
      mounted = false;
      dispose();
    }
  };
}
function instance$1t($$self, $$props, $$invalidate) {
  let isIcon;
  let $root, $$unsubscribe_root = noop, $$subscribe_root = () => ($$unsubscribe_root(), $$unsubscribe_root = subscribe(root, ($$value) => $$invalidate(6, $root = $$value)), root);
  $$self.$$.on_destroy.push(() => $$unsubscribe_root());
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { root } = $$props;
  $$subscribe_root();
  let { nodeAction = () => ({}) } = $$props;
  let { class: _class = "" } = $$props;
  let selectedNode = null;
  const dispatch = createEventDispatcher();
  let { showRoot = true } = $$props;
  let { size = "medium" } = $$props;
  function onChecked(e) {
    let { checked, node: node2 } = e.detail;
    if (checked) {
      node2.checkAll(CheckState.selected);
    } else {
      node2.checkAll(CheckState.none);
    }
    dispatch("check", { checked, node: node2 });
  }
  function selectNext() {
    if (!selectedNode) {
      selectedNode = root;
      selectedNode.setSelected(true);
    } else {
      selectedNode = selectedNode.selectNext();
    }
    dispatch("select", { node: selectedNode });
  }
  function selectPrevious() {
    if (!selectedNode) {
      selectedNode = root;
      selectedNode.setSelected(true);
    } else {
      selectedNode = selectedNode.selectPrevious();
    }
    dispatch("select", { node: selectedNode });
  }
  function onKeypress(e) {
    let { keyCode } = e;
    if (keyCode === 40) {
      selectNext();
    } else if (keyCode === 38) {
      selectPrevious();
    } else if (keyCode === 37) {
      if (!selectedNode)
        selectedNode = root;
      selectedNode.setExpanded(false);
      dispatch("expand", { expanded: false, node: selectedNode });
    } else if (keyCode === 39) {
      if (!selectedNode)
        selectedNode = root;
      if (selectedNode.isExpandable()) {
        selectedNode.setExpanded(true);
        dispatch("expand", { expanded: true, node: selectedNode });
      }
    } else if (keyCode === 32) {
      if (!selectedNode)
        selectedNode = node;
      onChecked({
        detail: {
          checked: selectedNode.checkState === CheckState.none,
          node: selectedNode
        }
      });
    }
  }
  function onClick(e) {
    let { node: node2 } = e.detail;
    if (!node2.isDisabled() && node2.isSelectable()) {
      if (selectedNode)
        selectedNode.setSelected(false);
      selectedNode = node2;
      node2.setSelected(true);
      dispatch("select", { node: node2 });
    }
  }
  function onExpand(e) {
    dispatch("expand", {
      expanded: e.detail.expanded,
      node: e.detail.node
    });
  }
  $$self.$$set = ($$props2) => {
    if ("root" in $$props2)
      $$subscribe_root($$invalidate(0, root = $$props2.root));
    if ("nodeAction" in $$props2)
      $$invalidate(1, nodeAction = $$props2.nodeAction);
    if ("class" in $$props2)
      $$invalidate(2, _class = $$props2.class);
    if ("showRoot" in $$props2)
      $$invalidate(3, showRoot = $$props2.showRoot);
    if ("size" in $$props2)
      $$invalidate(4, size = $$props2.size);
    if ("$$scope" in $$props2)
      $$invalidate(12, $$scope = $$props2.$$scope);
  };
  $$invalidate(5, isIcon = $$slots.icon);
  return [
    root,
    nodeAction,
    _class,
    showRoot,
    size,
    isIcon,
    $root,
    onChecked,
    onKeypress,
    onClick,
    onExpand,
    slots,
    $$scope
  ];
}
class TreeView extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1t, create_fragment$1A, safe_not_equal, {
      root: 0,
      nodeAction: 1,
      class: 2,
      showRoot: 3,
      size: 4
    });
  }
}
class BaseNode {
  constructor(id2, label, parent2 = null) {
    if (this.constructor === BaseNode) {
      throw new Error("unable to instantiate the abstract class");
    }
    this.id = id2;
    this.label = label;
    this.children = null;
    this.parent = parent2;
    this._expanded = false;
    this.selected = false;
    this.checkState = CheckState.none;
    this.listeners = [];
    this.checkable = false;
    this.disabled = false;
    this.selectable = false;
    this.loading = false;
  }
  subscribe(listener) {
    this.listeners.push(listener);
    listener(this);
    return () => {
      this.listeners.splice(this.listeners.indexOf(listener), 1);
    };
  }
  notify() {
    for (let listener of this.listeners) {
      listener(this);
    }
  }
  getId() {
    return this.id;
  }
  getLabel() {
    return this.label;
  }
  setLabel(label) {
    this.label = label;
    this.notify();
  }
  getChildCount() {
    return this.children ? this.children.length : 0;
  }
  async getChildren() {
    return this.children ? this.children : [];
  }
  setChildren(children) {
    this.children = children;
  }
  pushChild(child) {
    if (this.children !== null)
      this.children.push(child);
  }
  getParent() {
    return this.parent;
  }
  setParent(parent2) {
    this.parent = parent2;
  }
  isExpanded() {
    return this._expanded;
  }
  setExpanded(state) {
    if (this.isExpandable() && this._expanded !== state) {
      this._expanded = state;
      this.notify();
    }
    if (state && this.parent) {
      this.parent.setExpanded(true);
    }
  }
  isExpandable() {
    return this.children ? this.children.length > 0 : false;
  }
  isSelectable() {
    return this.selectable && !this.disabled;
  }
  setSelectable(selectable) {
    this.selectable = selectable;
  }
  getCheckState() {
    return this.checkState;
  }
  setCheckState(checkState) {
    this.checkState = checkState;
    this.notify();
  }
  isDisabled() {
    return this.disabled;
  }
  setDisabled(disabled) {
    this.disabled = disabled;
  }
  isCheckable() {
    return this.checkable && !this.disabled;
  }
  setCheckable(checkable) {
    this.checkable = checkable;
  }
  isLoading() {
    return this.loading;
  }
  setLoading(state) {
    this.loading = state;
    this.notify();
  }
  isRoot() {
    return !this.parent;
  }
  getRoot() {
    let node2 = this;
    let root = node2;
    while (node2.parent) {
      root = node2.parent;
      node2 = node2.parent;
    }
    return root;
  }
  checkAllChild(state) {
    this.checkState = state;
    if (!this.children) {
      return;
    }
    for (let child of this.children) {
      child.checkState = state;
      child.checkAllChild(state);
    }
  }
  checkAllParent(state) {
    if (this.parent === null)
      return;
    let siblings = this.getSiblings();
    let countOfNone = 0, partial = false;
    for (let sibling of siblings) {
      if (sibling.checkState === CheckState.none) {
        countOfNone++;
      } else if (sibling.checkState === CheckState.indeterminate) {
        partial = true;
        break;
      }
    }
    if (partial || countOfNone > 0 && countOfNone < siblings.length) {
      this.parent.checkState = CheckState.indeterminate;
    } else if (countOfNone === 0) {
      this.parent.checkState = CheckState.selected;
    } else {
      this.parent.checkState = CheckState.none;
    }
    this.parent.checkAllParent(state);
  }
  checkAll(state) {
    this.checkAllChild(state);
    this.checkAllParent(state);
    this.checkState = state;
    this.getRoot().notify();
  }
  expandedAll(state, root) {
    root._expanded = state;
    for (let child of parent.children) {
      child._expanded = state;
      this.expandedAll(state, child);
    }
    this.notify();
  }
  getSelected() {
    return this.selected;
  }
  setSelected(selected) {
    this.selected = selected;
    this.notify();
    if (selected) {
      this.setExpanded(true);
    }
  }
  getSiblings() {
    if (this.parent === null)
      return null;
    if (this.parent.getChildCount() > 0)
      return this.parent.children;
    return null;
  }
  findNextSibling() {
    let siblings = this.getSiblings();
    if (!siblings)
      return null;
    const index2 = siblings.indexOf(this);
    return siblings[index2 + 1] || this.parent.findNextSibling();
  }
  findPreviousSibling() {
    let siblings = this.getSiblings();
    if (!siblings)
      return null;
    const index2 = siblings.indexOf(this);
    return siblings[index2 - 1] || null;
  }
  findInnermostChild() {
    let childCount = this.getChildCount();
    if (childCount === 0 || (!this.isExpanded() || this.isLoading()))
      return this;
    return this.children[childCount - 1].findInnermostChild();
  }
  selectNext() {
    let next;
    if (this.isExpanded() && !this.isLoading() && this.getChildCount() > 0) {
      next = this.children[0];
    } else {
      next = this.findNextSibling();
    }
    if (next) {
      this.setSelected(false);
      if (next.isDisabled() || !next.isSelectable())
        return next.selectNext();
      next.setSelected(true);
      return next;
    } else {
      return null;
    }
  }
  selectPrevious() {
    let previous;
    let previousSibling = this.findPreviousSibling();
    if (!previousSibling)
      previous = this.parent;
    else if (previousSibling.isExpanded() && !previousSibling.isLoading()) {
      previous = previousSibling.findInnermostChild();
    } else {
      previous = previousSibling;
    }
    if (previous) {
      this.setSelected(false);
      if (previous.isDisabled() || !previous.isSelectable())
        return previous.selectPrevious();
      previous.setSelected(true);
      return previous;
    } else {
      return null;
    }
  }
  getNodeLevel() {
    if (!this.parent)
      return 0;
    return 1 + this.parent.getNodeLevel();
  }
}
const types = {
  ARRAY: "Array",
  ARRAY_OF_OBJECTS: "ArrayOfObjects",
  OBJECT: "Object",
  NUMBER: "Number",
  BOOLEAN: "Boolean",
  STRING: "String",
  NULL: "Null",
  UNDEFINED: "Undefined",
  PRIMITIVE: "Primitive"
};
function jsonType(json) {
  const type = Object.prototype.toString.call(json).slice(8, -1);
  if (type === "Object") {
    if (typeof json[Symbol.iterator] === "function") {
      return "Iterable";
    }
    return json.constructor.name;
  }
  return type;
}
function isPrimitive(value) {
  return isPrimitiveType(jsonType(value));
}
function isArrayOfPrimitives(arr) {
  if (!arr) {
    return false;
  }
  if (!Array.isArray(arr)) {
    return false;
  }
  for (let i2 = 0; i2 < arr.length; i2++) {
    if (!isPrimitive(arr[i2])) {
      return false;
    }
  }
  return true;
}
function isArrayOfObject(array) {
  for (let arr of array) {
    if (jsonType(arr) === types.OBJECT) {
      return true;
    }
  }
  return false;
}
function isPrimitiveType(type) {
  switch (type) {
    case types.NUMBER:
    case types.BOOLEAN:
    case types.STRING:
    case types.PRIMITIVE:
    case types.NULL:
    case types.UNDEFINED:
      return true;
    case types.ARRAY:
    case types.ARRAY_OF_OBJECTS:
    case types.OBJECT:
      return false;
  }
}
class DiffTreeNode extends BaseNode {
  constructor({ id: id2, label, parent: parent2 = null, type, value, oldValue = null, oldType = null, changeType, dirty = false, depth = 0 }) {
    super(id2, label, parent2);
    this.checkable = false;
    this.selectable = false;
    this.disabled = false;
    this._expanded = true;
    this.type = type;
    this.value = value;
    this.dirty = dirty;
    this.oldValue = oldValue;
    this.oldType = oldType;
    this.changeType = changeType;
    this.children = null;
    this.depth = depth;
  }
  getChildren() {
    return this.children || [];
  }
  isLeaf() {
    return this.getChildren().length === 0;
  }
  getValue() {
    switch (this.type) {
      case types.STRING:
        return this.value;
      default:
        return this.getPrettyValue();
    }
  }
  getPrettyValue(opts) {
    return this.getPretty({ value: this.value, type: this.type, ...opts });
  }
  getPrettyOldValue(opts) {
    return this.getPretty({ value: this.oldValue, type: this.oldType, ...opts });
  }
  getPretty({ value, type, trim = false }) {
    if (value === void 0) {
      return "";
    }
    if (!this.parent) {
      return this.value;
    }
    switch (type) {
      case types.STRING:
        value = firstValue(value);
        if (trim && value.length > 100) {
          return value.replace(/\s/g, " ").substring(0, 100) + `...`;
        } else {
          return value;
        }
      case types.NUMBER:
        return firstValue(value);
      case types.ARRAY:
      case types.OBJECT:
        return "";
      case types.BOOLEAN:
      default:
        return value;
    }
  }
}
const ChangeType = {
  ADDED: "added",
  DELETED: "deleted",
  VALUE_CHANGED: "value_changed"
};
function firstValue(arrayOrValue) {
  if (arrayOrValue !== 0 && !arrayOrValue) {
    return "";
  }
  if (Array.isArray(arrayOrValue) && arrayOrValue.length > 0) {
    for (let i2 = 0; i2 < arrayOrValue.length; i2++) {
      if (arrayOrValue[i2]) {
        return arrayOrValue[i2];
      }
    }
    return arrayOrValue[0];
  }
  return arrayOrValue;
}
function isArrayDiff(item) {
  return !(jsonType(item) !== types.ARRAY || !(item.length === 2 || item.length === 1 && item[0] === " ") || !(typeof item[0] === "string") || item[0].length !== 1 || ![" ", "-", "+", "~"].includes(item[0]));
}
class ComputeDiff {
  constructor() {
    this.count = 0;
    this.maxDepth = 0;
    this.additions = 0;
    this.deletions = 0;
    this.jsonDiffToNode = this.jsonDiffToNode.bind(this);
  }
  updateDiffCount(changeType) {
    switch (changeType) {
      case ChangeType.ADDED:
        this.additions++;
        break;
      case ChangeType.DELETED:
        this.deletions++;
        break;
      case ChangeType.VALUE_CHANGED:
        this.additions++;
        this.deletions++;
        break;
    }
  }
  generateTree(json, root, value) {
    const diffRoot = this.jsonDiffToNode(json, root, null, value);
    Object.assign(diffRoot, { maxDepth: this.maxDepth, additions: this.additions, deletions: this.deletions });
    return diffRoot;
  }
  jsonDiffToNode(json, label, parent2, value, changeType, depth = 0) {
    let type = jsonType(json);
    let newNode;
    let oldValue;
    let oldType;
    let change;
    let dirty = false;
    if (this.maxDepth < depth) {
      this.maxDepth = depth;
    }
    if (jsonType(label) === types.STRING) {
      if (change = label.match(/^(.*)__deleted$/)) {
        label = change[1];
        dirty = true;
        changeType = ChangeType.DELETED;
      } else if (change = label.match(/^(.*)__added$/)) {
        label = change[1];
        dirty = true;
        changeType = ChangeType.ADDED;
      }
    }
    switch (type) {
      case types.ARRAY:
        newNode = new DiffTreeNode({
          id: this.count++,
          label,
          parent: parent2,
          type,
          value,
          changeType
        });
        this.updateDiffCount(changeType);
        let looksLikeDiff = true;
        for (const item of json) {
          if (!isArrayDiff(item)) {
            looksLikeDiff = false;
          }
        }
        if (looksLikeDiff) {
          newNode.children = [];
          let add_count = 0, delete_count = 0;
          for (let index2 in json) {
            let [op, value2] = json[index2];
            if (value2 === void 0) {
              continue;
            }
            if (op === "~") {
              op = " ";
            }
            switch (op) {
              case "+":
                add_count++;
                newNode.children.push(this.jsonDiffToNode(value2, index2 - delete_count, newNode, value2, ChangeType.ADDED, depth + 1));
                break;
              case "-":
                newNode.children.push(this.jsonDiffToNode(value2, index2 - add_count, newNode, value2, ChangeType.DELETED, depth + 1));
                delete_count++;
                break;
              case " ":
              default:
                newNode.children.push(this.jsonDiffToNode(value2, index2 - delete_count, newNode, value2, void 0, depth + 1));
            }
          }
        } else {
          newNode.children = json.map((value2, index2) => this.jsonDiffToNode(value2, index2, newNode, value2, changeType, depth + 1));
        }
        break;
      case types.OBJECT:
        if ("__old" in json && "__new" in json && Object.keys(json).length === 2) {
          dirty = true;
          oldValue = json.__old;
          value = json.__new;
          oldType = jsonType(oldValue);
          type = jsonType(value);
          changeType = ChangeType.VALUE_CHANGED;
          this.updateDiffCount(changeType);
          if (!isPrimitive(oldValue) || !isPrimitive(value)) {
            newNode = new DiffTreeNode({
              id: this.count++,
              label,
              parent: parent2,
              type,
              value,
              oldValue,
              oldType,
              changeType
            });
            newNode.children = [];
            newNode.children.push(this.jsonDiffToNode(oldValue, void 0, newNode, oldValue, ChangeType.DELETED, depth + 1));
            newNode.children.push(this.jsonDiffToNode(value, void 0, newNode, value, ChangeType.ADDED, depth));
          } else {
            newNode = this.createLeafNode({ label, parent: parent2, type, value, oldValue, oldType, dirty, changeType });
          }
        } else {
          newNode = new DiffTreeNode({
            id: this.count++,
            label,
            parent: parent2,
            type,
            value,
            changeType
          });
          this.updateDiffCount(changeType);
          newNode.children = Object.keys(json).map((key) => this.jsonDiffToNode(json[key], key, newNode, json[key], changeType, depth + 1));
        }
        break;
      case types.NUMBER:
      case types.BOOLEAN:
      case types.STRING:
      case types.PRIMITIVE:
      default:
        this.updateDiffCount(changeType);
        newNode = this.createLeafNode({ label, parent: parent2, type, value, oldValue, oldType, dirty, changeType });
    }
    return newNode;
  }
  createLeafNode(data) {
    let { parent: parent2, changeType } = data;
    if (changeType) {
      let p = parent2;
      data.dirty = true;
      while (p) {
        if (p.dirty)
          break;
        p.dirty = true;
        p = p.parent;
      }
    }
    return new DiffTreeNode({
      id: this.count++,
      ...data
    });
  }
}
function pruneByChangeType(node2, changeType) {
  (function prune(node3) {
    let index2 = 0;
    let children = node3.getChildren();
    let length = children.length;
    while (index2 < length) {
      let curr = children[index2];
      if (curr.changeType === changeType) {
        children.splice(index2, 1);
        index2--;
        length--;
      } else if (curr.changeType === ChangeType.VALUE_CHANGED && curr.isLeaf()) {
        if (changeType === ChangeType.ADDED) {
          curr.value = void 0;
        } else {
          curr.oldValue = void 0;
        }
      } else {
        prune(curr);
      }
      index2++;
    }
  })(node2);
}
function removeDeletions(node2) {
  pruneByChangeType(node2, ChangeType.DELETED);
}
function removeAdditions(node2) {
  pruneByChangeType(node2, ChangeType.ADDED);
}
function generateTree(obj, options = {}) {
  let { pruneDeletions = false, pruneAdditions = false, root = "~", value } = options;
  const diff = new ComputeDiff();
  const diffNode = diff.generateTree(obj, root, value);
  if (pruneDeletions) {
    removeDeletions(diffNode);
  }
  if (pruneAdditions) {
    removeAdditions(diffNode);
  }
  return diffNode;
}
function cloneJsonDiff(root) {
  const diffClone = function clone(diffNode, parent2 = null) {
    let newNode = new DiffTreeNode(diffNode);
    newNode.parent = parent2;
    newNode.children = [];
    for (const child of diffNode.getChildren()) {
      newNode.children.push(clone(child, newNode));
    }
    return newNode;
  }(root);
  const { maxDepth, additions, deletions } = root;
  Object.assign(diffClone, { maxDepth, additions, deletions });
  return diffClone;
}
function create_else_block$p(ctx) {
  let span;
  let t0;
  let t1;
  let if_block_anchor;
  let if_block = ctx[2] && create_if_block_1$p(ctx);
  return {
    c() {
      span = element("span");
      t0 = text(ctx[0]);
      t1 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      insert(target, t1, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1)
        set_data(t0, ctx2[0]);
      if (ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1$p(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching)
        detach(span);
      if (detaching)
        detach(t1);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block$F(ctx) {
  let span;
  let t0_value = ctx[0].replace(/\s/g, " ").substring(0, ctx[1]) + "";
  let t0;
  let t1;
  let t2;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      span = element("span");
      t0 = text(t0_value);
      t1 = text("...");
      t2 = space();
      button = element("button");
      button.textContent = ">>";
      attr(button, "class", "btn btn-default btn-sm py-[2px] px-[4px] shadow-sm bg-[#eee] font-bold");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
      insert(target, t2, anchor);
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", ctx[4]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 3 && t0_value !== (t0_value = ctx2[0].replace(/\s/g, " ").substring(0, ctx2[1]) + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$p(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = "<<";
      attr(button, "class", "btn btn-default btn-sm py-[2px] px-[4px] shadow-sm bg-[#eee] font-bold");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", ctx[5]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$1z(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (ctx2[2] && !ctx2[3])
      return create_if_block$F;
    return create_else_block$p;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$1s($$self, $$props, $$invalidate) {
  let { content } = $$props;
  let { limit = 100 } = $$props;
  let limitExceeded = false;
  let showMore = false;
  const click_handler2 = () => $$invalidate(3, showMore = true);
  const click_handler_1 = () => $$invalidate(3, showMore = false);
  $$self.$$set = ($$props2) => {
    if ("content" in $$props2)
      $$invalidate(0, content = $$props2.content);
    if ("limit" in $$props2)
      $$invalidate(1, limit = $$props2.limit);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 3) {
      if (typeof content === "string") {
        $$invalidate(2, limitExceeded = content.length > limit);
      }
    }
  };
  return [content, limit, limitExceeded, showMore, click_handler2, click_handler_1];
}
class NodeValue extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1s, create_fragment$1z, safe_not_equal, { content: 0, limit: 1 });
  }
}
function create_fragment$1y(ctx) {
  let svg;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "fill", "#183a90");
      attr(path, "d", "M25.198,6.273c-0.014,0.23-0.045,0.389-0.087,0.467c-0.045,0.084-0.176,0.145-0.392,0.183 c-0.469,0.104-0.781-0.074-0.935-0.533C23.239,4.7,22.59,3.578,21.84,3.016c-1.041-0.773-2.862-1.161-5.469-1.161 c-1.054,0-1.633,0.115-1.734,0.343c-0.036,0.075-0.057,0.184-0.057,0.324v18.999c0,0.812,0.188,1.383,0.571,1.709 c0.382,0.32,1.069,0.731,2.201,0.999c0.483,0.103,0.97,0.2,1.034,0.239c0.46,0,0.504,1.057-0.376,1.057 c-0.025,0.016-10.375-0.008-10.375-0.008s-0.723-0.439-0.074-1.023c0.271-0.121,0.767-0.343,0.767-0.343s1.83-0.614,2.211-1.009 c0.434-0.445,0.648-1.164,0.648-2.154V2.521c0-0.369-0.229-0.585-0.687-0.647c-0.049-0.015-0.425-0.02-1.122-0.02 c-2.415,0-4.191,0.418-5.338,1.259C3.176,3.735,2.411,4.877,1.737,6.545C1.52,7.065,1.22,7.234,0.84,7.058 C0.408,6.957,0.251,6.719,0.363,6.353c0.445-1.374,0.668-3.31,0.668-5.814c0-0.292,0.387-0.586,1.163-0.533L23.56,0.064 c0.709-0.104,1.096,0.012,1.16,0.343C25.076,2.096,25.234,4.052,25.198,6.273z");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "width", "70%");
      attr(svg, "height", "90%");
      attr(svg, "viewBox", "0 0 25 25");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
class StringSVG extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$1y, safe_not_equal, {});
  }
}
function create_fragment$1x(ctx) {
  let svg;
  let g1;
  let g0;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      g1 = svg_element("g");
      g0 = svg_element("g");
      path = svg_element("path");
      attr(path, "fill", "#41b310");
      attr(path, "d", "M17.2881302,2.00089344 L17.3894,2.01308 C17.7964,2.09007 18.064,2.48242 17.987,2.88941 L17.987,2.88941 L17.0214,7.99404 L21.2496,7.99207 C21.6639,7.99187 21.9998,8.3275 21.9999999,8.74172 C21.9999999,9.15593 21.6646,9.49187 21.2503,9.49207 L21.2503,9.49207 L16.7376,9.49417 L15.7919,14.4939 L20.2496,14.4918 C20.6639,14.4916 20.9998,14.8273 20.9999999,15.2415 C21.0002,15.6557 20.6646,15.9916 20.2503,15.9918 L20.2503,15.9918 L15.5081,15.994 L14.4869,21.3924 C14.41,21.7994 14.0176,22.0669 13.6106,21.9899 C13.2036,21.9129 12.9361,21.5206 13.0131,21.1136 L13.0131,21.1136 L13.9814,15.9948 L8.50742,15.9973 L7.48688,21.3924 C7.4099,21.7994 7.01755,22.0669 6.61055,21.9899 C6.20356,21.9129 5.93603,21.5206 6.01302,21.1136 L6.01302,21.1136 L6.98068,15.998 L2.75035,16 C2.33614,16.0002 1.99999992,15.6646 1.99999992,15.2503 C1.99999992,14.8361 2.33544,14.5002 2.74965,14.5 L2.74965,14.5 L7.26445,14.4979 L8.2102,9.49816 L3.75035,9.50024 C3.33614,9.50044 3.00019,9.16481 2.99999992,8.75059 C2.99981,8.33638 3.33544,8.00044 3.74965,8.00024 L3.74965,8.00024 L8.49396,7.99803 L9.51305,2.61062 C9.59003,2.20362 9.98238,1.9361 10.3894,2.01308 C10.7964,2.09007 11.0639,2.48242 10.9869,2.88941 L10.9869,2.88941 L10.0207,7.99731 L15.4946,7.99476 L16.5131,2.61062 C16.5901,2.20362 16.9824,1.9361 17.3894,2.01308 Z M15.2109,9.49489 L9.73693,9.49745 L8.79118,14.4972 L14.2651,14.4946 L15.2109,9.49489 Z");
      attr(g0, "id", "ic_fluent_number_symbol_24_regular");
      attr(g0, "fill", "#212121");
      attr(g0, "fill-rule", "nonzero");
      attr(g1, "stroke", "none");
      attr(g1, "stroke-width", "1");
      attr(g1, "fill", "none");
      attr(g1, "fill-rule", "evenodd");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, g1);
      append(g1, g0);
      append(g0, path);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
class NumberSVG extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$1x, safe_not_equal, {});
  }
}
function create_fragment$1w(ctx) {
  let svg;
  let g;
  let path0;
  let path1;
  return {
    c() {
      svg = svg_element("svg");
      g = svg_element("g");
      path0 = svg_element("path");
      path1 = svg_element("path");
      attr(path0, "fill", "none");
      attr(path0, "d", "M0 0h24v24H0z");
      attr(path1, "fill", "#0cc8d2");
      attr(path1, "d", "M9 3v2H6v14h3v2H4V3h5zm6 0h5v18h-5v-2h3V5h-3V3z");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, g);
      append(g, path0);
      append(g, path1);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
class ArraySVG extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$1w, safe_not_equal, {});
  }
}
function create_fragment$1v(ctx) {
  let svg;
  let g;
  let t;
  let path0;
  let path1;
  return {
    c() {
      svg = svg_element("svg");
      g = svg_element("g");
      t = text("null\n    ");
      path0 = svg_element("path");
      path1 = svg_element("path");
      attr(path0, "fill", "none");
      attr(path0, "d", "M0 0h24v24H0z");
      attr(path1, "fill", "#bf3126");
      attr(path1, "d", "M4 18v-3.7a1.5 1.5 0 0 0-1.5-1.5H2v-1.6h.5A1.5 1.5 0 0 0 4 9.7V6a3 3 0 0 1 3-3h1v2H7a1 1 0 0 0-1 1v4.1A2 2 0 0 1 4.626 12 2 2 0 0 1 6 13.9V18a1 1 0 0 0 1 1h1v2H7a3 3 0 0 1-3-3zm16-3.7V18a3 3 0 0 1-3 3h-1v-2h1a1 1 0 0 0 1-1v-4.1a2 2 0 0 1 1.374-1.9A2 2 0 0 1 18 10.1V6a1 1 0 0 0-1-1h-1V3h1a3 3 0 0 1 3 3v3.7a1.5 1.5 0 0 0 1.5 1.5h.5v1.6h-.5a1.5 1.5 0 0 0-1.5 1.5z");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, g);
      append(g, t);
      append(g, path0);
      append(g, path1);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
class ObjectSVG extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$1v, safe_not_equal, {});
  }
}
function create_fragment$1u(ctx) {
  let svg;
  let defs2;
  let style;
  let t;
  let path;
  let circle;
  let rect;
  return {
    c() {
      svg = svg_element("svg");
      defs2 = svg_element("defs");
      style = svg_element("style");
      t = text(".cls-1{fill:none}");
      path = svg_element("path");
      circle = svg_element("circle");
      rect = svg_element("rect");
      attr(path, "fill", "#ec8f0c");
      attr(path, "d", "M23,23a7,7,0,1,1,7-7A7.0078,7.0078,0,0,1,23,23Zm0-12a5,5,0,1,0,5,5A5.0055,5.0055,0,0,0,23,11Z");
      attr(circle, "fill", "#ec8f0c");
      attr(circle, "cx", "9");
      attr(circle, "cy", "16");
      attr(circle, "r", "7");
      attr(rect, "id", "_Transparent_Rectangle_");
      attr(rect, "data-name", "<Transparent Rectangle>");
      attr(rect, "class", "cls-1");
      attr(rect, "width", "32");
      attr(rect, "height", "32");
      attr(svg, "viewBox", "0 0 32 32");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "width", "120%");
      attr(svg, "height", "120%");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, defs2);
      append(defs2, style);
      append(style, t);
      append(svg, path);
      append(svg, circle);
      append(svg, rect);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
class BooleanSVG extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$1u, safe_not_equal, {});
  }
}
function create_else_block$o(ctx) {
  let objectsvg;
  let current;
  objectsvg = new ObjectSVG({});
  return {
    c() {
      create_component(objectsvg.$$.fragment);
    },
    m(target, anchor) {
      mount_component(objectsvg, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(objectsvg.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(objectsvg.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(objectsvg, detaching);
    }
  };
}
function create_if_block_3$a(ctx) {
  let arraytypesvg;
  let current;
  arraytypesvg = new ArraySVG({});
  return {
    c() {
      create_component(arraytypesvg.$$.fragment);
    },
    m(target, anchor) {
      mount_component(arraytypesvg, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(arraytypesvg.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(arraytypesvg.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(arraytypesvg, detaching);
    }
  };
}
function create_if_block_2$e(ctx) {
  let booleantypesvg;
  let current;
  booleantypesvg = new BooleanSVG({});
  return {
    c() {
      create_component(booleantypesvg.$$.fragment);
    },
    m(target, anchor) {
      mount_component(booleantypesvg, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(booleantypesvg.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(booleantypesvg.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(booleantypesvg, detaching);
    }
  };
}
function create_if_block_1$o(ctx) {
  let numbertypesvg;
  let current;
  numbertypesvg = new NumberSVG({});
  return {
    c() {
      create_component(numbertypesvg.$$.fragment);
    },
    m(target, anchor) {
      mount_component(numbertypesvg, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(numbertypesvg.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(numbertypesvg.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(numbertypesvg, detaching);
    }
  };
}
function create_if_block$E(ctx) {
  let stringtypesvg;
  let current;
  stringtypesvg = new StringSVG({});
  return {
    c() {
      create_component(stringtypesvg.$$.fragment);
    },
    m(target, anchor) {
      mount_component(stringtypesvg, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(stringtypesvg.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(stringtypesvg.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(stringtypesvg, detaching);
    }
  };
}
function create_fragment$1t(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [
    create_if_block$E,
    create_if_block_1$o,
    create_if_block_2$e,
    create_if_block_3$a,
    create_else_block$o
  ];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0] === types.STRING)
      return 0;
    if (ctx2[0] === types.NUMBER)
      return 1;
    if (ctx2[0] === types.BOOLEAN)
      return 2;
    if (ctx2[0] === types.ARRAY || ctx2[0] === types.ARRAY_OF_OBJECTS)
      return 3;
    return 4;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$1r($$self, $$props, $$invalidate) {
  let { type } = $$props;
  $$self.$$set = ($$props2) => {
    if ("type" in $$props2)
      $$invalidate(0, type = $$props2.type);
  };
  return [type];
}
class TypeSVG extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1r, create_fragment$1t, safe_not_equal, { type: 0 });
  }
}
function create_fragment$1s(ctx) {
  let svg;
  let rect;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      rect = svg_element("rect");
      path = svg_element("path");
      attr(rect, "fill", "white");
      attr(rect, "fill-opacity", "0.01");
      attr(path, "d", "M24 33C28.9706 33 33 28.9706 33 24C33 19.0294 28.9706 15 24 15C19.0294 15 15 19.0294 15 24C15 28.9706 19.0294 33 24 33Z");
      attr(path, "fill", "blue");
      attr(path, "stroke", "blue");
      attr(path, "stroke-width", "4");
      attr(svg, "viewBox", "0 0 64 64");
      attr(svg, "fill", "none");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, rect);
      append(svg, path);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
class DirtySVG extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$1s, safe_not_equal, {});
  }
}
let diffWorker;
let diffPromises = {};
function diffHtml(oldHtml, newHtml, context) {
  const data = { oldHtml: oldHtml || "<html></html>", newHtml: newHtml || "<html></html>", context };
  if (typeof Worker !== "undefined") {
    const isLocal = Supports.agents.local;
    const prefix = isLocal ? "/ui" : "";
    if (!diffWorker) {
      diffWorker = new Worker(prefix + "/lib/diff_html.js");
      diffWorker.addEventListener("message", function(event) {
        const { context: resCtx, diff, error } = event.data;
        if (diffPromises[resCtx]) {
          if (error) {
            diffPromises[resCtx].reject(Object.assign(new Error(), error));
            return;
          }
          diffPromises[resCtx].resolve({ diff, additions: getInsertCount(diff), deletions: getRemoveCount(diff) });
        } else {
          console.warn(`Resolve for ${resCtx} not found`);
        }
      });
    }
    diffWorker.postMessage(data);
    return new Promise((resolve, reject) => {
      diffPromises[context] = { resolve, reject };
    });
  } else {
    document.getElementById("result").innerHTML = "Sorry, your browser does not support Web Workers...";
  }
}
function getInsertCount(html2) {
  return getCount(html2, "inserted");
}
function getRemoveCount(html2) {
  return getCount(html2, "removed");
}
function getCount(diff, cls) {
  const pattern = new RegExp(`class="diffMark ${cls}`, "g");
  let count2 = (diff.match(pattern) || []).length;
  return count2;
}
let jsonDiff;
async function diffJson(oldJson, newJson, options = {}) {
  const { full = true } = options;
  if (!jsonDiff) {
    ({ jsonDiff } = await __vitePreload(() => import("./json-diff.min.648166e2.js"), true ? [] : void 0));
  }
  let diff = jsonDiff.diff(oldJson, newJson, { full });
  let diffNode;
  if (diff) {
    diffNode = generateTree(diff);
  } else {
    diffNode = generateTree(oldJson);
  }
  return diffNode;
}
const Diff = {
  diffHtml,
  diffJson
};
var JSONDiffView_svelte_svelte_type_style_lang = "";
function create_catch_block$9(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$9(ctx) {
  let div1;
  let div0;
  let treeview;
  let div1_class_value;
  let current;
  treeview = new TreeView({
    props: {
      root: ctx[0],
      size: "medium",
      class: " bg-white bb bl br bt border-bootstrap-border " + ctx[6],
      nodeAction: ctx[9],
      $$slots: {
        meta: [
          create_meta_slot$1,
          ({ node: node2 }) => ({ 32: node2 }),
          ({ node: node2 }) => [0, node2 ? 2 : 0]
        ],
        icon: [
          create_icon_slot$4,
          ({ node: node2 }) => ({ 32: node2 }),
          ({ node: node2 }) => [0, node2 ? 2 : 0]
        ],
        label: [
          create_label_slot$1,
          ({ node: node2 }) => ({ 32: node2 }),
          ({ node: node2 }) => [0, node2 ? 2 : 0]
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      create_component(treeview.$$.fragment);
      attr(div0, "class", "w-full h-full");
      attr(div1, "class", div1_class_value = null_to_empty(ctx[7]) + " svelte-hoe3nl");
      set_style(div1, "--max-depth", ctx[8]());
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      mount_component(treeview, div0, null);
      current = true;
    },
    p(ctx2, dirty) {
      const treeview_changes = {};
      if (dirty[0] & 1)
        treeview_changes.root = ctx2[0];
      if (dirty[0] & 64)
        treeview_changes.class = " bg-white bb bl br bt border-bootstrap-border " + ctx2[6];
      if (dirty[0] & 60 | dirty[1] & 6) {
        treeview_changes.$$scope = { dirty, ctx: ctx2 };
      }
      treeview.$set(treeview_changes);
      if (!current || dirty[0] & 128 && div1_class_value !== (div1_class_value = null_to_empty(ctx2[7]) + " svelte-hoe3nl")) {
        attr(div1, "class", div1_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(treeview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(treeview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(treeview);
    }
  };
}
function create_label_slot$1(ctx) {
  let div;
  let t_value = (ctx[32].label !== void 0 ? ctx[32].label : "") + "";
  let t;
  return {
    c() {
      div = element("div");
      t = text(t_value);
      attr(div, "slot", "label");
      attr(div, "class", "xbreak-long-words xpadding svelte-hoe3nl");
      toggle_class(div, "inserted", ctx[32].changeType === ChangeType.ADDED && ctx[32].label !== void 0);
      toggle_class(div, "removed", ctx[32].changeType === ChangeType.DELETED && ctx[32].label !== void 0);
      toggle_class(div, "xdiff", ctx[32].changeType);
      toggle_class(div, "opacity-0", ctx[32].changeType === ChangeType.ADDED && ctx[4] || ctx[32].changeType === ChangeType.DELETED && ctx[3]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty[1] & 2 && t_value !== (t_value = (ctx2[32].label !== void 0 ? ctx2[32].label : "") + ""))
        set_data(t, t_value);
      if (dirty[1] & 2) {
        toggle_class(div, "inserted", ctx2[32].changeType === ChangeType.ADDED && ctx2[32].label !== void 0);
      }
      if (dirty[1] & 2) {
        toggle_class(div, "removed", ctx2[32].changeType === ChangeType.DELETED && ctx2[32].label !== void 0);
      }
      if (dirty[1] & 2) {
        toggle_class(div, "xdiff", ctx2[32].changeType);
      }
      if (dirty[0] & 24 | dirty[1] & 2) {
        toggle_class(div, "opacity-0", ctx2[32].changeType === ChangeType.ADDED && ctx2[4] || ctx2[32].changeType === ChangeType.DELETED && ctx2[3]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_2$d(ctx) {
  let div;
  let current;
  let if_block = ctx[32].dirty && create_if_block_3$9();
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "class", "xdirty svelte-hoe3nl");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[32].dirty) {
        if (if_block) {
          if (dirty[1] & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_3$9();
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
    }
  };
}
function create_if_block_3$9(ctx) {
  let dirtysvg;
  let current;
  dirtysvg = new DirtySVG({});
  return {
    c() {
      create_component(dirtysvg.$$.fragment);
    },
    m(target, anchor) {
      mount_component(dirtysvg, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(dirtysvg.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dirtysvg.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dirtysvg, detaching);
    }
  };
}
function create_icon_slot$4(ctx) {
  let div1;
  let t;
  let div0;
  let typesvg;
  let div0_title_value;
  let current;
  let if_block = ctx[5] && ctx[2] && create_if_block_2$d(ctx);
  typesvg = new TypeSVG({ props: { type: ctx[32].type } });
  return {
    c() {
      div1 = element("div");
      if (if_block)
        if_block.c();
      t = space();
      div0 = element("div");
      create_component(typesvg.$$.fragment);
      attr(div0, "class", "tv-svg");
      attr(div0, "title", div0_title_value = ctx[32].type);
      attr(div1, "slot", "icon");
      attr(div1, "class", "tv-flex tv-svg-parent");
      toggle_class(div1, "opacity-0", ctx[32].changeType === ChangeType.ADDED && ctx[4] || ctx[32].changeType === ChangeType.DELETED && ctx[3]);
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      if (if_block)
        if_block.m(div1, null);
      append(div1, t);
      append(div1, div0);
      mount_component(typesvg, div0, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[5] && ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & 36) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_2$d(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div1, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      const typesvg_changes = {};
      if (dirty[1] & 2)
        typesvg_changes.type = ctx2[32].type;
      typesvg.$set(typesvg_changes);
      if (!current || dirty[1] & 2 && div0_title_value !== (div0_title_value = ctx2[32].type)) {
        attr(div0, "title", div0_title_value);
      }
      if (dirty[0] & 24 | dirty[1] & 2) {
        toggle_class(div1, "opacity-0", ctx2[32].changeType === ChangeType.ADDED && ctx2[4] || ctx2[32].changeType === ChangeType.DELETED && ctx2[3]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(typesvg.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(typesvg.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (if_block)
        if_block.d();
      destroy_component(typesvg);
    }
  };
}
function create_if_block_1$n(ctx) {
  let div;
  let nodevalue;
  let current;
  nodevalue = new NodeValue({
    props: {
      content: ctx[32].getPrettyOldValue()
    }
  });
  return {
    c() {
      div = element("div");
      create_component(nodevalue.$$.fragment);
      attr(div, "class", "xbreak-long-words removed flex-grow xpadding svelte-hoe3nl");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(nodevalue, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const nodevalue_changes = {};
      if (dirty[1] & 2)
        nodevalue_changes.content = ctx2[32].getPrettyOldValue();
      nodevalue.$set(nodevalue_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(nodevalue.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(nodevalue.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(nodevalue);
    }
  };
}
function create_if_block$D(ctx) {
  let div;
  let nodevalue;
  let current;
  nodevalue = new NodeValue({
    props: {
      content: ctx[32].getPrettyValue()
    }
  });
  return {
    c() {
      div = element("div");
      create_component(nodevalue.$$.fragment);
      attr(div, "class", "xbreak-long-words flex-grow xpadding svelte-hoe3nl");
      toggle_class(div, "inserted", (ctx[32].changeType === ChangeType.ADDED || ctx[32].changeType === ChangeType.VALUE_CHANGED) && ctx[32].isLeaf() && ctx[32].value !== void 0);
      toggle_class(div, "removed", ctx[32].changeType === ChangeType.DELETED && ctx[32].isLeaf());
      toggle_class(div, "opacity-0", ctx[32].changeType && ctx[32].changeType === ChangeType.ADDED && ctx[4] || ctx[32].changeType === ChangeType.DELETED && ctx[3]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(nodevalue, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const nodevalue_changes = {};
      if (dirty[1] & 2)
        nodevalue_changes.content = ctx2[32].getPrettyValue();
      nodevalue.$set(nodevalue_changes);
      if (dirty[1] & 2) {
        toggle_class(div, "inserted", (ctx2[32].changeType === ChangeType.ADDED || ctx2[32].changeType === ChangeType.VALUE_CHANGED) && ctx2[32].isLeaf() && ctx2[32].value !== void 0);
      }
      if (dirty[1] & 2) {
        toggle_class(div, "removed", ctx2[32].changeType === ChangeType.DELETED && ctx2[32].isLeaf());
      }
      if (dirty[0] & 24 | dirty[1] & 2) {
        toggle_class(div, "opacity-0", ctx2[32].changeType && ctx2[32].changeType === ChangeType.ADDED && ctx2[4] || ctx2[32].changeType === ChangeType.DELETED && ctx2[3]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(nodevalue.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(nodevalue.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(nodevalue);
    }
  };
}
function create_meta_slot$1(ctx) {
  let div;
  let show_if = ctx[32].changeType === ChangeType.VALUE_CHANGED && ctx[32].isLeaf() && ctx[32].oldValue !== void 0 && !ctx[3];
  let t;
  let div_title_value;
  let current;
  let if_block0 = show_if && create_if_block_1$n(ctx);
  let if_block1 = !(ctx[32].changeType === ChangeType.VALUE_CHANGED && ctx[4]) && create_if_block$D(ctx);
  return {
    c() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      attr(div, "slot", "meta");
      attr(div, "title", div_title_value = ctx[32].getValue());
      attr(div, "class", "flex gap-2 xl:flex-1");
      toggle_class(div, "xdiffMeta", ctx[32].changeType === ChangeType.VALUE_CHANGED && ctx[32].oldValue !== void 0 && ctx[32].value !== void 0);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append(div, t);
      if (if_block1)
        if_block1.m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & 8 | dirty[1] & 2)
        show_if = ctx2[32].changeType === ChangeType.VALUE_CHANGED && ctx2[32].isLeaf() && ctx2[32].oldValue !== void 0 && !ctx2[3];
      if (show_if) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & 8 | dirty[1] & 2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1$n(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!(ctx2[32].changeType === ChangeType.VALUE_CHANGED && ctx2[4])) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 16 | dirty[1] & 2) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$D(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty[1] & 2 && div_title_value !== (div_title_value = ctx2[32].getValue())) {
        attr(div, "title", div_title_value);
      }
      if (dirty[1] & 2) {
        toggle_class(div, "xdiffMeta", ctx2[32].changeType === ChangeType.VALUE_CHANGED && ctx2[32].oldValue !== void 0 && ctx2[32].value !== void 0);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
}
function create_pending_block$9(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_fragment$1r(ctx) {
  let await_block_anchor;
  let promise;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$9,
    then: create_then_block$9,
    catch: create_catch_block$9,
    value: 31,
    blocks: [, , ,]
  };
  handle_promise(promise = ctx[1], info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      info.ctx = ctx;
      if (dirty[0] & 2 && promise !== (promise = ctx[1]) && handle_promise(promise, info))
        ;
      else {
        update_await_block_branch(info, ctx, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function instance$1q($$self, $$props, $$invalidate) {
  let { oldJson } = $$props;
  let { newJson } = $$props;
  let { diff } = $$props;
  let { jsonDiffPromise } = $$props;
  let { full = true } = $$props;
  let { pruneDeletions = false } = $$props;
  let { pruneAdditions = false } = $$props;
  let { additions = 0 } = $$props;
  let { deletions = 0 } = $$props;
  let { hideDeletions = false } = $$props;
  let { hideAdditions = false } = $$props;
  let { showDirty = false } = $$props;
  let { treeViewClass = "" } = $$props;
  let { scrollToFirstDiff = false } = $$props;
  let { computeDiff = true } = $$props;
  let { diffNavigation = false } = $$props;
  const goToNextDiff = () => goToDiff(STEP.NEXT);
  const goToPrevDiff = () => goToDiff(STEP.PREV);
  let { class: classes2 = "" } = $$props;
  let maxDepth;
  let diffs = { nodes: [], curr: null };
  let init2 = !computeDiff;
  let currDiff;
  const STEP = { NEXT: 1, PREV: -1 };
  async function getDiff(oldJson2, newJson2, options = {}) {
    init2 = false;
    const { full: full2 } = options;
    $$invalidate(0, diff = await Diff.diffJson(oldJson2, newJson2, { full: full2 }));
    $$invalidate(10, { maxDepth, additions, deletions } = diff, additions, $$invalidate(11, deletions));
    init2 = true;
  }
  function getDiffNodes2() {
    let nodes = [];
    (function getNodes(node2) {
      if (node2.changeType) {
        nodes.push(node2);
      }
      node2.getChildren().forEach((child) => getNodes(child));
    })(diff);
    diffs.nodes = nodes;
    diffs.curr = null;
  }
  function goToDiff(step) {
    var _a;
    let { nodes, curr } = diffs;
    const length = nodes.length;
    if (length === 0 || length === 1 && nodes[0].getSelected()) {
      return;
    }
    if (curr === null) {
      if (step === STEP.NEXT) {
        curr = -1;
      } else {
        curr = length;
      }
    }
    let next = curr + step;
    if (next < 0) {
      next = length - 1;
    } else if (next >= length) {
      next = 0;
    }
    (_a = nodes[curr]) == null ? void 0 : _a.setSelected(false);
    nodes[next].setSelected(true);
    diffs.curr = next;
  }
  function goToFirstDiff() {
    const firstDiffNode = diffs.nodes[0];
    if (firstDiffNode) {
      diffs.curr = 0;
      firstDiffNode.setSelected(true);
    }
  }
  async function processDiff() {
    $$invalidate(21, currDiff = diff);
    if (!computeDiff) {
      let diffClone = cloneJsonDiff(diff);
      $$invalidate(10, { maxDepth, additions, deletions } = diffClone, additions, $$invalidate(11, deletions));
      $$invalidate(0, diff = diffClone);
      $$invalidate(21, currDiff = diff);
    }
    if (pruneAdditions && init2) {
      removeAdditions(diff);
    }
    if (pruneDeletions && init2) {
      removeDeletions(diff);
    }
    if (diffNavigation) {
      getDiffNodes2();
      if (scrollToFirstDiff) {
        await tick();
        goToFirstDiff();
      }
    }
  }
  function getDepth() {
    let minWidth = 30, upper_bound = 40;
    let depth = minWidth + 2 * maxDepth;
    return `${depth > upper_bound ? upper_bound : depth}%`;
  }
  const actionFn = (elRef, node2) => {
    return {
      update: (node3) => {
        if (node3.getSelected()) {
          elRef.scrollIntoView({ behaviour: "smooth", block: "center" });
        }
      }
    };
  };
  $$self.$$set = ($$props2) => {
    if ("oldJson" in $$props2)
      $$invalidate(12, oldJson = $$props2.oldJson);
    if ("newJson" in $$props2)
      $$invalidate(13, newJson = $$props2.newJson);
    if ("diff" in $$props2)
      $$invalidate(0, diff = $$props2.diff);
    if ("jsonDiffPromise" in $$props2)
      $$invalidate(1, jsonDiffPromise = $$props2.jsonDiffPromise);
    if ("full" in $$props2)
      $$invalidate(2, full = $$props2.full);
    if ("pruneDeletions" in $$props2)
      $$invalidate(14, pruneDeletions = $$props2.pruneDeletions);
    if ("pruneAdditions" in $$props2)
      $$invalidate(15, pruneAdditions = $$props2.pruneAdditions);
    if ("additions" in $$props2)
      $$invalidate(10, additions = $$props2.additions);
    if ("deletions" in $$props2)
      $$invalidate(11, deletions = $$props2.deletions);
    if ("hideDeletions" in $$props2)
      $$invalidate(3, hideDeletions = $$props2.hideDeletions);
    if ("hideAdditions" in $$props2)
      $$invalidate(4, hideAdditions = $$props2.hideAdditions);
    if ("showDirty" in $$props2)
      $$invalidate(5, showDirty = $$props2.showDirty);
    if ("treeViewClass" in $$props2)
      $$invalidate(6, treeViewClass = $$props2.treeViewClass);
    if ("scrollToFirstDiff" in $$props2)
      $$invalidate(16, scrollToFirstDiff = $$props2.scrollToFirstDiff);
    if ("computeDiff" in $$props2)
      $$invalidate(17, computeDiff = $$props2.computeDiff);
    if ("diffNavigation" in $$props2)
      $$invalidate(18, diffNavigation = $$props2.diffNavigation);
    if ("class" in $$props2)
      $$invalidate(7, classes2 = $$props2.class);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 159748) {
      computeDiff && $$invalidate(1, jsonDiffPromise = getDiff(oldJson, newJson, { full }));
    }
    if ($$self.$$.dirty[0] & 2097153) {
      if (diff !== currDiff) {
        processDiff();
      }
    }
  };
  return [
    diff,
    jsonDiffPromise,
    full,
    hideDeletions,
    hideAdditions,
    showDirty,
    treeViewClass,
    classes2,
    getDepth,
    actionFn,
    additions,
    deletions,
    oldJson,
    newJson,
    pruneDeletions,
    pruneAdditions,
    scrollToFirstDiff,
    computeDiff,
    diffNavigation,
    goToNextDiff,
    goToPrevDiff,
    currDiff
  ];
}
class JSONDiffView extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1q, create_fragment$1r, safe_not_equal, {
      oldJson: 12,
      newJson: 13,
      diff: 0,
      jsonDiffPromise: 1,
      full: 2,
      pruneDeletions: 14,
      pruneAdditions: 15,
      additions: 10,
      deletions: 11,
      hideDeletions: 3,
      hideAdditions: 4,
      showDirty: 5,
      treeViewClass: 6,
      scrollToFirstDiff: 16,
      computeDiff: 17,
      diffNavigation: 18,
      goToNextDiff: 19,
      goToPrevDiff: 20,
      class: 7
    }, null, [-1, -1]);
  }
  get oldJson() {
    return this.$$.ctx[12];
  }
  set oldJson(oldJson) {
    this.$$set({ oldJson });
    flush();
  }
  get newJson() {
    return this.$$.ctx[13];
  }
  set newJson(newJson) {
    this.$$set({ newJson });
    flush();
  }
  get diff() {
    return this.$$.ctx[0];
  }
  set diff(diff) {
    this.$$set({ diff });
    flush();
  }
  get jsonDiffPromise() {
    return this.$$.ctx[1];
  }
  set jsonDiffPromise(jsonDiffPromise) {
    this.$$set({ jsonDiffPromise });
    flush();
  }
  get full() {
    return this.$$.ctx[2];
  }
  set full(full) {
    this.$$set({ full });
    flush();
  }
  get pruneDeletions() {
    return this.$$.ctx[14];
  }
  set pruneDeletions(pruneDeletions) {
    this.$$set({ pruneDeletions });
    flush();
  }
  get pruneAdditions() {
    return this.$$.ctx[15];
  }
  set pruneAdditions(pruneAdditions) {
    this.$$set({ pruneAdditions });
    flush();
  }
  get additions() {
    return this.$$.ctx[10];
  }
  set additions(additions) {
    this.$$set({ additions });
    flush();
  }
  get deletions() {
    return this.$$.ctx[11];
  }
  set deletions(deletions) {
    this.$$set({ deletions });
    flush();
  }
  get hideDeletions() {
    return this.$$.ctx[3];
  }
  set hideDeletions(hideDeletions) {
    this.$$set({ hideDeletions });
    flush();
  }
  get hideAdditions() {
    return this.$$.ctx[4];
  }
  set hideAdditions(hideAdditions) {
    this.$$set({ hideAdditions });
    flush();
  }
  get showDirty() {
    return this.$$.ctx[5];
  }
  set showDirty(showDirty) {
    this.$$set({ showDirty });
    flush();
  }
  get treeViewClass() {
    return this.$$.ctx[6];
  }
  set treeViewClass(treeViewClass) {
    this.$$set({ treeViewClass });
    flush();
  }
  get scrollToFirstDiff() {
    return this.$$.ctx[16];
  }
  set scrollToFirstDiff(scrollToFirstDiff) {
    this.$$set({ scrollToFirstDiff });
    flush();
  }
  get computeDiff() {
    return this.$$.ctx[17];
  }
  set computeDiff(computeDiff) {
    this.$$set({ computeDiff });
    flush();
  }
  get diffNavigation() {
    return this.$$.ctx[18];
  }
  set diffNavigation(diffNavigation) {
    this.$$set({ diffNavigation });
    flush();
  }
  get goToNextDiff() {
    return this.$$.ctx[19];
  }
  get goToPrevDiff() {
    return this.$$.ctx[20];
  }
  get class() {
    return this.$$.ctx[7];
  }
  set class(classes2) {
    this.$$set({ class: classes2 });
    flush();
  }
}
function get_each_context$m(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i2];
  return child_ctx;
}
function create_each_block$m(ctx) {
  let option;
  let t_value = new Date(ctx[8].ts_mod).toLocaleString() + "";
  let t;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = option_value_value = ctx[8].id;
      option.value = option.__value;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t_value !== (t_value = new Date(ctx2[8].ts_mod).toLocaleString() + ""))
        set_data(t, t_value);
      if (dirty & 2 && option_value_value !== (option_value_value = ctx2[8].id)) {
        option.__value = option_value_value;
        option.value = option.__value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_fragment$1q(ctx) {
  let div;
  let select;
  let select_class_value;
  let mounted;
  let dispose;
  let each_value = ctx[1];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$m(get_each_context$m(ctx, each_value, i2));
  }
  return {
    c() {
      div = element("div");
      select = element("select");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(select, "class", select_class_value = "form-control " + ctx[2]);
      attr(select, "title", ctx[3]);
      if (ctx[0] === void 0)
        add_render_callback(() => ctx[6].call(select));
      attr(div, "class", ctx[4]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, select);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(select, null);
      }
      select_option(select, ctx[0]);
      if (!mounted) {
        dispose = [
          listen(select, "change", ctx[6]),
          listen(select, "change", ctx[7])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 2) {
        each_value = ctx2[1];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$m(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$m(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(select, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & 4 && select_class_value !== (select_class_value = "form-control " + ctx2[2])) {
        attr(select, "class", select_class_value);
      }
      if (dirty & 8) {
        attr(select, "title", ctx2[3]);
      }
      if (dirty & 3) {
        select_option(select, ctx2[0]);
      }
      if (dirty & 16) {
        attr(div, "class", ctx2[4]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$1p($$self, $$props, $$invalidate) {
  const dispatch = createEventDispatcher();
  let { timestamps } = $$props;
  let { value } = $$props;
  let { selectClass = "" } = $$props;
  let { title } = $$props;
  let { class: classes2 = "" } = $$props;
  function select_change_handler() {
    value = select_value(this);
    $$invalidate(0, value);
    $$invalidate(1, timestamps);
  }
  const change_handler = (e) => dispatch("change", { value: e.target.value });
  $$self.$$set = ($$props2) => {
    if ("timestamps" in $$props2)
      $$invalidate(1, timestamps = $$props2.timestamps);
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("selectClass" in $$props2)
      $$invalidate(2, selectClass = $$props2.selectClass);
    if ("title" in $$props2)
      $$invalidate(3, title = $$props2.title);
    if ("class" in $$props2)
      $$invalidate(4, classes2 = $$props2.class);
  };
  return [
    value,
    timestamps,
    selectClass,
    title,
    classes2,
    dispatch,
    select_change_handler,
    change_handler
  ];
}
class DateSelect extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1p, create_fragment$1q, safe_not_equal, {
      timestamps: 1,
      value: 0,
      selectClass: 2,
      title: 3,
      class: 4
    });
  }
}
function initStore() {
  const { subscribe: subscribe2, set, update } = writable({ sieve_data: null, data1: null, data2: null, diff: null, additions: 0, deletions: 0, type: null, uri: null });
  store = {
    subscribe: subscribe2,
    set,
    fetchSieveData: async function(sieve_id, curr_id) {
      try {
        const { data } = await Api.api(`/sieves/${sieve_id}/data`, "GET");
        let index2 = data.findIndex((dat) => dat.id === curr_id);
        if (index2 === -1) {
          throw new Error("Unable to find sieve");
        }
        await this.init({ sieve_data: data, data1: data[index2 + 1], data2: data[index2] });
      } catch (e) {
        console.error(`Error while fetching sieve data for the sieve:${sieve_id} `, e);
      }
    },
    init: async function(data) {
      this.updateStore(data);
      await this.updateDiff(data);
    },
    updateData1ById: function(id2) {
      const currStore = get_store_value(this);
      const data1 = currStore.sieve_data.find((data) => data.id === id2);
      this.updateDiff({ data1, data2: currStore.data2 });
    },
    updateData2ById: function(id2) {
      const currStore = get_store_value(this);
      const data2 = currStore.sieve_data.find((data) => data.id === id2);
      this.updateDiff({ data1: currStore.data1, data2 });
    },
    updateDiff: async function({ data1, data2 }) {
      let diffData = await this.getDiff(data1, data2);
      this.updateStore({ ...diffData, data1, data2 });
    },
    getDiff: async function(data1, data2) {
      const { type } = get_store_value(this);
      let content1 = data1.data;
      let content2 = data2.data;
      let diff, additions = 0, deletions = 0;
      switch (type) {
        case C.TYPE_DOC:
        case C.TYPE_HTML:
        case C.TYPE_PDF_HTML:
          try {
            ({ diff, additions, deletions } = await Diff.diffHtml(content1, content2, data1.id + data2.id));
          } catch (e) {
            diff = content2;
            console.error(e);
          }
          break;
        case C.TYPE_JSON:
          if (typeof content1 === "string") {
            content1 = JSON.parse(content1);
            data1.data = content1;
          }
          if (typeof content2 === "string") {
            content2 = JSON.parse(content2);
            data2.data = content2;
          }
          diff = await Diff.diffJson(content1, content2);
          ({ additions, deletions } = diff);
          break;
      }
      return { diff, additions, deletions };
    },
    updateStore: function(obj) {
      update((value) => {
        return { ...value, ...obj };
      });
    }
  };
  return store;
}
function destroyStore() {
  store = void 0;
}
let store;
function create_fragment$1p(ctx) {
  let div;
  let span1;
  let span0;
  let t0;
  let t1;
  let t2;
  let span4;
  let span2;
  let t3;
  let span3;
  return {
    c() {
      div = element("div");
      span1 = element("span");
      span0 = element("span");
      t0 = text(ctx[0]);
      t1 = text("+");
      t2 = space();
      span4 = element("span");
      span2 = element("span");
      t3 = text(ctx[1]);
      span3 = element("span");
      span3.textContent = "\u2013";
      attr(span1, "class", "text-green-700 font-bold");
      set_style(span3, "font-size", "1.1em");
      set_style(span3, "line-height", "1.1");
      attr(span4, "class", "text-red-700 font-bold");
      attr(div, "class", ctx[2]);
      attr(div, "title", T("l_diff_stats"));
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span1);
      append(span1, span0);
      append(span0, t0);
      append(span1, t1);
      append(div, t2);
      append(div, span4);
      append(span4, span2);
      append(span2, t3);
      append(span4, span3);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1)
        set_data(t0, ctx2[0]);
      if (dirty & 2)
        set_data(t3, ctx2[1]);
      if (dirty & 4) {
        attr(div, "class", ctx2[2]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function instance$1o($$self, $$props, $$invalidate) {
  let { additions } = $$props;
  let { deletions } = $$props;
  let { class: classes2 = "" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("additions" in $$props2)
      $$invalidate(0, additions = $$props2.additions);
    if ("deletions" in $$props2)
      $$invalidate(1, deletions = $$props2.deletions);
    if ("class" in $$props2)
      $$invalidate(2, classes2 = $$props2.class);
  };
  return [additions, deletions, classes2];
}
class DiffStats extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1o, create_fragment$1p, safe_not_equal, { additions: 0, deletions: 1, class: 2 });
  }
}
var ExploreDiffHeader_svelte_svelte_type_style_lang = "";
function create_if_block_1$m(ctx) {
  let div;
  let button0;
  let t0_value = T("a_side_by_side_diff") + "";
  let t0;
  let button0_class_value;
  let t1;
  let button1;
  let t2_value = T("a_inline_diff") + "";
  let t2;
  let button1_class_value;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button0 = element("button");
      t0 = text(t0_value);
      t1 = space();
      button1 = element("button");
      t2 = text(t2_value);
      attr(button0, "class", button0_class_value = "btn btn-default flex-grow " + (!ctx[0] ? "btn-primary min-w-0 active" : ""));
      attr(button1, "class", button1_class_value = "btn btn-default flex-grow " + (ctx[0] ? "btn-primary min-w-0 active" : ""));
      attr(div, "class", "btn-group btn-toggle flex");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button0);
      append(button0, t0);
      append(div, t1);
      append(div, button1);
      append(button1, t2);
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[10]),
          listen(button1, "click", ctx[11])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1 && button0_class_value !== (button0_class_value = "btn btn-default flex-grow " + (!ctx2[0] ? "btn-primary min-w-0 active" : ""))) {
        attr(button0, "class", button0_class_value);
      }
      if (dirty & 1 && button1_class_value !== (button1_class_value = "btn btn-default flex-grow " + (ctx2[0] ? "btn-primary min-w-0 active" : ""))) {
        attr(button1, "class", button1_class_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$C(ctx) {
  let div;
  let button0;
  let t0_value = T("a_styled_page") + "";
  let t0;
  let button0_class_value;
  let button1;
  let t1_value = T("a_unstyled_page") + "";
  let t1;
  let button1_class_value;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button0 = element("button");
      t0 = text(t0_value);
      button1 = element("button");
      t1 = text(t1_value);
      attr(button0, "class", button0_class_value = "btn btn-default " + (!ctx[1] ? "btn-primary min-w-0 active" : ""));
      attr(button1, "class", button1_class_value = "btn btn-default " + (ctx[1] ? "btn-primary min-w-0 active" : ""));
      attr(div, "class", "btn-group btn-toggle no-wrap flex conceal svelte-gdbbe6");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button0);
      append(button0, t0);
      append(div, button1);
      append(button1, t1);
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[12]),
          listen(button1, "click", ctx[13])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 2 && button0_class_value !== (button0_class_value = "btn btn-default " + (!ctx2[1] ? "btn-primary min-w-0 active" : ""))) {
        attr(button0, "class", button0_class_value);
      }
      if (dirty & 2 && button1_class_value !== (button1_class_value = "btn btn-default " + (ctx2[1] ? "btn-primary min-w-0 active" : ""))) {
        attr(button1, "class", button1_class_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_catch_block_1(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block_1(ctx) {
  let div1;
  let dateselect0;
  let t0;
  let div0;
  let t1;
  let dateselect1;
  let t2;
  let a;
  let i1;
  let a_href_value;
  let current;
  dateselect0 = new DateSelect({
    props: {
      timestamps: ctx[6].sieve_data,
      value: ctx[6].data1.id,
      title: T("l_sieve_to_compare")
    }
  });
  dateselect0.$on("change", ctx[14]);
  dateselect1 = new DateSelect({
    props: {
      timestamps: ctx[6].sieve_data,
      value: ctx[6].data2.id,
      title: T("l_sieve_to_compare_with")
    }
  });
  dateselect1.$on("change", ctx[15]);
  return {
    c() {
      div1 = element("div");
      create_component(dateselect0.$$.fragment);
      t0 = space();
      div0 = element("div");
      div0.innerHTML = `<i class="fa fa-arrow-right"></i>`;
      t1 = space();
      create_component(dateselect1.$$.fragment);
      t2 = space();
      a = element("a");
      i1 = element("i");
      attr(div0, "class", "flex items-center");
      attr(div1, "class", "flex items-center gap-2");
      attr(i1, "class", "fa fa-external-link");
      attr(a, "href", a_href_value = ctx[6].uri);
      attr(a, "class", "btn btn-default");
      attr(a, "target", "_blank");
      attr(a, "rel", "noopener");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      mount_component(dateselect0, div1, null);
      append(div1, t0);
      append(div1, div0);
      append(div1, t1);
      mount_component(dateselect1, div1, null);
      insert(target, t2, anchor);
      insert(target, a, anchor);
      append(a, i1);
      current = true;
    },
    p(ctx2, dirty) {
      const dateselect0_changes = {};
      if (dirty & 64)
        dateselect0_changes.timestamps = ctx2[6].sieve_data;
      if (dirty & 64)
        dateselect0_changes.value = ctx2[6].data1.id;
      dateselect0.$set(dateselect0_changes);
      const dateselect1_changes = {};
      if (dirty & 64)
        dateselect1_changes.timestamps = ctx2[6].sieve_data;
      if (dirty & 64)
        dateselect1_changes.value = ctx2[6].data2.id;
      dateselect1.$set(dateselect1_changes);
      if (!current || dirty & 64 && a_href_value !== (a_href_value = ctx2[6].uri)) {
        attr(a, "href", a_href_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(dateselect0.$$.fragment, local);
      transition_in(dateselect1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dateselect0.$$.fragment, local);
      transition_out(dateselect1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(dateselect0);
      destroy_component(dateselect1);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(a);
    }
  };
}
function create_pending_block_1(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_catch_block$8(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$8(ctx) {
  let div;
  let diffstats;
  let current;
  diffstats = new DiffStats({
    props: {
      additions: ctx[6].additions,
      deletions: ctx[6].deletions,
      class: "bg-white border-[1px] border-[#cccccc] border-solid p-2 rounded-md "
    }
  });
  return {
    c() {
      div = element("div");
      create_component(diffstats.$$.fragment);
      attr(div, "class", "flex mr-5");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(diffstats, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const diffstats_changes = {};
      if (dirty & 64)
        diffstats_changes.additions = ctx2[6].additions;
      if (dirty & 64)
        diffstats_changes.deletions = ctx2[6].deletions;
      diffstats.$set(diffstats_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(diffstats.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(diffstats.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(diffstats);
    }
  };
}
function create_pending_block$8(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_fragment$1o(ctx) {
  let div3;
  let div0;
  let t0;
  let t1;
  let promise_1;
  let t2;
  let div2;
  let promise_2;
  let t3;
  let div1;
  let button;
  let t4;
  let div3_class_value;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[2] && create_if_block_1$m(ctx);
  let if_block1 = ctx[3] && create_if_block$C(ctx);
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block_1,
    then: create_then_block_1,
    catch: create_catch_block_1,
    value: 17,
    blocks: [, , ,]
  };
  handle_promise(promise_1 = ctx[4], info);
  let info_1 = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$8,
    then: create_then_block$8,
    catch: create_catch_block$8,
    value: 17,
    blocks: [, , ,]
  };
  handle_promise(promise_2 = ctx[4], info_1);
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      info.block.c();
      t2 = space();
      div2 = element("div");
      info_1.block.c();
      t3 = space();
      div1 = element("div");
      button = element("button");
      t4 = text("\u2715");
      attr(div0, "class", "flex gap-4 no-wrap");
      attr(button, "class", "close");
      attr(button, "title", T("a_close"));
      attr(div1, "class", "flex");
      attr(div2, "class", "flex items-center");
      attr(div3, "class", div3_class_value = "panel-heading xpanel-heading-alt flex justify-between gap-8 items-stretch no-wrap " + ctx[5] + " svelte-gdbbe6");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div0);
      if (if_block0)
        if_block0.m(div0, null);
      append(div0, t0);
      if (if_block1)
        if_block1.m(div0, null);
      append(div0, t1);
      info.block.m(div0, info.anchor = null);
      info.mount = () => div0;
      info.anchor = null;
      append(div3, t2);
      append(div3, div2);
      info_1.block.m(div2, info_1.anchor = null);
      info_1.mount = () => div2;
      info_1.anchor = t3;
      append(div2, t3);
      append(div2, div1);
      append(div1, button);
      append(button, t4);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[16]);
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (ctx[2]) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
        } else {
          if_block0 = create_if_block_1$m(ctx);
          if_block0.c();
          if_block0.m(div0, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx[3]) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
        } else {
          if_block1 = create_if_block$C(ctx);
          if_block1.c();
          if_block1.m(div0, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      info.ctx = ctx;
      if (dirty & 16 && promise_1 !== (promise_1 = ctx[4]) && handle_promise(promise_1, info))
        ;
      else {
        update_await_block_branch(info, ctx, dirty);
      }
      info_1.ctx = ctx;
      if (dirty & 16 && promise_2 !== (promise_2 = ctx[4]) && handle_promise(promise_2, info_1))
        ;
      else {
        update_await_block_branch(info_1, ctx, dirty);
      }
      if (!current || dirty & 32 && div3_class_value !== (div3_class_value = "panel-heading xpanel-heading-alt flex justify-between gap-8 items-stretch no-wrap " + ctx[5] + " svelte-gdbbe6")) {
        attr(div3, "class", div3_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      transition_in(info_1.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info_1.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      info.block.d();
      info.token = null;
      info = null;
      info_1.block.d();
      info_1.token = null;
      info_1 = null;
      mounted = false;
      dispose();
    }
  };
}
function instance$1n($$self, $$props, $$invalidate) {
  let $store;
  component_subscribe($$self, store, ($$value) => $$invalidate(6, $store = $$value));
  const dispatch = createEventDispatcher();
  let { showDiffMode = true } = $$props;
  let { showStyleMode = true } = $$props;
  let { inlined = false } = $$props;
  let { withoutStyle = false } = $$props;
  let { promise } = $$props;
  let { class: classes2 = "" } = $$props;
  function showDiffInline(value) {
    $$invalidate(0, inlined = value);
  }
  function removeStyles(value) {
    $$invalidate(1, withoutStyle = value);
  }
  const click_handler2 = () => showDiffInline(false);
  const click_handler_1 = () => showDiffInline(true);
  const click_handler_2 = () => removeStyles(false);
  const click_handler_3 = () => removeStyles(true);
  const change_handler = (e) => store.updateData1ById(e.detail.value);
  const change_handler_1 = (e) => store.updateData2ById(e.detail.value);
  const click_handler_4 = () => dispatch("close");
  $$self.$$set = ($$props2) => {
    if ("showDiffMode" in $$props2)
      $$invalidate(2, showDiffMode = $$props2.showDiffMode);
    if ("showStyleMode" in $$props2)
      $$invalidate(3, showStyleMode = $$props2.showStyleMode);
    if ("inlined" in $$props2)
      $$invalidate(0, inlined = $$props2.inlined);
    if ("withoutStyle" in $$props2)
      $$invalidate(1, withoutStyle = $$props2.withoutStyle);
    if ("promise" in $$props2)
      $$invalidate(4, promise = $$props2.promise);
    if ("class" in $$props2)
      $$invalidate(5, classes2 = $$props2.class);
  };
  return [
    inlined,
    withoutStyle,
    showDiffMode,
    showStyleMode,
    promise,
    classes2,
    $store,
    dispatch,
    showDiffInline,
    removeStyles,
    click_handler2,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    change_handler,
    change_handler_1,
    click_handler_4
  ];
}
class ExploreDiffHeader extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1n, create_fragment$1o, safe_not_equal, {
      showDiffMode: 2,
      showStyleMode: 3,
      inlined: 0,
      withoutStyle: 1,
      promise: 4,
      class: 5
    });
  }
}
function create_fragment$1n(ctx) {
  let div;
  let button0;
  let i0;
  let button0_disabled_value;
  let t;
  let button1;
  let i1;
  let button1_disabled_value;
  let div_class_value;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button0 = element("button");
      i0 = element("i");
      t = space();
      button1 = element("button");
      i1 = element("i");
      attr(i0, "class", "fa fa-chevron-up");
      attr(button0, "class", "btn btn-default");
      attr(button0, "title", "Previous Diff");
      button0.disabled = button0_disabled_value = ctx[4] || ctx[2];
      attr(i1, "class", "fa fa-chevron-down");
      attr(button1, "class", "btn btn-default");
      attr(button1, "title", "Next Diff");
      button1.disabled = button1_disabled_value = ctx[4] || ctx[3];
      attr(div, "class", div_class_value = "btn-group flex flex-nowrap " + ctx[5]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button0);
      append(button0, i0);
      append(div, t);
      append(div, button1);
      append(button1, i1);
      if (!mounted) {
        dispose = [
          listen(button0, "click", function() {
            if (is_function(ctx[1]))
              ctx[1].apply(this, arguments);
          }),
          listen(button1, "click", function() {
            if (is_function(ctx[0]))
              ctx[0].apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (dirty & 20 && button0_disabled_value !== (button0_disabled_value = ctx[4] || ctx[2])) {
        button0.disabled = button0_disabled_value;
      }
      if (dirty & 24 && button1_disabled_value !== (button1_disabled_value = ctx[4] || ctx[3])) {
        button1.disabled = button1_disabled_value;
      }
      if (dirty & 32 && div_class_value !== (div_class_value = "btn-group flex flex-nowrap " + ctx[5])) {
        attr(div, "class", div_class_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$1m($$self, $$props, $$invalidate) {
  let { nextFn } = $$props;
  let { prevFn } = $$props;
  let { nextDisabled = false } = $$props;
  let { prevDisabled = false } = $$props;
  let { disableButtons = false } = $$props;
  let { class: classes2 = "" } = $$props;
  createEventDispatcher();
  $$self.$$set = ($$props2) => {
    if ("nextFn" in $$props2)
      $$invalidate(0, nextFn = $$props2.nextFn);
    if ("prevFn" in $$props2)
      $$invalidate(1, prevFn = $$props2.prevFn);
    if ("nextDisabled" in $$props2)
      $$invalidate(2, nextDisabled = $$props2.nextDisabled);
    if ("prevDisabled" in $$props2)
      $$invalidate(3, prevDisabled = $$props2.prevDisabled);
    if ("disableButtons" in $$props2)
      $$invalidate(4, disableButtons = $$props2.disableButtons);
    if ("class" in $$props2)
      $$invalidate(5, classes2 = $$props2.class);
  };
  return [nextFn, prevFn, nextDisabled, prevDisabled, disableButtons, classes2];
}
class NavigateDiff extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1m, create_fragment$1n, safe_not_equal, {
      nextFn: 0,
      prevFn: 1,
      nextDisabled: 2,
      prevDisabled: 3,
      disableButtons: 4,
      class: 5
    });
  }
}
function create_fragment$1m(ctx) {
  let ul;
  let li0;
  let navigatediff;
  let t0;
  let li1;
  let a0;
  let t2;
  let li2;
  let a1;
  let t4;
  let li3;
  let ul_class_value;
  let current;
  let mounted;
  let dispose;
  navigatediff = new NavigateDiff({
    props: {
      nextFn: ctx[1],
      prevFn: ctx[2],
      disableButtons: ctx[4].disableButtons
    }
  });
  return {
    c() {
      ul = element("ul");
      li0 = element("li");
      create_component(navigatediff.$$.fragment);
      t0 = space();
      li1 = element("li");
      a0 = element("a");
      a0.textContent = `${T("l_tree")}`;
      t2 = space();
      li2 = element("li");
      a1 = element("a");
      a1.textContent = `${T("l_raw")}`;
      t4 = space();
      li3 = element("li");
      attr(li0, "class", "m-0 pl-2 mr-3 ");
      attr(li1, "class", "nav-item");
      toggle_class(li1, "active", ctx[0]);
      attr(li2, "class", "nav-item");
      toggle_class(li2, "active", !ctx[0]);
      attr(li3, "class", "flex-1");
      attr(ul, "class", ul_class_value = "nav nav-tabs sticky top-[-13px] bg-white flex w-full " + ctx[3]);
    },
    m(target, anchor) {
      insert(target, ul, anchor);
      append(ul, li0);
      mount_component(navigatediff, li0, null);
      append(ul, t0);
      append(ul, li1);
      append(li1, a0);
      append(ul, t2);
      append(ul, li2);
      append(li2, a1);
      append(ul, t4);
      append(ul, li3);
      current = true;
      if (!mounted) {
        dispose = [
          listen(a0, "click", ctx[5]),
          listen(a1, "click", ctx[6])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const navigatediff_changes = {};
      if (dirty & 2)
        navigatediff_changes.nextFn = ctx2[1];
      if (dirty & 4)
        navigatediff_changes.prevFn = ctx2[2];
      if (dirty & 16)
        navigatediff_changes.disableButtons = ctx2[4].disableButtons;
      navigatediff.$set(navigatediff_changes);
      if (dirty & 1) {
        toggle_class(li1, "active", ctx2[0]);
      }
      if (dirty & 1) {
        toggle_class(li2, "active", !ctx2[0]);
      }
      if (!current || dirty & 8 && ul_class_value !== (ul_class_value = "nav nav-tabs sticky top-[-13px] bg-white flex w-full " + ctx2[3])) {
        attr(ul, "class", ul_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(navigatediff.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(navigatediff.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(ul);
      destroy_component(navigatediff);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$1l($$self, $$props, $$invalidate) {
  const omit_props_names = ["treeViewMode", "goToNextDiff", "goToPrevDiff", "class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { treeViewMode = true } = $$props;
  let { goToNextDiff } = $$props;
  let { goToPrevDiff } = $$props;
  let { class: classes2 = "" } = $$props;
  const click_handler2 = () => $$invalidate(0, treeViewMode = true);
  const click_handler_1 = () => $$invalidate(0, treeViewMode = false);
  $$self.$$set = ($$new_props) => {
    $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("treeViewMode" in $$new_props)
      $$invalidate(0, treeViewMode = $$new_props.treeViewMode);
    if ("goToNextDiff" in $$new_props)
      $$invalidate(1, goToNextDiff = $$new_props.goToNextDiff);
    if ("goToPrevDiff" in $$new_props)
      $$invalidate(2, goToPrevDiff = $$new_props.goToPrevDiff);
    if ("class" in $$new_props)
      $$invalidate(3, classes2 = $$new_props.class);
  };
  return [
    treeViewMode,
    goToNextDiff,
    goToPrevDiff,
    classes2,
    $$restProps,
    click_handler2,
    click_handler_1
  ];
}
class JSONDiffHeader extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1l, create_fragment$1m, safe_not_equal, {
      treeViewMode: 0,
      goToNextDiff: 1,
      goToPrevDiff: 2,
      class: 3
    });
  }
}
function create_else_block_1$4(ctx) {
  let pre;
  let t_value = JSON.stringify(ctx[6].data1.data, null, 2) + "";
  let t;
  return {
    c() {
      pre = element("pre");
      t = text(t_value);
      attr(pre, "class", "overflow-auto whitespace-pre-wrap border-t-0 bg-white");
    },
    m(target, anchor) {
      insert(target, pre, anchor);
      append(pre, t);
    },
    p(ctx2, dirty) {
      if (dirty & 64 && t_value !== (t_value = JSON.stringify(ctx2[6].data1.data, null, 2) + ""))
        set_data(t, t_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(pre);
    }
  };
}
function create_if_block_1$l(ctx) {
  let jsondiffview;
  let updating_goToNextDiff;
  let updating_goToPrevDiff;
  let current;
  function jsondiffview_goToNextDiff_binding(value) {
    ctx[8](value);
  }
  function jsondiffview_goToPrevDiff_binding(value) {
    ctx[9](value);
  }
  let jsondiffview_props = {
    diff: ctx[6].diff,
    computeDiff: false,
    pruneAdditions: true,
    class: "flex-grow",
    treeViewClass: "border-t-0",
    diffNavigation: true
  };
  if (ctx[1] !== void 0) {
    jsondiffview_props.goToNextDiff = ctx[1];
  }
  if (ctx[2] !== void 0) {
    jsondiffview_props.goToPrevDiff = ctx[2];
  }
  jsondiffview = new JSONDiffView({ props: jsondiffview_props });
  binding_callbacks.push(() => bind$2(jsondiffview, "goToNextDiff", jsondiffview_goToNextDiff_binding));
  binding_callbacks.push(() => bind$2(jsondiffview, "goToPrevDiff", jsondiffview_goToPrevDiff_binding));
  return {
    c() {
      create_component(jsondiffview.$$.fragment);
    },
    m(target, anchor) {
      mount_component(jsondiffview, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const jsondiffview_changes = {};
      if (dirty & 64)
        jsondiffview_changes.diff = ctx2[6].diff;
      if (!updating_goToNextDiff && dirty & 2) {
        updating_goToNextDiff = true;
        jsondiffview_changes.goToNextDiff = ctx2[1];
        add_flush_callback(() => updating_goToNextDiff = false);
      }
      if (!updating_goToPrevDiff && dirty & 4) {
        updating_goToPrevDiff = true;
        jsondiffview_changes.goToPrevDiff = ctx2[2];
        add_flush_callback(() => updating_goToPrevDiff = false);
      }
      jsondiffview.$set(jsondiffview_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(jsondiffview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(jsondiffview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(jsondiffview, detaching);
    }
  };
}
function create_else_block$n(ctx) {
  let pre;
  let t_value = JSON.stringify(ctx[6].data2.data, null, 2) + "";
  let t;
  return {
    c() {
      pre = element("pre");
      t = text(t_value);
      attr(pre, "class", "overflow-auto whitespace-pre-wrap border-t-0 bg-white");
    },
    m(target, anchor) {
      insert(target, pre, anchor);
      append(pre, t);
    },
    p(ctx2, dirty) {
      if (dirty & 64 && t_value !== (t_value = JSON.stringify(ctx2[6].data2.data, null, 2) + ""))
        set_data(t, t_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(pre);
    }
  };
}
function create_if_block$B(ctx) {
  let jsondiffview;
  let updating_goToNextDiff;
  let updating_goToPrevDiff;
  let current;
  function jsondiffview_goToNextDiff_binding_1(value) {
    ctx[11](value);
  }
  function jsondiffview_goToPrevDiff_binding_1(value) {
    ctx[12](value);
  }
  let jsondiffview_props = {
    diff: ctx[6].diff,
    computeDiff: false,
    pruneDeletions: true,
    class: "flex-grow",
    treeViewClass: "border-t-0",
    diffNavigation: true
  };
  if (ctx[4] !== void 0) {
    jsondiffview_props.goToNextDiff = ctx[4];
  }
  if (ctx[5] !== void 0) {
    jsondiffview_props.goToPrevDiff = ctx[5];
  }
  jsondiffview = new JSONDiffView({ props: jsondiffview_props });
  binding_callbacks.push(() => bind$2(jsondiffview, "goToNextDiff", jsondiffview_goToNextDiff_binding_1));
  binding_callbacks.push(() => bind$2(jsondiffview, "goToPrevDiff", jsondiffview_goToPrevDiff_binding_1));
  return {
    c() {
      create_component(jsondiffview.$$.fragment);
    },
    m(target, anchor) {
      mount_component(jsondiffview, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const jsondiffview_changes = {};
      if (dirty & 64)
        jsondiffview_changes.diff = ctx2[6].diff;
      if (!updating_goToNextDiff && dirty & 16) {
        updating_goToNextDiff = true;
        jsondiffview_changes.goToNextDiff = ctx2[4];
        add_flush_callback(() => updating_goToNextDiff = false);
      }
      if (!updating_goToPrevDiff && dirty & 32) {
        updating_goToPrevDiff = true;
        jsondiffview_changes.goToPrevDiff = ctx2[5];
        add_flush_callback(() => updating_goToPrevDiff = false);
      }
      jsondiffview.$set(jsondiffview_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(jsondiffview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(jsondiffview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(jsondiffview, detaching);
    }
  };
}
function create_fragment$1l(ctx) {
  let div0;
  let jsondiffheader0;
  let updating_treeViewMode;
  let t0;
  let current_block_type_index;
  let if_block0;
  let t1;
  let div1;
  let jsondiffheader1;
  let updating_treeViewMode_1;
  let t2;
  let current_block_type_index_1;
  let if_block1;
  let current;
  function jsondiffheader0_treeViewMode_binding(value) {
    ctx[7](value);
  }
  let jsondiffheader0_props = {
    disableButtons: !ctx[0],
    goToNextDiff: ctx[1],
    goToPrevDiff: ctx[2]
  };
  if (ctx[0] !== void 0) {
    jsondiffheader0_props.treeViewMode = ctx[0];
  }
  jsondiffheader0 = new JSONDiffHeader({ props: jsondiffheader0_props });
  binding_callbacks.push(() => bind$2(jsondiffheader0, "treeViewMode", jsondiffheader0_treeViewMode_binding));
  const if_block_creators = [create_if_block_1$l, create_else_block_1$4];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  function jsondiffheader1_treeViewMode_binding(value) {
    ctx[10](value);
  }
  let jsondiffheader1_props = {
    disableButtons: !ctx[3],
    goToNextDiff: ctx[4],
    goToPrevDiff: ctx[5]
  };
  if (ctx[3] !== void 0) {
    jsondiffheader1_props.treeViewMode = ctx[3];
  }
  jsondiffheader1 = new JSONDiffHeader({ props: jsondiffheader1_props });
  binding_callbacks.push(() => bind$2(jsondiffheader1, "treeViewMode", jsondiffheader1_treeViewMode_binding));
  const if_block_creators_1 = [create_if_block$B, create_else_block$n];
  const if_blocks_1 = [];
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[3])
      return 0;
    return 1;
  }
  current_block_type_index_1 = select_block_type_1(ctx);
  if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
  return {
    c() {
      div0 = element("div");
      create_component(jsondiffheader0.$$.fragment);
      t0 = space();
      if_block0.c();
      t1 = space();
      div1 = element("div");
      create_component(jsondiffheader1.$$.fragment);
      t2 = space();
      if_block1.c();
      attr(div0, "class", "flex flex-column flex-1 pl-10 pr-10");
      attr(div1, "class", "flex flex-column flex-1 border-l border-solid pl-10 pr-10");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      mount_component(jsondiffheader0, div0, null);
      append(div0, t0);
      if_blocks[current_block_type_index].m(div0, null);
      insert(target, t1, anchor);
      insert(target, div1, anchor);
      mount_component(jsondiffheader1, div1, null);
      append(div1, t2);
      if_blocks_1[current_block_type_index_1].m(div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const jsondiffheader0_changes = {};
      if (dirty & 1)
        jsondiffheader0_changes.disableButtons = !ctx2[0];
      if (dirty & 2)
        jsondiffheader0_changes.goToNextDiff = ctx2[1];
      if (dirty & 4)
        jsondiffheader0_changes.goToPrevDiff = ctx2[2];
      if (!updating_treeViewMode && dirty & 1) {
        updating_treeViewMode = true;
        jsondiffheader0_changes.treeViewMode = ctx2[0];
        add_flush_callback(() => updating_treeViewMode = false);
      }
      jsondiffheader0.$set(jsondiffheader0_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(div0, null);
      }
      const jsondiffheader1_changes = {};
      if (dirty & 8)
        jsondiffheader1_changes.disableButtons = !ctx2[3];
      if (dirty & 16)
        jsondiffheader1_changes.goToNextDiff = ctx2[4];
      if (dirty & 32)
        jsondiffheader1_changes.goToPrevDiff = ctx2[5];
      if (!updating_treeViewMode_1 && dirty & 8) {
        updating_treeViewMode_1 = true;
        jsondiffheader1_changes.treeViewMode = ctx2[3];
        add_flush_callback(() => updating_treeViewMode_1 = false);
      }
      jsondiffheader1.$set(jsondiffheader1_changes);
      let previous_block_index_1 = current_block_type_index_1;
      current_block_type_index_1 = select_block_type_1(ctx2);
      if (current_block_type_index_1 === previous_block_index_1) {
        if_blocks_1[current_block_type_index_1].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
          if_blocks_1[previous_block_index_1] = null;
        });
        check_outros();
        if_block1 = if_blocks_1[current_block_type_index_1];
        if (!if_block1) {
          if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(div1, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(jsondiffheader0.$$.fragment, local);
      transition_in(if_block0);
      transition_in(jsondiffheader1.$$.fragment, local);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(jsondiffheader0.$$.fragment, local);
      transition_out(if_block0);
      transition_out(jsondiffheader1.$$.fragment, local);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      destroy_component(jsondiffheader0);
      if_blocks[current_block_type_index].d();
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div1);
      destroy_component(jsondiffheader1);
      if_blocks_1[current_block_type_index_1].d();
    }
  };
}
function instance$1k($$self, $$props, $$invalidate) {
  let $store;
  component_subscribe($$self, store, ($$value) => $$invalidate(6, $store = $$value));
  let view1TreeMode = true;
  let view1GoToNextDiff;
  let view1GoToPrevDiff;
  let view2TreeMode = true;
  let view2GoToNextDiff;
  let view2GoToPrevDiff;
  function jsondiffheader0_treeViewMode_binding(value) {
    view1TreeMode = value;
    $$invalidate(0, view1TreeMode);
  }
  function jsondiffview_goToNextDiff_binding(value) {
    view1GoToNextDiff = value;
    $$invalidate(1, view1GoToNextDiff);
  }
  function jsondiffview_goToPrevDiff_binding(value) {
    view1GoToPrevDiff = value;
    $$invalidate(2, view1GoToPrevDiff);
  }
  function jsondiffheader1_treeViewMode_binding(value) {
    view2TreeMode = value;
    $$invalidate(3, view2TreeMode);
  }
  function jsondiffview_goToNextDiff_binding_1(value) {
    view2GoToNextDiff = value;
    $$invalidate(4, view2GoToNextDiff);
  }
  function jsondiffview_goToPrevDiff_binding_1(value) {
    view2GoToPrevDiff = value;
    $$invalidate(5, view2GoToPrevDiff);
  }
  return [
    view1TreeMode,
    view1GoToNextDiff,
    view1GoToPrevDiff,
    view2TreeMode,
    view2GoToNextDiff,
    view2GoToPrevDiff,
    $store,
    jsondiffheader0_treeViewMode_binding,
    jsondiffview_goToNextDiff_binding,
    jsondiffview_goToPrevDiff_binding,
    jsondiffheader1_treeViewMode_binding,
    jsondiffview_goToNextDiff_binding_1,
    jsondiffview_goToPrevDiff_binding_1
  ];
}
class JSONSideBySideDiff extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1k, create_fragment$1l, safe_not_equal, {});
  }
}
function create_fragment$1k(ctx) {
  let div1;
  let div0;
  let navigatediff;
  let t;
  let jsondiffview;
  let updating_goToNextDiff;
  let updating_goToPrevDiff;
  let current;
  navigatediff = new NavigateDiff({
    props: {
      nextFn: ctx[0],
      prevFn: ctx[1]
    }
  });
  function jsondiffview_goToNextDiff_binding(value) {
    ctx[3](value);
  }
  function jsondiffview_goToPrevDiff_binding(value) {
    ctx[4](value);
  }
  let jsondiffview_props = {
    scrollToFirstDiff: true,
    diff: ctx[2].diff,
    computeDiff: false,
    diffNavigation: true
  };
  if (ctx[0] !== void 0) {
    jsondiffview_props.goToNextDiff = ctx[0];
  }
  if (ctx[1] !== void 0) {
    jsondiffview_props.goToPrevDiff = ctx[1];
  }
  jsondiffview = new JSONDiffView({ props: jsondiffview_props });
  binding_callbacks.push(() => bind$2(jsondiffview, "goToNextDiff", jsondiffview_goToNextDiff_binding));
  binding_callbacks.push(() => bind$2(jsondiffview, "goToPrevDiff", jsondiffview_goToPrevDiff_binding));
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      create_component(navigatediff.$$.fragment);
      t = space();
      create_component(jsondiffview.$$.fragment);
      attr(div0, "class", "flex mb-3 sticky top-0 bg-transparent");
      attr(div1, "class", "flex-grow pl-10 pr-10 flex flex-column");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      mount_component(navigatediff, div0, null);
      append(div1, t);
      mount_component(jsondiffview, div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const navigatediff_changes = {};
      if (dirty & 1)
        navigatediff_changes.nextFn = ctx2[0];
      if (dirty & 2)
        navigatediff_changes.prevFn = ctx2[1];
      navigatediff.$set(navigatediff_changes);
      const jsondiffview_changes = {};
      if (dirty & 4)
        jsondiffview_changes.diff = ctx2[2].diff;
      if (!updating_goToNextDiff && dirty & 1) {
        updating_goToNextDiff = true;
        jsondiffview_changes.goToNextDiff = ctx2[0];
        add_flush_callback(() => updating_goToNextDiff = false);
      }
      if (!updating_goToPrevDiff && dirty & 2) {
        updating_goToPrevDiff = true;
        jsondiffview_changes.goToPrevDiff = ctx2[1];
        add_flush_callback(() => updating_goToPrevDiff = false);
      }
      jsondiffview.$set(jsondiffview_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(navigatediff.$$.fragment, local);
      transition_in(jsondiffview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(navigatediff.$$.fragment, local);
      transition_out(jsondiffview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(navigatediff);
      destroy_component(jsondiffview);
    }
  };
}
function instance$1j($$self, $$props, $$invalidate) {
  let $store;
  component_subscribe($$self, store, ($$value) => $$invalidate(2, $store = $$value));
  let goToNextDiff;
  let goToPrevDiff;
  function jsondiffview_goToNextDiff_binding(value) {
    goToNextDiff = value;
    $$invalidate(0, goToNextDiff);
  }
  function jsondiffview_goToPrevDiff_binding(value) {
    goToPrevDiff = value;
    $$invalidate(1, goToPrevDiff);
  }
  return [
    goToNextDiff,
    goToPrevDiff,
    $store,
    jsondiffview_goToNextDiff_binding,
    jsondiffview_goToPrevDiff_binding
  ];
}
class JSONInlineDiff extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1j, create_fragment$1k, safe_not_equal, {});
  }
}
function create_else_block$m(ctx) {
  let jsonsidebysidediff;
  let current;
  jsonsidebysidediff = new JSONSideBySideDiff({});
  return {
    c() {
      create_component(jsonsidebysidediff.$$.fragment);
    },
    m(target, anchor) {
      mount_component(jsonsidebysidediff, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(jsonsidebysidediff.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(jsonsidebysidediff.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(jsonsidebysidediff, detaching);
    }
  };
}
function create_if_block$A(ctx) {
  let jsoninlinediff;
  let current;
  jsoninlinediff = new JSONInlineDiff({});
  return {
    c() {
      create_component(jsoninlinediff.$$.fragment);
    },
    m(target, anchor) {
      mount_component(jsoninlinediff, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(jsoninlinediff.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(jsoninlinediff.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(jsoninlinediff, detaching);
    }
  };
}
function create_fragment$1j(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block$A, create_else_block$m];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "flex-grow flex items-stretch");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance$1i($$self, $$props, $$invalidate) {
  let { inlined = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("inlined" in $$props2)
      $$invalidate(0, inlined = $$props2.inlined);
  };
  return [inlined];
}
class ExploreJSONDiff extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1i, create_fragment$1j, safe_not_equal, { inlined: 0 });
  }
}
var DiffHTMLView_svelte_svelte_type_style_lang = "";
function create_fragment$1i(ctx) {
  let div;
  let iframe_1;
  let iframe_1_class_value;
  let div_class_value;
  return {
    c() {
      div = element("div");
      iframe_1 = element("iframe");
      attr(iframe_1, "title", "");
      attr(iframe_1, "class", iframe_1_class_value = "w-full xmin-height " + ctx[1] + " svelte-yf4p48");
      attr(iframe_1, "scrolling", "no");
      attr(iframe_1, "srcdoc", ctx[0]);
      attr(div, "class", div_class_value = null_to_empty(ctx[2]) + " svelte-yf4p48");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, iframe_1);
      ctx[19](iframe_1);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 2 && iframe_1_class_value !== (iframe_1_class_value = "w-full xmin-height " + ctx2[1] + " svelte-yf4p48")) {
        attr(iframe_1, "class", iframe_1_class_value);
      }
      if (dirty[0] & 1) {
        attr(iframe_1, "srcdoc", ctx2[0]);
      }
      if (dirty[0] & 4 && div_class_value !== (div_class_value = null_to_empty(ctx2[2]) + " svelte-yf4p48")) {
        attr(div, "class", div_class_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[19](null);
    }
  };
}
const highlightClass = "highlighted";
const selector = ".diffMark:not(.xdistill-hide)";
function getDiffNodes(parentEl, diffs, options = {}) {
  let { selector: selector2 } = options;
  diffs.nodes = [];
  diffs.curr = null;
  diffs.nodes = Array.from(parentEl.querySelectorAll(selector2));
}
function instance$1h($$self, $$props, $$invalidate) {
  let { oldHtml } = $$props;
  let { newHtml } = $$props;
  let { context } = $$props;
  let { diff } = $$props;
  let { uri } = $$props;
  let { computeDiff = true } = $$props;
  let { hideInserted = false } = $$props;
  let { hideRemoved = false } = $$props;
  let { withoutStyle = false } = $$props;
  let { iframeClass = "" } = $$props;
  let { additions = 0 } = $$props;
  let { deletions = 0 } = $$props;
  let { scrollToFirstDiff = false } = $$props;
  let { diffNavigation = false } = $$props;
  const goToNextDiff = () => goToDiff(STEP.NEXT);
  const goToPrevDiff = () => goToDiff(STEP.PREV);
  const STEP = { NEXT: 1, PREV: -1 };
  let { class: classes2 = "" } = $$props;
  let iframe;
  let styleSheets;
  let styledElements;
  const styles = `
  .inserted {
    background-color: #b7fdcb;
  }
  .removed {
    background-color: #ff9494;
  }
  span.inserted,
  span.removed {
    padding: 1px 4px;
  }
  a.removed,
  a .removed {
    color: #008;
  }
  img.inserted {
    border: solid 2px green;
    background-color: transparent;
    padding: 2px;
  }
  img.removed {
    border: solid 2px red;
    background-color: transparent;
    padding: 2px;
  }
  [hidden] {
    display:block;
  }
  .xdistill-hide {display: none !important}
  .highlighted{
     outline: blue solid 2px;
  }
  `;
  let load = false;
  let parentEl;
  let diffs = { nodes: [], curr: null };
  function goToDiff(step) {
    let { nodes, curr } = diffs;
    const length = nodes.length;
    if (length === 0) {
      return;
    }
    if (curr === null) {
      if (step === STEP.NEXT) {
        curr = -1;
      } else {
        curr = length;
      }
    }
    let next = curr + step;
    if (next < 0) {
      next = length - 1;
    } else if (next >= length) {
      next = 0;
    }
    const currDiff = nodes[curr];
    const nextDiff = nodes[next];
    currDiff == null ? void 0 : currDiff.classList.remove(highlightClass);
    nextDiff.classList.add(highlightClass);
    nextDiff.scrollIntoView({ behaviour: "smooth", block: "center" });
    diffs.curr = next;
  }
  function goToFirstDiff() {
    const firstDiffEl = diffs.nodes[0];
    if (firstDiffEl) {
      diffs.curr = 0;
      firstDiffEl.scrollIntoView({ behaviour: "smooth", block: "center" });
      firstDiffEl.classList.add(highlightClass);
    }
  }
  onMount(() => {
    $$invalidate(3, iframe.onload = onLoad, iframe);
  });
  function onLoad() {
    parentEl = iframe.contentWindow.document;
    styleSheets = void 0;
    styledElements = void 0;
    resetHighlighting();
    updateLinks();
    addDiffStyles();
    if (hideInserted) {
      hideElement(".inserted");
    }
    if (hideRemoved) {
      hideElement(".removed");
    }
    if (diffNavigation) {
      getDiffNodes(parentEl, diffs, { selector });
      if (scrollToFirstDiff) {
        goToFirstDiff();
      }
    }
    getDiffCount();
    parentEl.body.addEventListener("rendered", () => {
      $$invalidate(3, iframe.height = parentEl.body.scrollHeight + "px", iframe);
    });
    injectScript();
    $$invalidate(18, load = true);
  }
  function updateLinks() {
    const baseURIMatch = diff.match(/<base\s*href=\"(.*?)\"/);
    let baseURI;
    if (baseURIMatch) {
      baseURI = baseURIMatch[1];
    } else {
      baseURI = uri;
    }
    const base2 = parentEl.createElement("base");
    base2.setAttribute("href", baseURI);
    (parentEl.head || parentEl.documentElement).prepend(base2);
    parentEl.querySelectorAll("a[href]").forEach((el) => {
      el.setAttribute("target", "_blank");
      el.setAttribute("rel", "noopener");
    });
  }
  function updateHeight() {
    parentEl.body.dispatchEvent(new Event("rendered"));
  }
  function injectScript() {
    const script = document.createElement("script");
    script.innerHTML = `document.body.dispatchEvent(new Event('rendered'));`;
    parentEl.body.append(script);
  }
  function resetHighlighting() {
    Array.from(parentEl.querySelectorAll(`.${highlightClass}`)).map((el) => el.classList.remove(highlightClass));
  }
  function getDiffCount() {
    $$invalidate(4, additions = parentEl.querySelectorAll(".inserted").length || 0);
    $$invalidate(5, deletions = parentEl.querySelectorAll(".removed").length || 0);
  }
  async function getDiff() {
    try {
      $$invalidate(0, { diff, additions, deletions } = await Diff.diffHtml(oldHtml, newHtml, context), diff, $$invalidate(4, additions), $$invalidate(5, deletions));
    } catch (e) {
      console.error(e);
      $$invalidate(0, diff = newHtml);
    }
  }
  function hideElement(selector2, cls = "xdistill-hide") {
    parentEl.querySelectorAll(selector2).forEach((element2) => {
      element2.classList.add(cls);
    });
  }
  function addDiffStyles() {
    const style = document.createElement("style");
    style.classList.add("xdistill");
    style.innerText = styles;
    parentEl.querySelector("head").appendChild(style);
  }
  function toggleStyle(flag) {
    if (flag) {
      styleSheets = Array.from(parentEl.querySelectorAll("link[rel=stylesheet],style:not(.xdistill)"));
      styleSheets.forEach((style) => style.remove());
      styledElements = Array.from(parentEl.querySelectorAll("[style]")).map((element2) => {
        let data = [element2, element2.getAttribute("style")];
        element2.removeAttribute("style");
        return data;
      });
    } else {
      styleSheets && styleSheets.forEach((style) => parentEl.querySelector("head").appendChild(style));
      styledElements && styledElements.forEach(([element2, style]) => {
        element2.setAttribute("style", style);
      });
    }
    updateHeight();
  }
  function iframe_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      iframe = $$value;
      $$invalidate(3, iframe);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("oldHtml" in $$props2)
      $$invalidate(6, oldHtml = $$props2.oldHtml);
    if ("newHtml" in $$props2)
      $$invalidate(7, newHtml = $$props2.newHtml);
    if ("context" in $$props2)
      $$invalidate(8, context = $$props2.context);
    if ("diff" in $$props2)
      $$invalidate(0, diff = $$props2.diff);
    if ("uri" in $$props2)
      $$invalidate(9, uri = $$props2.uri);
    if ("computeDiff" in $$props2)
      $$invalidate(10, computeDiff = $$props2.computeDiff);
    if ("hideInserted" in $$props2)
      $$invalidate(11, hideInserted = $$props2.hideInserted);
    if ("hideRemoved" in $$props2)
      $$invalidate(12, hideRemoved = $$props2.hideRemoved);
    if ("withoutStyle" in $$props2)
      $$invalidate(13, withoutStyle = $$props2.withoutStyle);
    if ("iframeClass" in $$props2)
      $$invalidate(1, iframeClass = $$props2.iframeClass);
    if ("additions" in $$props2)
      $$invalidate(4, additions = $$props2.additions);
    if ("deletions" in $$props2)
      $$invalidate(5, deletions = $$props2.deletions);
    if ("scrollToFirstDiff" in $$props2)
      $$invalidate(14, scrollToFirstDiff = $$props2.scrollToFirstDiff);
    if ("diffNavigation" in $$props2)
      $$invalidate(15, diffNavigation = $$props2.diffNavigation);
    if ("class" in $$props2)
      $$invalidate(2, classes2 = $$props2.class);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 270336) {
      load && toggleStyle(withoutStyle);
    }
    if ($$self.$$.dirty[0] & 1024) {
      computeDiff && getDiff();
    }
  };
  return [
    diff,
    iframeClass,
    classes2,
    iframe,
    additions,
    deletions,
    oldHtml,
    newHtml,
    context,
    uri,
    computeDiff,
    hideInserted,
    hideRemoved,
    withoutStyle,
    scrollToFirstDiff,
    diffNavigation,
    goToNextDiff,
    goToPrevDiff,
    load,
    iframe_1_binding
  ];
}
class DiffHTMLView$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1h, create_fragment$1i, safe_not_equal, {
      oldHtml: 6,
      newHtml: 7,
      context: 8,
      diff: 0,
      uri: 9,
      computeDiff: 10,
      hideInserted: 11,
      hideRemoved: 12,
      withoutStyle: 13,
      iframeClass: 1,
      additions: 4,
      deletions: 5,
      scrollToFirstDiff: 14,
      diffNavigation: 15,
      goToNextDiff: 16,
      goToPrevDiff: 17,
      class: 2
    }, null, [-1, -1]);
  }
  get goToNextDiff() {
    return this.$$.ctx[16];
  }
  get goToPrevDiff() {
    return this.$$.ctx[17];
  }
}
function create_fragment$1h(ctx) {
  let div1;
  let div0;
  let navigatediff;
  let t;
  let diffhtmlview;
  let updating_goToNextDiff;
  let updating_goToPrevDiff;
  let updating_withoutStyle;
  let current;
  navigatediff = new NavigateDiff({
    props: {
      class: "ml-5 bg-transparent",
      nextFn: ctx[1],
      prevFn: ctx[2]
    }
  });
  function diffhtmlview_goToNextDiff_binding(value) {
    ctx[4](value);
  }
  function diffhtmlview_goToPrevDiff_binding(value) {
    ctx[5](value);
  }
  function diffhtmlview_withoutStyle_binding(value) {
    ctx[6](value);
  }
  let diffhtmlview_props = {
    diff: ctx[3].diff,
    uri: ctx[3].uri,
    computeDiff: false,
    class: "flex-grow pt-6",
    scrollToFirstDiff: true,
    diffNavigation: true
  };
  if (ctx[1] !== void 0) {
    diffhtmlview_props.goToNextDiff = ctx[1];
  }
  if (ctx[2] !== void 0) {
    diffhtmlview_props.goToPrevDiff = ctx[2];
  }
  if (ctx[0] !== void 0) {
    diffhtmlview_props.withoutStyle = ctx[0];
  }
  diffhtmlview = new DiffHTMLView$1({ props: diffhtmlview_props });
  binding_callbacks.push(() => bind$2(diffhtmlview, "goToNextDiff", diffhtmlview_goToNextDiff_binding));
  binding_callbacks.push(() => bind$2(diffhtmlview, "goToPrevDiff", diffhtmlview_goToPrevDiff_binding));
  binding_callbacks.push(() => bind$2(diffhtmlview, "withoutStyle", diffhtmlview_withoutStyle_binding));
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      create_component(navigatediff.$$.fragment);
      t = space();
      create_component(diffhtmlview.$$.fragment);
      attr(div0, "class", "flex justify-start sticky top-0");
      attr(div1, "class", "flex flex-column self-stretch flex-grow");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      mount_component(navigatediff, div0, null);
      append(div1, t);
      mount_component(diffhtmlview, div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const navigatediff_changes = {};
      if (dirty & 2)
        navigatediff_changes.nextFn = ctx2[1];
      if (dirty & 4)
        navigatediff_changes.prevFn = ctx2[2];
      navigatediff.$set(navigatediff_changes);
      const diffhtmlview_changes = {};
      if (dirty & 8)
        diffhtmlview_changes.diff = ctx2[3].diff;
      if (dirty & 8)
        diffhtmlview_changes.uri = ctx2[3].uri;
      if (!updating_goToNextDiff && dirty & 2) {
        updating_goToNextDiff = true;
        diffhtmlview_changes.goToNextDiff = ctx2[1];
        add_flush_callback(() => updating_goToNextDiff = false);
      }
      if (!updating_goToPrevDiff && dirty & 4) {
        updating_goToPrevDiff = true;
        diffhtmlview_changes.goToPrevDiff = ctx2[2];
        add_flush_callback(() => updating_goToPrevDiff = false);
      }
      if (!updating_withoutStyle && dirty & 1) {
        updating_withoutStyle = true;
        diffhtmlview_changes.withoutStyle = ctx2[0];
        add_flush_callback(() => updating_withoutStyle = false);
      }
      diffhtmlview.$set(diffhtmlview_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(navigatediff.$$.fragment, local);
      transition_in(diffhtmlview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(navigatediff.$$.fragment, local);
      transition_out(diffhtmlview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(navigatediff);
      destroy_component(diffhtmlview);
    }
  };
}
function instance$1g($$self, $$props, $$invalidate) {
  let $store;
  component_subscribe($$self, store, ($$value) => $$invalidate(3, $store = $$value));
  let { withoutStyle = false } = $$props;
  let goToNextDiff;
  let goToPrevDiff;
  function diffhtmlview_goToNextDiff_binding(value) {
    goToNextDiff = value;
    $$invalidate(1, goToNextDiff);
  }
  function diffhtmlview_goToPrevDiff_binding(value) {
    goToPrevDiff = value;
    $$invalidate(2, goToPrevDiff);
  }
  function diffhtmlview_withoutStyle_binding(value) {
    withoutStyle = value;
    $$invalidate(0, withoutStyle);
  }
  $$self.$$set = ($$props2) => {
    if ("withoutStyle" in $$props2)
      $$invalidate(0, withoutStyle = $$props2.withoutStyle);
  };
  return [
    withoutStyle,
    goToNextDiff,
    goToPrevDiff,
    $store,
    diffhtmlview_goToNextDiff_binding,
    diffhtmlview_goToPrevDiff_binding,
    diffhtmlview_withoutStyle_binding
  ];
}
class HTMLInlineDiff extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1g, create_fragment$1h, safe_not_equal, { withoutStyle: 0 });
  }
}
function create_fragment$1g(ctx) {
  let div1;
  let div0;
  let navigatediff0;
  let t0;
  let diffhtmlview0;
  let updating_withoutStyle;
  let updating_goToNextDiff;
  let updating_goToPrevDiff;
  let t1;
  let div3;
  let div2;
  let navigatediff1;
  let t2;
  let diffhtmlview1;
  let updating_withoutStyle_1;
  let updating_goToNextDiff_1;
  let updating_goToPrevDiff_1;
  let current;
  navigatediff0 = new NavigateDiff({
    props: {
      class: "ml-5",
      nextFn: ctx[1],
      prevFn: ctx[2]
    }
  });
  function diffhtmlview0_withoutStyle_binding(value) {
    ctx[6](value);
  }
  function diffhtmlview0_goToNextDiff_binding(value) {
    ctx[7](value);
  }
  function diffhtmlview0_goToPrevDiff_binding(value) {
    ctx[8](value);
  }
  let diffhtmlview0_props = {
    diff: ctx[5].diff,
    uri: ctx[5].uri,
    computeDiff: false,
    hideInserted: true,
    diffNavigation: true,
    class: "flex-grow pt-6"
  };
  if (ctx[0] !== void 0) {
    diffhtmlview0_props.withoutStyle = ctx[0];
  }
  if (ctx[1] !== void 0) {
    diffhtmlview0_props.goToNextDiff = ctx[1];
  }
  if (ctx[2] !== void 0) {
    diffhtmlview0_props.goToPrevDiff = ctx[2];
  }
  diffhtmlview0 = new DiffHTMLView$1({ props: diffhtmlview0_props });
  binding_callbacks.push(() => bind$2(diffhtmlview0, "withoutStyle", diffhtmlview0_withoutStyle_binding));
  binding_callbacks.push(() => bind$2(diffhtmlview0, "goToNextDiff", diffhtmlview0_goToNextDiff_binding));
  binding_callbacks.push(() => bind$2(diffhtmlview0, "goToPrevDiff", diffhtmlview0_goToPrevDiff_binding));
  navigatediff1 = new NavigateDiff({
    props: {
      class: "ml-5",
      nextFn: ctx[3],
      prevFn: ctx[4]
    }
  });
  function diffhtmlview1_withoutStyle_binding(value) {
    ctx[9](value);
  }
  function diffhtmlview1_goToNextDiff_binding(value) {
    ctx[10](value);
  }
  function diffhtmlview1_goToPrevDiff_binding(value) {
    ctx[11](value);
  }
  let diffhtmlview1_props = {
    diff: ctx[5].diff,
    uri: ctx[5].uri,
    computeDiff: false,
    hideRemoved: true,
    diffNavigation: true,
    class: "flex-grow pt-6"
  };
  if (ctx[0] !== void 0) {
    diffhtmlview1_props.withoutStyle = ctx[0];
  }
  if (ctx[3] !== void 0) {
    diffhtmlview1_props.goToNextDiff = ctx[3];
  }
  if (ctx[4] !== void 0) {
    diffhtmlview1_props.goToPrevDiff = ctx[4];
  }
  diffhtmlview1 = new DiffHTMLView$1({ props: diffhtmlview1_props });
  binding_callbacks.push(() => bind$2(diffhtmlview1, "withoutStyle", diffhtmlview1_withoutStyle_binding));
  binding_callbacks.push(() => bind$2(diffhtmlview1, "goToNextDiff", diffhtmlview1_goToNextDiff_binding));
  binding_callbacks.push(() => bind$2(diffhtmlview1, "goToPrevDiff", diffhtmlview1_goToPrevDiff_binding));
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      create_component(navigatediff0.$$.fragment);
      t0 = space();
      create_component(diffhtmlview0.$$.fragment);
      t1 = space();
      div3 = element("div");
      div2 = element("div");
      create_component(navigatediff1.$$.fragment);
      t2 = space();
      create_component(diffhtmlview1.$$.fragment);
      attr(div0, "class", "flex justify-start sticky bg-white top-0");
      attr(div1, "class", "flex-grow flex flex-column items-stretch");
      attr(div2, "class", "flex justify-start sticky bg-white top-0");
      attr(div3, "class", "flex-grow flex flex-column border-l border-solid items-stretch");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      mount_component(navigatediff0, div0, null);
      append(div1, t0);
      mount_component(diffhtmlview0, div1, null);
      insert(target, t1, anchor);
      insert(target, div3, anchor);
      append(div3, div2);
      mount_component(navigatediff1, div2, null);
      append(div3, t2);
      mount_component(diffhtmlview1, div3, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const navigatediff0_changes = {};
      if (dirty & 2)
        navigatediff0_changes.nextFn = ctx2[1];
      if (dirty & 4)
        navigatediff0_changes.prevFn = ctx2[2];
      navigatediff0.$set(navigatediff0_changes);
      const diffhtmlview0_changes = {};
      if (dirty & 32)
        diffhtmlview0_changes.diff = ctx2[5].diff;
      if (dirty & 32)
        diffhtmlview0_changes.uri = ctx2[5].uri;
      if (!updating_withoutStyle && dirty & 1) {
        updating_withoutStyle = true;
        diffhtmlview0_changes.withoutStyle = ctx2[0];
        add_flush_callback(() => updating_withoutStyle = false);
      }
      if (!updating_goToNextDiff && dirty & 2) {
        updating_goToNextDiff = true;
        diffhtmlview0_changes.goToNextDiff = ctx2[1];
        add_flush_callback(() => updating_goToNextDiff = false);
      }
      if (!updating_goToPrevDiff && dirty & 4) {
        updating_goToPrevDiff = true;
        diffhtmlview0_changes.goToPrevDiff = ctx2[2];
        add_flush_callback(() => updating_goToPrevDiff = false);
      }
      diffhtmlview0.$set(diffhtmlview0_changes);
      const navigatediff1_changes = {};
      if (dirty & 8)
        navigatediff1_changes.nextFn = ctx2[3];
      if (dirty & 16)
        navigatediff1_changes.prevFn = ctx2[4];
      navigatediff1.$set(navigatediff1_changes);
      const diffhtmlview1_changes = {};
      if (dirty & 32)
        diffhtmlview1_changes.diff = ctx2[5].diff;
      if (dirty & 32)
        diffhtmlview1_changes.uri = ctx2[5].uri;
      if (!updating_withoutStyle_1 && dirty & 1) {
        updating_withoutStyle_1 = true;
        diffhtmlview1_changes.withoutStyle = ctx2[0];
        add_flush_callback(() => updating_withoutStyle_1 = false);
      }
      if (!updating_goToNextDiff_1 && dirty & 8) {
        updating_goToNextDiff_1 = true;
        diffhtmlview1_changes.goToNextDiff = ctx2[3];
        add_flush_callback(() => updating_goToNextDiff_1 = false);
      }
      if (!updating_goToPrevDiff_1 && dirty & 16) {
        updating_goToPrevDiff_1 = true;
        diffhtmlview1_changes.goToPrevDiff = ctx2[4];
        add_flush_callback(() => updating_goToPrevDiff_1 = false);
      }
      diffhtmlview1.$set(diffhtmlview1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(navigatediff0.$$.fragment, local);
      transition_in(diffhtmlview0.$$.fragment, local);
      transition_in(navigatediff1.$$.fragment, local);
      transition_in(diffhtmlview1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(navigatediff0.$$.fragment, local);
      transition_out(diffhtmlview0.$$.fragment, local);
      transition_out(navigatediff1.$$.fragment, local);
      transition_out(diffhtmlview1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(navigatediff0);
      destroy_component(diffhtmlview0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div3);
      destroy_component(navigatediff1);
      destroy_component(diffhtmlview1);
    }
  };
}
function instance$1f($$self, $$props, $$invalidate) {
  let $store;
  component_subscribe($$self, store, ($$value) => $$invalidate(5, $store = $$value));
  let { withoutStyle = false } = $$props;
  let view1GoToNextDiff, view1GoToPrevDiff, view2GoToNextDiff, view2GoToPrevDiff;
  function diffhtmlview0_withoutStyle_binding(value) {
    withoutStyle = value;
    $$invalidate(0, withoutStyle);
  }
  function diffhtmlview0_goToNextDiff_binding(value) {
    view1GoToNextDiff = value;
    $$invalidate(1, view1GoToNextDiff);
  }
  function diffhtmlview0_goToPrevDiff_binding(value) {
    view1GoToPrevDiff = value;
    $$invalidate(2, view1GoToPrevDiff);
  }
  function diffhtmlview1_withoutStyle_binding(value) {
    withoutStyle = value;
    $$invalidate(0, withoutStyle);
  }
  function diffhtmlview1_goToNextDiff_binding(value) {
    view2GoToNextDiff = value;
    $$invalidate(3, view2GoToNextDiff);
  }
  function diffhtmlview1_goToPrevDiff_binding(value) {
    view2GoToPrevDiff = value;
    $$invalidate(4, view2GoToPrevDiff);
  }
  $$self.$$set = ($$props2) => {
    if ("withoutStyle" in $$props2)
      $$invalidate(0, withoutStyle = $$props2.withoutStyle);
  };
  return [
    withoutStyle,
    view1GoToNextDiff,
    view1GoToPrevDiff,
    view2GoToNextDiff,
    view2GoToPrevDiff,
    $store,
    diffhtmlview0_withoutStyle_binding,
    diffhtmlview0_goToNextDiff_binding,
    diffhtmlview0_goToPrevDiff_binding,
    diffhtmlview1_withoutStyle_binding,
    diffhtmlview1_goToNextDiff_binding,
    diffhtmlview1_goToPrevDiff_binding
  ];
}
class HTMLSideBySideDiff extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1f, create_fragment$1g, safe_not_equal, { withoutStyle: 0 });
  }
}
function create_else_block$l(ctx) {
  let htmlsidebysidediff;
  let current;
  htmlsidebysidediff = new HTMLSideBySideDiff({
    props: { withoutStyle: ctx[1] }
  });
  return {
    c() {
      create_component(htmlsidebysidediff.$$.fragment);
    },
    m(target, anchor) {
      mount_component(htmlsidebysidediff, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const htmlsidebysidediff_changes = {};
      if (dirty & 2)
        htmlsidebysidediff_changes.withoutStyle = ctx2[1];
      htmlsidebysidediff.$set(htmlsidebysidediff_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(htmlsidebysidediff.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(htmlsidebysidediff.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(htmlsidebysidediff, detaching);
    }
  };
}
function create_if_block$z(ctx) {
  let htmlinlinediff;
  let current;
  htmlinlinediff = new HTMLInlineDiff({
    props: { withoutStyle: ctx[1] }
  });
  return {
    c() {
      create_component(htmlinlinediff.$$.fragment);
    },
    m(target, anchor) {
      mount_component(htmlinlinediff, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const htmlinlinediff_changes = {};
      if (dirty & 2)
        htmlinlinediff_changes.withoutStyle = ctx2[1];
      htmlinlinediff.$set(htmlinlinediff_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(htmlinlinediff.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(htmlinlinediff.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(htmlinlinediff, detaching);
    }
  };
}
function create_fragment$1f(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block$z, create_else_block$l];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "flex-grow flex");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance$1e($$self, $$props, $$invalidate) {
  let { inlined } = $$props;
  let { withoutStyle = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("inlined" in $$props2)
      $$invalidate(0, inlined = $$props2.inlined);
    if ("withoutStyle" in $$props2)
      $$invalidate(1, withoutStyle = $$props2.withoutStyle);
  };
  return [inlined, withoutStyle];
}
class ExploreHTMLDiff extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1e, create_fragment$1f, safe_not_equal, { inlined: 0, withoutStyle: 1 });
  }
}
function create_fragment$1e(ctx) {
  let div1;
  let div0;
  let div1_class_value;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      attr(div0, "class", "xindeterminate");
      attr(div1, "class", div1_class_value = "xprogress " + ctx[0]);
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1 && div1_class_value !== (div1_class_value = "xprogress " + ctx2[0])) {
        attr(div1, "class", div1_class_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div1);
    }
  };
}
function instance$1d($$self, $$props, $$invalidate) {
  let { classes: classes2 = "" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("classes" in $$props2)
      $$invalidate(0, classes2 = $$props2.classes);
  };
  return [classes2];
}
class Loader extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1d, create_fragment$1e, safe_not_equal, { classes: 0 });
  }
}
function create_if_block$y(ctx) {
  let div;
  let explorediffheader;
  let updating_inlined;
  let updating_withoutStyle;
  let t;
  let current;
  function explorediffheader_inlined_binding(value) {
    ctx[9](value);
  }
  function explorediffheader_withoutStyle_binding(value) {
    ctx[10](value);
  }
  let explorediffheader_props = {
    class: "mb-4",
    promise: ctx[6],
    showStyleMode: ctx[7]()
  };
  if (ctx[1] !== void 0) {
    explorediffheader_props.inlined = ctx[1];
  }
  if (ctx[2] !== void 0) {
    explorediffheader_props.withoutStyle = ctx[2];
  }
  explorediffheader = new ExploreDiffHeader({ props: explorediffheader_props });
  binding_callbacks.push(() => bind$2(explorediffheader, "inlined", explorediffheader_inlined_binding));
  binding_callbacks.push(() => bind$2(explorediffheader, "withoutStyle", explorediffheader_withoutStyle_binding));
  explorediffheader.$on("close", ctx[5]);
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$7,
    then: create_then_block$7,
    catch: create_catch_block$7,
    blocks: [, , ,]
  };
  handle_promise(ctx[6], info);
  return {
    c() {
      div = element("div");
      create_component(explorediffheader.$$.fragment);
      t = space();
      info.block.c();
      attr(div, "class", "xmodal panel panel-default flex flex-column h-full");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(explorediffheader, div, null);
      append(div, t);
      info.block.m(div, info.anchor = null);
      info.mount = () => div;
      info.anchor = null;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const explorediffheader_changes = {};
      if (!updating_inlined && dirty & 2) {
        updating_inlined = true;
        explorediffheader_changes.inlined = ctx[1];
        add_flush_callback(() => updating_inlined = false);
      }
      if (!updating_withoutStyle && dirty & 4) {
        updating_withoutStyle = true;
        explorediffheader_changes.withoutStyle = ctx[2];
        add_flush_callback(() => updating_withoutStyle = false);
      }
      explorediffheader.$set(explorediffheader_changes);
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(explorediffheader.$$.fragment, local);
      transition_in(info.block);
      current = true;
    },
    o(local) {
      transition_out(explorediffheader.$$.fragment, local);
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(explorediffheader);
      info.block.d();
      info.token = null;
      info = null;
    }
  };
}
function create_catch_block$7(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$7(ctx) {
  let div;
  let current;
  let if_block = ctx[3].diff && create_if_block_1$k(ctx);
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "class", "flex-grow overflow-y-auto");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[3].diff) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$k(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
    }
  };
}
function create_if_block_1$k(ctx) {
  let show_if;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_2$c, create_if_block_3$8];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (show_if == null)
      show_if = !!ctx2[7]();
    if (show_if)
      return 0;
    if (ctx2[3].type === C.TYPE_JSON)
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_3$8(ctx) {
  let explorejsondiff;
  let current;
  explorejsondiff = new ExploreJSONDiff({ props: { inlined: ctx[1] } });
  return {
    c() {
      create_component(explorejsondiff.$$.fragment);
    },
    m(target, anchor) {
      mount_component(explorejsondiff, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const explorejsondiff_changes = {};
      if (dirty & 2)
        explorejsondiff_changes.inlined = ctx2[1];
      explorejsondiff.$set(explorejsondiff_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(explorejsondiff.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(explorejsondiff.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(explorejsondiff, detaching);
    }
  };
}
function create_if_block_2$c(ctx) {
  let explorehtmldiff;
  let updating_withoutStyle;
  let current;
  function explorehtmldiff_withoutStyle_binding(value) {
    ctx[11](value);
  }
  let explorehtmldiff_props = { inlined: ctx[1] };
  if (ctx[2] !== void 0) {
    explorehtmldiff_props.withoutStyle = ctx[2];
  }
  explorehtmldiff = new ExploreHTMLDiff({ props: explorehtmldiff_props });
  binding_callbacks.push(() => bind$2(explorehtmldiff, "withoutStyle", explorehtmldiff_withoutStyle_binding));
  return {
    c() {
      create_component(explorehtmldiff.$$.fragment);
    },
    m(target, anchor) {
      mount_component(explorehtmldiff, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const explorehtmldiff_changes = {};
      if (dirty & 2)
        explorehtmldiff_changes.inlined = ctx2[1];
      if (!updating_withoutStyle && dirty & 4) {
        updating_withoutStyle = true;
        explorehtmldiff_changes.withoutStyle = ctx2[2];
        add_flush_callback(() => updating_withoutStyle = false);
      }
      explorehtmldiff.$set(explorehtmldiff_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(explorehtmldiff.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(explorehtmldiff.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(explorehtmldiff, detaching);
    }
  };
}
function create_pending_block$7(ctx) {
  let loader;
  let current;
  loader = new Loader({});
  return {
    c() {
      create_component(loader.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
    }
  };
}
function create_fragment$1d(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[0] && create_if_block$y(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$y(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$1c($$self, $$props, $$invalidate) {
  let $store;
  let { model } = $$props;
  let { showModal = true } = $$props;
  const store2 = initStore();
  component_subscribe($$self, store2, (value) => $$invalidate(3, $store = value));
  store2.updateStore({
    type: model.get("data_type"),
    uri: model.parent.get("uri")
  });
  function onClose() {
    $$invalidate(0, showModal = false);
    destroyStore();
  }
  let promise = store2.fetchSieveData(model.parent.id, model.id);
  let inlined = false;
  let withoutStyle = false;
  function isHTML() {
    return [C.TYPE_DOC, C.TYPE_HTML, C.TYPE_PDF_HTML].includes($store.type);
  }
  function explorediffheader_inlined_binding(value) {
    inlined = value;
    $$invalidate(1, inlined);
  }
  function explorediffheader_withoutStyle_binding(value) {
    withoutStyle = value;
    $$invalidate(2, withoutStyle);
  }
  function explorehtmldiff_withoutStyle_binding(value) {
    withoutStyle = value;
    $$invalidate(2, withoutStyle);
  }
  $$self.$$set = ($$props2) => {
    if ("model" in $$props2)
      $$invalidate(8, model = $$props2.model);
    if ("showModal" in $$props2)
      $$invalidate(0, showModal = $$props2.showModal);
  };
  return [
    showModal,
    inlined,
    withoutStyle,
    $store,
    store2,
    onClose,
    promise,
    isHTML,
    model,
    explorediffheader_inlined_binding,
    explorediffheader_withoutStyle_binding,
    explorehtmldiff_withoutStyle_binding
  ];
}
class ExploreDiff extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1c, create_fragment$1d, safe_not_equal, { model: 8, showModal: 0 });
  }
}
const Backbone$6 = window.Backbone;
const feeddiff = window.feeddiff;
if (!feeddiff) {
  throw new Error("ADD feeddiff");
}
const PREFS_DEFAULT = {
  snipped: false,
  removed: false
};
var DiffableView = View$1.Base.extend({
  initialize: function(options) {
    DiffableView.__super__.initialize.call(this, options);
    this.oldModel = options.oldModel;
  },
  getDiffCount: function() {
    return [0, 0];
  },
  getDiffCount: function() {
    return [0, 0];
  },
  setState: function(state) {
    this.state = state;
    this.show(state);
  },
  show: function(state) {
    if (!state.diff) {
      return this.render();
    }
    const model = this.model;
    Msg.start("diff", { info: "l_loading" });
    try {
      const dmp = new diff_match_patch();
      const text_new = model.get("data");
      const text_old = (this.oldModel || model).get("data");
      const diffs = dmp.diff_main(text_old, text_new);
      dmp.diff_cleanupSemantic(diffs);
      this.$el.empty().append(dmp.diff_prettyHtml(diffs));
    } catch (e) {
      this.$el.empty().append("Error showing diff: ", e.message).append(e.stack);
    }
    Msg.stop("diff");
  },
  showDiffModal: function() {
    throw new Error("Not implemented");
  }
});
const SieveFeedView = DiffableView.extend({
  name: "SieveFeedView",
  tagName: "iframe",
  attributes: {
    frameborder: 0,
    style: "width:100%;height:80px"
  },
  onFrameLoad: function() {
    this.el.style.height = this.el.contentDocument.documentElement.scrollHeight + "px";
    this.frame_loaded = true;
    this.trigger("frame_loaded");
  },
  getDiffCount: function() {
    return [this.newFeedCount, this.updatedFeedCount];
  },
  postInit: function() {
    this.el.onload = this.onFrameLoad;
  },
  show: function(state) {
    if (!this.frame_loaded) {
      this.once("frame_loaded", () => this.show(state));
      return;
    }
    const feedNew = JSON.parse(this.model.get("data"));
    const feedOld = this.oldModel && JSON.parse(this.oldModel.get("data"));
    const feedDict = {};
    new DOMParser();
    const style = document.createElement("style");
    this.el.contentDocument;
    let css;
    feedDict["newHashedFeed"] = feedNew;
    feedDict["oldHashedFeed"] = feedOld;
    css = ".inserted{background-color:#b7fdcb;}";
    css += ".removed{background-color:#ff9494;}";
    css += "img{margin-top:2px;margin-bottom:5px;}";
    css += state.removed ? ".removed{display:inline}" : ".removed{display:none}";
    css += "body{width:700px;margin:0 auto;padding:0 10px;}";
    css += ".summary{padding-top:5px;}";
    style.type = "text/css";
    $(style).attr("class", "xdistill").text(css);
    feeddiff.getUpdatedEntries(Diff.diffHtml, feedDict, this.model.id, (err, result) => {
      if (err) {
        console.error("Error in update feed: ", err);
        Msg.error("Error finding changes in feed");
        return;
      }
      if (result["changes"].length == 0) {
        result.changes = feedDict.newHashedFeed.entries;
      } else {
        result.changes = result["newEntries"].concat(result["updatedEntries"]);
      }
      this.newFeedCount = result["newEntries"].length;
      this.updatedFeedCount = result["updatedEntries"].length;
      const view = new View.FeedEntryList({
        model: new Model$1.FeedEntryCollection(result.changes)
      }).render();
      view.$el.append(style);
      this.once("frame_loaded", () => this.bubbleEvent("sieve:data:loaded"));
      this.el.setAttribute("srcdoc", view.el.outerHTML);
    });
  }
});
var SieveXMLView = DiffableView.extend({
  name: "SieveXMLView",
  postInit: function(options) {
    SieveXMLView.__super__.postInit.call(this, options);
    this.show({ diff: true });
    _.defer(() => this.bubbleEvent("sieve:data:loaded"));
  }
});
var SieveJSONView = DiffableView.extend({
  name: "SieveJSONView",
  getDiffCount() {
    return [this.additions, this.deletions];
  },
  show(state) {
    if (this.view) {
      this.view.full = !state.snipped;
      this.view.pruneDeletions = !state.removed;
    } else {
      let newJson = JSON.parse(this.model.get("data"));
      let oldJson = this.oldModel && JSON.parse(this.oldModel.get("data"));
      this.view = new JSONDiffView({
        target: this.el,
        props: {
          oldJson,
          newJson,
          full: !state.snipped,
          pruneDeletions: !state.removed,
          showDirty: !state.snipped,
          class: "ml-20 pr-10 my-10 w-auto max-h-[40vh] overflow-scroll"
        }
      });
      (async () => {
        await this.view.jsonDiffPromise;
        this.additions = this.view.additions;
        this.deletions = this.view.deletions;
        _.defer(() => this.bubbleEvent("sieve:data:loaded"));
      })();
    }
  },
  showDiffModal: function() {
    this.diffModal = new ExploreDiff({
      target: document.querySelector("body"),
      props: {
        model: this.model
      }
    });
  },
  remove() {
    SieveJSONView.__super__.remove.call(this);
    if (this.diffModal) {
      this.diffModal.$destroy();
    }
  }
});
const SieveHTMLView = DiffableView.extend({
  name: "SieveHTMLView",
  attributes: {
    src: window.IE ? `javascript:document.write('<script>document.open();document.domain="` + document.domain + `";document.close();<\/script>')` : "about:blank",
    frameborder: 0,
    style: "width:100%;height:40px"
  },
  tagName: "iframe",
  getDiffCount: function() {
    return [$(this.doc).find(".inserted").length, $(this.doc).find(".removed").length];
  },
  postInit: function() {
    this.showingDiff = false;
    this.el.onload = this.onFrameLoad;
    this.sieve = this.model.parent;
    this.model.get("text");
    this.el.style.height = "40px";
  },
  onFrameLoad: function() {
    this.frameReady = true;
    this.trigger("frame_ready");
    $(this.el.contentDocument).on("click", function(e) {
      const href2 = e.target.href || "";
      if (href2.slice(0, 11) == "javascript:") {
        e.preventDefault();
      }
    });
  },
  onFrameReady: function(callback) {
    try {
      this.frameReady ? callback() : this.once("frame_ready", callback);
    } catch (e) {
      console.error("Error calling frame ready callback", e);
    }
  },
  renderHTML: function(html2, state) {
    this.model.id;
    let nSyncs = 0;
    const host = this.el;
    const win = host.contentWindow;
    const doc = win.document;
    const el = doc.documentElement;
    const uri = this.sieve.get("uri");
    updateFrameContent(doc, uri, html2);
    async.map($(el).find("link[rel=stylesheet]").toArray(), function(link, callback) {
      const img = doc.createElement("img");
      img.onerror = function() {
        callback();
      };
      img.src = link.href;
    }, (err, res2) => {
      if (this.syncIntervalId)
        clearInterval(this.syncIntervalId);
      this.syncIntervalId = setInterval(() => {
        try {
          const win2 = host.contentWindow;
          if (!win2 || !win2.document) {
            clearInterval(this.syncIntervalId);
            return;
          }
          const iframeRoot = win2.document.body || el;
          const height = Math.min(1e4, Math.max(el.scrollHeight, iframeRoot.scrollHeight));
          if (height > win2.innerHeight) {
            host.style.height = height + "px";
          }
          nSyncs += 1;
          if (nSyncs > 10)
            clearInterval(this.syncIntervalId);
        } catch (e) {
          clearInterval(this.syncIntervalId);
          throw e;
        }
      }, 100);
    });
    setTimeout(() => {
      this.$("span").css({ left: 0, position: "relative" });
      $(el).find("a[href]").attr("target", "_blank").attr("rel", "noopener");
      this.bubbleEvent("sieve:data:loaded");
    }, 200);
  },
  show: async function(state) {
    this.state = state;
    if (this.shown) {
      return this.doc && this.showDoc(state);
    }
    this.shown = true;
    Msg.start("diff", { info: "l_loading" });
    const newHtml = this.model.get("data");
    const oldHtml = this.oldModel.get("data");
    const parser = new DOMParser();
    let showHTML = (data) => {
      this.markedHTML = data;
      this.doc = parser.parseFromString(data, "text/html");
      if (this.doc.querySelectorAll(".inserted,.removed").length == 0) {
        this.markedHTML = newHtml;
        this.doc = parser.parseFromString(newHtml, "text/html");
      }
      this.showDoc(this.state);
      Msg.stop("diff");
    };
    if (newHtml == oldHtml) {
      return showHTML(newHtml);
    }
    try {
      let { diff } = await Diff.diffHtml(oldHtml, newHtml, this.model.id);
      showHTML(diff);
    } catch (e) {
      console.error("Error ", e);
      showHTML(newHtml);
    }
  },
  showDoc: function(state) {
    const doc = this.doc;
    const style = this.styleSheet || doc.createElement("style");
    let css = "";
    let html2;
    css = ".inserted{background-color:#b7fdcb;}";
    css += ".removed{background-color:#ff9494;}";
    css += "span.inserted, span.removed{padding: 1px 4px;}";
    css += "a.removed, a .removed{color: #008}";
    css += "img.inserted{border: solid 2px green; background-color: transparent; padding: 2px;}";
    css += "img.removed{border: solid 2px red; background-color: transparent; padding: 2px;}";
    css += "[hidden]{display:block;}";
    css += state.removed ? ".removed{display:inline}" : ".removed{display:none}";
    if (state.snipped) {
      css += ".nonDiffHide {display:none}";
      this.srcStylesheet = doc.querySelectorAll("link[rel=stylesheet], style:not(.xdistill)");
      $(this.srcStylesheet).remove();
      this.styledElements2 = $(doc).find("[style]").each(function() {
        this.dataset.oldStyle2 = this.getAttribute("style");
        this.removeAttribute("style");
      });
      this.snippedHeight && this.$el.height(this.snippedHeight);
    } else {
      this.snippedHeight = this.snippedHeight || this.$el.height();
      $(doc).find("head").append(this.srcStylesheet);
      this.styledElements2 && this.styledElements2.each(function() {
        this.setAttribute("style", this.dataset.oldStyle2);
      });
    }
    if (!$(doc).find('link[rel="stylesheet"], style:not(.xdistill)').length) {
      css += "body {padding: 10px;}";
      css += "td {padding: 10px}";
      css += "body {font-size: 0.94em}";
    }
    style.type = "text/css";
    $(style).attr("class", "xdistill").text(css);
    doc.body.appendChild(style);
    this.styleSheet = style;
    html2 = doc.documentElement.outerHTML;
    this.onFrameReady(() => this.renderHTML(html2, state));
  },
  showDiffModal: function() {
    this.diffModal = new ExploreDiff({
      target: document.querySelector("body"),
      props: {
        model: this.model
      }
    });
  },
  remove: function() {
    SieveHTMLView.__super__.remove.call(this);
    if (this.diffModal) {
      this.diffModal.$destroy();
    }
  }
});
const DiffPrefMenu = View$1.ContextMenu.extend({
  name: "DiffPrefMenu",
  events: {
    "change input": "event_change"
  },
  event_change: function(e) {
    e.stopPropagation();
    this.save();
  },
  getPrefs: function() {
    const prefs = {};
    this.$(":checkbox").each(function(_2, el) {
      prefs[el.name] = el.checked ? 1 : 0;
    });
    return prefs;
  },
  load: async function() {
    try {
      let res2 = await Api.api("/users/prefs/ui_diff", "GET");
      this.showPrefs(res2);
    } catch (err) {
      console.error("Failed to get prefs", err);
      this.showApiErr();
    }
    this.show();
  },
  renderMenu: function() {
    this.load();
    this.$el.empty().append(LI({ "class": "xview" }, DIV(T("l_loading"), "...")));
  },
  save: async function() {
    const prefs = this.getPrefs();
    try {
      await Api.api("/users/prefs/ui_diff", "PUT", prefs);
      USER.prefs.ui_diff = prefs;
      if (Supports.agents.local) {
        await Service.SyncMan.get(Service.store.UserStore);
      }
    } catch (err) {
      Msg.error("e_req");
    }
  },
  showApiErr: function(err) {
    this.$el.empty().append(LI({ "class": "xview error" }, DIV("Couldn't get prefs. ", A({ href: "/ui/settings.html#general" }, "Sign in to account."))));
  },
  showPrefs: function(prefs) {
    const tid = Date.now() * Math.random() | 0;
    _.defaults(prefs, PREFS_DEFAULT);
    this.$el.empty().append(LI({ "class": "xview" }, DIV({ style: "font-size: 1.1em; " }, T("Defaults")), DIV(INPUT({
      id: "removed" + tid,
      name: "removed",
      type: "checkbox",
      style: "position: relative; top: 2px;"
    }), LABEL({
      "for": "removed" + tid,
      "style": "margin:0 4px;padding:0;font-size:.9em; user-select: none;"
    }, T("Deleted"))), DIV(INPUT({
      id: "snipped" + tid,
      name: "snipped",
      type: "checkbox",
      style: "position: relative; top: 2px;"
    }), LABEL({
      "for": "snipped" + tid,
      "style": "margin:0 4px;padding:0;font-size:.9em; user-select: none;"
    }, T("Snipped")))));
    this.$(":checkbox").each(function(_2, el) {
      const checked = prefs[el.name];
      if (checked) {
        el.checked = 1;
      }
    });
  }
});
let diffMenu;
const BaseDiffBar = View$1.Base.extend({
  event_settings: function(e) {
    if (diffMenu && diffMenu.el.parentNode) {
      diffMenu.remove();
      diffMenu = null;
    } else {
      (diffMenu = new DiffPrefMenu({
        parent: this
      })).toggle(this.name, e.currentTarget);
    }
  }
});
const FeedBar = BaseDiffBar.extend({
  name: "FeedBar",
  events: {
    "click .xsettings": "event_settings",
    "click .xremoved": "event_show_removed"
  },
  event_show_removed: function(e) {
    this.state.removed = e.target.checked;
    this.updateState();
  },
  postInit: function(options) {
    this.state = _.extend({}, PREFS_DEFAULT, USER.prefs.ui_diff);
    this.view = options.view;
    this.view.setState(this.state);
  },
  render: function() {
    const tid = Date.now() * Math.random() | 0;
    this.$el.css({
      position: "absolute",
      right: 1,
      borderBottom: "solid 1px #ddd",
      backgroundColor: "#f3f3f3",
      backgroundColor: "#f0f0f0",
      marginTop: "-4px",
      padding: 0
    }).append(DIV({ "class": "inline-block" }, DIV({ "class": "btn", "style": "padding:0 6px;", "title": "Shows the number of new and updated feeds" }, SPAN({ style: "font-weight: bold;" }, this.elNewFeed = SPAN(0), " new, "), " ", SPAN({ style: "font-weight: bold;", title: "Shows the number of new and updated feeds" }, this.elChangedFeed = SPAN(0), " updated. ")), INPUT({ "class": "xremoved", "type": "checkbox", "id": "show-del" + tid }), LABEL({
      "for": "show-del" + tid,
      "style": "margin:0 4px;font-size:.9em; user-select: none;",
      "title": "Shows deleted content in changed feed entry"
    }, "Deleted"), BUTTON({
      "class": "btn btn-default btn-sm xsettings",
      "style": "min-width:20px;padding:0;margin:0;"
    }, I({ "class": "fa fa-cog" }))));
    return this;
  },
  setDiffCount: function(feedCount) {
    this.elNewFeed.textContent = Math.min(feedCount[0], 999);
    this.elChangedFeed.textContent = Math.min(feedCount[1], 999);
  },
  updateState: function() {
    this.$(".xremoved").prop("checked", this.state.removed);
    this.view.setState(this.state);
  }
});
const DiffBar = BaseDiffBar.extend({
  name: "DiffBar",
  events: {
    "click .xpopup": "event_popup",
    "click .xsettings": "event_settings",
    "click .xsnipped": "event_show_snipped",
    "click .xremoved": "event_show_removed"
  },
  event_popup: function(e) {
    this.popWindow(e);
  },
  event_show_removed: function(e) {
    this.state.removed = e.target.checked;
    this.updateState();
  },
  event_show_snipped: function(e) {
    this.state.snipped = e.target.checked;
    this.updateState();
  },
  postInit: function(options) {
    this.state = _.extend({}, PREFS_DEFAULT, USER.prefs.ui_diff);
    this.view = options.view;
    this.view.setState(this.state);
  },
  render: function() {
    const tid = Date.now() * Math.random() | 0;
    this.$el.css({
      position: "absolute",
      right: 1,
      borderBottom: "solid 1px #ddd",
      backgroundColor: "#f3f3f3",
      backgroundColor: "#f0f0f0",
      marginTop: "-4px",
      padding: 0
    }).append(DIV({ "class": "inline-block" }, A({
      "class": "btn btn-default btn-sm xpopup",
      "style": "padding:0 6px; margin-right: 4px;"
    }, T("Explore diff (beta)"), " ", SPAN({ style: "color: green;font-weight: bold;" }, this.elPlus = SPAN(0), "+"), " ", SPAN({ style: "color: red;font-weight: bold;" }, this.elMinus = SPAN(0), SPAN({ style: "font-size: 1.1em; line-height: 1.1" }, "\u2013"))), INPUT({
      "id": "removed" + tid,
      "class": "xremoved",
      "name": "removed",
      "type": "checkbox",
      "style": "position: relative; top: 2px;"
    }), LABEL({
      "for": "removed" + tid,
      "style": "margin:0 4px;padding:0;font-size:.9em; user-select: none;"
    }, T("Deleted")), INPUT({
      "id": "snipped" + tid,
      "class": "xsnipped",
      "name": "snipped",
      "type": "checkbox",
      "style": "position: relative; top: 2px;"
    }), LABEL({
      "for": "snipped" + tid,
      "style": "margin:0 4px;padding:0;font-size:.9em; user-select: none;"
    }, T("Snipped")), BUTTON({
      "class": "btn btn-default btn-sm xsettings",
      "style": "min-width:20px;padding:0;margin:0;"
    }, I({ "class": "fa fa-cog" }))));
    this.$(":checkbox").each((_2, el) => {
      if (this.state[el.name]) {
        el.checked = true;
      }
    });
    return this;
  },
  setDiffCount: function(diffCounts) {
    this.elPlus.textContent = Math.min(diffCounts[0], 999);
    this.elMinus.textContent = Math.min(diffCounts[1], 999);
    if (diffCounts[0] + diffCounts[1] == 0) {
      this.$(".xpopup,.xsnipped,.xremoved").attr("disabled", 1);
    }
  },
  updateState: function() {
    this.$(".xsnipped").prop("checked", this.state.snipped);
    this.$(".xremoved").prop("checked", this.state.removed);
    this.view.setState(this.state);
  },
  popWindow: function(event) {
    this.view.showDiffModal();
  }
});
const DiffHTMLView = View$1.Base.extend({
  attributes: {
    style: "width: 100%;"
  },
  getScrollHeight: function() {
    return this.frameReady ? this.iframe.contentWindow.document.body.scrollHeight : 400;
  },
  toggleStyle: function(flag) {
    this.onFrameReady(() => {
      const doc = this.iframe.contentWindow.document;
      if (flag) {
        this.styleSheets = doc.querySelectorAll("link[rel=stylesheet],style:not(.xdistill)");
        $(this.styleSheets).remove();
        this.styledElements = $(doc).find("[style]").each(function() {
          this.dataset.oldStyle = this.getAttribute("style");
          this.removeAttribute("style");
        });
      } else {
        $(doc.head).append(this.styleSheets);
        this.styledElements.each(function() {
          this.setAttribute("style", this.dataset.oldStyle);
        });
      }
    });
  },
  hideRemoved: function() {
    this.onFrameReady(() => {
      $(this.iframe.contentWindow.document).find(".removed").addClass("xdistill-hide");
    });
  },
  hideInserted: function() {
    this.onFrameReady(() => {
      $(this.iframe.contentWindow.document).find(".inserted").addClass("xdistill-hide");
    });
  },
  moveToNextDiff: function() {
    let count2 = 0;
    const scrollCt = this.options.scrollCt;
    const scrollTop = scrollCt.scrollTop;
    const viewportHeight = $(scrollCt).height();
    const elements = $(this.iframe.contentWindow.document).find(".diffMark:visible");
    while (count2 < elements.length && elements.eq(count2++).offset().top - scrollTop < viewportHeight)
      ;
    count2 -= 1;
    if (elements[count2]) {
      elements[count2].scrollIntoView({ behavior: "smooth" });
      return true;
    }
    return false;
  },
  moveToPrevDiff: function() {
    const scrollCt = this.options.scrollCt;
    const scrollTop = scrollCt.scrollTop;
    $(scrollCt).height();
    const element2 = $(this.iframe.contentWindow.document).find(".diffMark:visible");
    let count2 = element2.length;
    while (--count2 > 0 && element2.eq(count2).offset().top + element2.eq(count2).height() > scrollTop)
      ;
    element2[count2].scrollIntoView({ behavior: "smooth" });
  },
  onFrameReady: function(callback) {
    try {
      this.frameReady ? callback() : this.once("frame_ready", callback);
    } catch (e) {
      console.error("Error calling frame ready callback", e);
    }
  },
  onViewReady: function(callback) {
    try {
      this.viewReady ? callback() : this.once("view_ready", callback);
    } catch (e) {
      console.error("Error calling view ready callback", e);
    }
  },
  render: function() {
    const iframe = IFRAME({ "class": "data-pad", "width": "100%", "scrolling": "no", "style": "border: none;" });
    this.iframe = iframe;
    this.$el.append(iframe);
    iframe.onload = () => {
      this.frameReady = true;
      this.trigger("frame_ready");
    };
    this.onFrameReady(this.renderFrameContent);
    return this;
  },
  renderFrameContent: function() {
    const sieve = this.options.model.parent;
    const html2 = this.options.html;
    const doc = this.iframe.contentWindow.document;
    const style = doc.createElement("style");
    updateFrameContent(doc, sieve.get("uri"), html2);
    $(style).attr({
      "class": "xdistill",
      "type": "text/css"
    }).text(".removed {background-color:#ff9494; display:inline !important}a.removed, a .removed {color: #008}.inserted {background-color:#b7fdcb; display:inline !important}span.inserted, span.removed{padding: 1px 4px;}.xdistill-hide {display: none !important} img.inserted{border: solid 2px green; background-color: transparent; padding: 2px;}img.removed{border: solid 2px red; background-color: transparent; padding: 2px;}[hidden]{display:block;}");
    $(doc).find("body").append(style);
    const cssLinks = $(doc).find('link[rel="stylesheet"]');
    async.each(cssLinks, function(link, callback) {
      link.addEventListener("load", callback);
    }, (err, res2) => {
      this.viewReady = true;
      this.trigger("view_ready");
    });
  },
  scrollFirstDiffIntoView: function() {
    const el = $(this.iframe.contentWindow.document).find(".diffMark:visible")[0];
    if (el) {
      el.scrollIntoView({ behavior: "smooth" });
      return true;
    }
    return false;
  },
  setFrameHeight: function(height) {
    $(this.iframe).css("height", height);
  },
  showDiff: function() {
    this.onFrameReady(() => {
      $(this.iframe.contentWindow.document).find(".inserted").removeClass("xdistill-hide");
      $(this.iframe.contentWindow.document).find(".removed").removeClass("xdistill-hide");
    });
  }
});
View$1.Modal.extend({
  events: {
    "click .xdiff-toggle-mode": "toggleMode",
    "click .xdiff-toggle-style": "toggleStyle",
    "click .xleft-frame-up": "moveToPrevDiffLeftEle",
    "click .xleft-frame-down": "moveToNextDiffLeftEle",
    "click .xright-frame-up": "moveToPrevDiffRightEle",
    "click .xright-frame-down": "moveToNextDiffRightEle"
  },
  headerClass: "panel-heading xpanel-heading-alt",
  showSplitView: function() {
    this.view1.$el.parent().css("width", "50%");
    this.view2.$el.parent().css("width", "50%");
    $(this.elView2).show();
    this.view1.hideRemoved();
    this.view2.hideInserted();
    $(this.toolbarView1).css("right", "51%");
    this.syncHeight();
  },
  showInlinedView: function() {
    this.view1.$el.parent().css("width", "100%");
    $(this.elView2).hide();
    this.view1.showDiff();
    $(this.toolbarView1).css("right", "10px");
    this.syncHeight();
  },
  syncHeight: function() {
    const height = Math.max(this.view1.getScrollHeight(), this.view2.getScrollHeight());
    this.view1.setFrameHeight(height);
    this.view2.setFrameHeight(height);
    $(this.scrollCt).css("height", $(window).height() - this.scrollCt.getBoundingClientRect().y);
  },
  toggleMode: function(event) {
    this.isModeInlined = !this.isModeInlined;
    this[this.isModeInlined ? "showInlinedView" : "showSplitView"]();
    const tb = $(event.currentTarget);
    tb.find(".active").removeClass("active").removeClass("btn-primary");
    tb.find(this.isModeInlined ? ".xdiff-mode-inlined" : ".xdiff-mode-sbs").addClass("active btn-primary");
    this.syncHeight();
  },
  toggleStyle: function(event) {
    this.isStyleRemoved = !this.isStyleRemoved;
    this.view1.toggleStyle(this.isStyleRemoved);
    this.view2.toggleStyle(this.isStyleRemoved);
    const tb = $(event.currentTarget);
    tb.find(".active").removeClass("active").removeClass("btn-primary");
    tb.find(this.isStyleRemoved ? ".xdiff-style-restore" : ".xdiff-style-remove").addClass("active btn-primary");
    this.syncHeight();
  },
  moveToPrevDiffLeftEle: function() {
    this.view1.moveToPrevDiff();
  },
  moveToNextDiffLeftEle: function() {
    this.view1.moveToNextDiff();
  },
  moveToPrevDiffRightEle: function() {
    this.view2.moveToPrevDiff();
  },
  moveToNextDiffRightEle: function() {
    this.view2.moveToNextDiff();
  },
  renderHeader: function() {
    let header;
    header = DIV(DIV({ "class": "xtbar xvbar-margin pull-right" }, BUTTON({
      "class": "close",
      "data-action": "modal close",
      "title": T("a_window_close")
    }, "\u2715")), DIV({ "class": "xtbar xvbar-margin" }, DIV({ "class": "btn-group btn-toggle xdiff-toggle-mode" }, BUTTON({ "class": "btn btn-default xdiff-mode-sbs btn-primary active" }, T("Side-by-side diff")), BUTTON({ "class": "btn btn-default xdiff-mode-inlined" }, T("Inlined diff"))), DIV({ "class": "btn-group btn-toggle xdiff-toggle-style" }, BUTTON({ "class": "btn btn-default xdiff-style-remove btn-primary active" }, T("Styled Page")), BUTTON({ "class": "btn btn-default xdiff-style-restore" }, T("Unstyled Page"))), A({ "href": this.model.parent.get("uri"), "class": "btn btn-default", "target": "_blank", "rel": "noopener" }, I({ "class": "fa fa-external-link" }))));
    return header;
  },
  renderView: function() {
    const el = DIV({ "style": "overflow-y: scroll;" }, this.elView1 = DIV({ style: "width: 50%; height: 100%; float: left" }, this.toolbarView1 = DIV({ "class": "btn-group", "style": "position: fixed; right: 51%" }, BUTTON({ "class": "btn btn-default xleft-frame-up" }, I({ "class": "fa fa-chevron-up" })), BUTTON({ "class": "btn btn-default xleft-frame-down" }, I({ "class": "fa fa-chevron-down" })))), this.elView2 = DIV({ style: "width: 50%; height: 100%; float:right;" }, DIV({ "class": "btn-group", "style": "position: fixed; right: 15px;" }, BUTTON({ "class": "btn btn-default xright-frame-up" }, I({ "class": "fa fa-chevron-up" })), BUTTON({ "class": "btn btn-default xright-frame-down" }, I({ "class": "fa fa-chevron-down" })))));
    this.scrollCt = el;
    this.view1 = new DiffHTMLView({
      parent: this.parent,
      model: this.model,
      html: this.options.html,
      scrollCt: el
    }).render();
    this.elView1.appendChild(this.view1.el);
    this.view2 = new DiffHTMLView({
      parent: this.parent,
      model: this.model,
      html: this.options.html,
      scrollCt: el
    }).render();
    this.elView2.appendChild(this.view2.el);
    this.view1.hideRemoved();
    this.view2.hideInserted();
    this.view1.onViewReady(onViewReady);
    this.view2.onViewReady(onViewReady);
    const self = this;
    function onViewReady() {
      if (self.view1.frameReady && self.view2.frameReady) {
        self.syncHeight();
        $(self.view2.iframe).css("border-left", "solid 1px #666");
        if (!self.view1.scrollFirstDiffIntoView()) {
          self.view2.scrollFirstDiffIntoView();
        }
      }
      $(window).resize(self.syncHeight);
      self.on("remove", function() {
        $(window).off("resize", self.syncHeight);
      });
    }
    return el;
  }
});
const SieveToolbar = View$1.ActionProvider.extend({
  actions: {
    list_view: { fn: "action_list_view" }
  },
  action_list_view() {
    let team2 = get_store_value(params).team;
    push$1(`/w/${team2}/list/all/`);
  },
  render: function() {
    let module = get_store_value(params).module;
    this.$el.empty().append(DIV({ "class": "form-actions btn-toolbar flex align-item justify-center pa3" }, BUTTON({
      "class": "btn btn-default ",
      "data-action": "sieve more data"
    }, T("Show More")), BUTTON({
      "class": "btn btn-default ",
      "data-action": "sieve edit"
    }, T(T("a_edit_options"))), BUTTON({
      "class": "btn btn-default",
      "data-action": module == "list" ? "sieve view" : "list_view"
    }, T("Close"))));
    return this;
  }
});
const SieveDataView = View$1.Base.extend({
  name: "SieveDataView",
  className: "xsieve-data-item",
  action_email: async function() {
    Msg.info("loading");
    let res2 = await Api.api("/users/attrs", { name: "email", state: 40 });
    Msg.reset();
    const select = SELECT(res2.data.map((attr2) => OPTION({ value: attr2.value }, attr2.value)));
    const view = new View$1.Base({
      el: DIV({ style: "margin: 5px;" }, select)
    });
    const modal = new View$1.SaveDiscardModal({
      name: "SieveData$Email",
      parent: this,
      title: "Email",
      a_save: "Send",
      view
    });
    modal.on("save", async () => {
      try {
        let doc1 = this.view.el.contentDocument.cloneNode(true);
        setDiffStyle(doc1);
        await Api.api("/agents/actions/email", "POST", {
          action: { config: { email: select.value } },
          sieve: this.model.parent.pick("id", "name", "uri", "ts"),
          sieve_data: this.model.pick("id", "text", "ts"),
          emailContent: `<div id="highlighted-inlined"
            style="padding: 10px; background-color: #fff">
            ${doc1.body.innerHTML}
          </div>`,
          hasDiff: true
        });
        modal.remove();
      } catch (e) {
        console.error(e);
        Msg.error(`Please try again later - error in batch action ${e.message || e.msg}`);
      }
    });
    modal.on("discard", () => modal.remove());
    modal.show();
  },
  createView: function() {
    const model = this.model;
    const oldModel = this.options.oldModel;
    const opts = {
      index: this.options.index,
      parent: this,
      model,
      oldModel
    };
    switch (model.get("data_type")) {
      case C.TYPE_HTML:
        return new SieveHTMLView(opts);
      case C.TYPE_FEED:
        return new SieveFeedView(opts);
      case C.TYPE_XML:
        return new SieveXMLView(opts);
      case C.TYPE_PDF_HTML:
        return new SieveHTMLView(opts);
      case C.TYPE_DOC:
        return new SieveHTMLView(opts);
      case C.TYPE_JSON:
        return new SieveJSONView(opts);
      default:
        return new Backbone$6.View({
          el: SPAN("ERR! Unknown data type")
        });
    }
  },
  onViewLoad: function() {
    this.bubbleEvent("sieve:data:loaded");
    this.diffBar && this.diffBar.setDiffCount(this.view.getDiffCount());
  },
  postInit: function() {
    this.view = this.createView();
    this.view.on("sieve:data:loaded", this.onViewLoad);
    if (this.model.get("data_type") == C.TYPE_FEED) {
      this.diffBar = new FeedBar({ parent: this, view: this.view });
    }
    if (this.model.get("data_type") == C.TYPE_HTML) {
      this.diffBar = new DiffBar({ parent: this, view: this.view });
    }
    if (this.model.get("data_type") == C.TYPE_DOC) {
      this.diffBar = new DiffBar({ parent: this, view: this.view });
    }
    if (this.model.get("data_type") == C.TYPE_PDF_HTML) {
      this.diffBar = new DiffBar({ parent: this, view: this.view });
    }
    if (this.model.get("data_type") == C.TYPE_JSON) {
      this.diffBar = new DiffBar({ parent: this, view: this.view });
    }
    this.listenTo(this.model, "destroy", this.remove);
  },
  render: function() {
    const ts_mod = moment(this.model.get("ts_mod"));
    let aCollapseExpand, aSendEmail;
    this.$el.empty().append(this.diffBar ? this.diffBar.render().el : "", DIV({ style: "display:flex;margin:4px 0;" }, DIV({ style: "margin-right:10px;", title: ts_mod.format() }, aCollapseExpand = A({ href: "#" }, I({ "class": "fa fa-caret-down f4" }), " ", ts_mod.format("hh:mm A")), DIV({ style: "position: relative" }, A({
      href: "#",
      "class": "dropdown-toggle",
      "data-toggle": "dropdown"
    }, I({ "class": "fa fa-caret-down f4" }), " ", ts_mod.format("MMM DD")), UL({ "class": "dropdown-menu", "role": "menu" }, LI(aSendEmail = A({
      tabindex: -1,
      href: "#"
    }, T("Email")))))), DIV({ "style": "flex:1;background-color:#fff;border-bottom:solid 1px #ccc;" }, DIV({
      "style": "flex:1;background-color:#fff;border-bottom:solid 1px #ccc;"
    }, this.view.render().el))));
    $(aCollapseExpand).click((e) => {
      e.preventDefault();
      this.collapsed = !this.collapsed;
      $(aCollapseExpand).find(".fa").toggleClass("fa-caret-right").toggleClass("fa-caret-down");
      this.view.$el[this.collapsed ? "hide" : "show"]();
    });
    $(aSendEmail).click((e) => {
      e.preventDefault();
      this.action_email();
    });
    return this;
  }
});
const SieveDataList = View$1.ActionProvider.extend({
  name: "SieveDataList",
  fetch: async function() {
    const $btn = this.$('[data-action="sieve more data"]');
    const $msg = this.$(".xmsg");
    const init2 = !this.lastData;
    const limit = init2 ? this.options.initialFetchCount || 2 : 2;
    const query = { _opt: { limit } };
    if (!init2) {
      query["ts.lt"] = this.lastData.ts;
    }
    $btn.button("loading");
    Msg.start("sieve:data:fetch", { info: "l_loading" });
    try {
      let res2 = await Api.api("/sieves/" + this.model.id + "/data", "GET", query);
      $btn.button("reset");
      const currentData = this.data;
      const newData = res2.data;
      let dataToDisplay = [];
      Msg.stop("sieve:data:fetch");
      if (init2 && res2.count == 0) {
        this.$data.append(DIV({ "class": "xinfo" }, T("m_history_empty")));
        this.removeProgress();
        return;
      }
      $msg.removeClass("hide").find(".info > span").text(res2.count);
      if (init2) {
        dataToDisplay = newData.slice(0);
        if (dataToDisplay.length > limit - 1) {
          dataToDisplay.pop();
        }
      } else {
        if (this.lastData.id != this.lastDisplayedData.id) {
          dataToDisplay.push(currentData[currentData.length - 1]);
        }
        if (newData.length > 1) {
          dataToDisplay = dataToDisplay.concat(newData);
          dataToDisplay.pop();
        }
      }
      if (newData.length > 0) {
        this.lastData = newData[newData.length - 1];
      }
      for (let i2 = 0; i2 < dataToDisplay.length; i2 += 1) {
        this.addDataView(dataToDisplay[i2], dataToDisplay[i2 + 1] || this.lastData, i2);
      }
      if (dataToDisplay.length > 0) {
        this.lastDisplayedData = dataToDisplay[dataToDisplay.length - 1];
      }
      this.data = currentData.concat(newData);
      if (res2.count == 0) {
      }
    } catch (err) {
      this.removeProgress();
      return Msg.stop("sieve:data:fetch", { error: "err:sieve:data:fetch" });
    }
  },
  addDataView: function(data, oldData, index2) {
    const model = new Backbone$6.Model(data);
    model.parent = this.model;
    const view = new SieveDataView({
      index: index2,
      model,
      oldModel: oldData && new Backbone$6.Model(oldData),
      parent: this
    }).render();
    this.listenTo(view, "sieve:data:loaded", this.removeProgress);
    this.$(".xinfo").remove();
    this.$data.append(view.el);
  },
  postInit: function(options) {
    this.listenTo(this.model, "change:ts_data", this.renderUpdateMsg);
    this.resetData();
  },
  removeProgress: function() {
    this.$(".xprogress").remove();
  },
  render: function() {
    const err = this.model.get("err");
    const aLog = A({
      "href": "https://distill.io/help/check-log",
      "data-action": "sieve log menu",
      "data-action-param": this.model.id
    }, "View log for details.");
    const elErr = err && DIV({ "class": "xinfo" }, SPAN({
      "class": "error"
    }, T("Error encountered checking for updates. It may correct automatically on next check."), " ", aLog), " ", A({ href: "https://distill.io/help/contact" }, "Get help.")) || "";
    const progressBar = DIV({ "class": "xprogress", "style": "margin-top: -2px;position:absolute;" }, DIV({ "class": "xindeterminate" }));
    const data = DIV({ "class": "xsieve-data" }, elErr);
    const actionMsg = DIV({ "class": "xmsg centered hide" }, SPAN({ "class": "info" }));
    this.$el.append(DIV({ "class": "xview-body" }, progressBar, data), actionMsg).css({ margin: "4px 0" });
    this.$data = $(data);
    return this;
  },
  resetData: function() {
    delete this.lastData;
    delete this.lastDisplayedData;
    this.data = [];
    this.removeChildren();
    this.fetch();
  },
  renderUpdateMsg: function() {
    const $msg = $(DIV({ style: "text-align:center;" }, "Updated. Reloading now... "));
    _.delay(this.resetData, 100);
    _.delay(function remove() {
      $msg.remove();
    }, 1400);
  }
});
const SieveDetail = View$1.ActionProvider.extend({
  name: "SieveDetail",
  actions: {
    "sieve edit": {
      fn: "action_edit"
    },
    "sieve more data": {
      fn: "action_more"
    }
  },
  action_edit: function() {
    let team2 = get_store_value(params).team;
    push$1(`/w/${team2}/sieve/edit/${this.model.id}.id`);
  },
  action_more: function() {
    this.list.fetch();
  },
  postInit: function() {
    this.toolbar = new SieveToolbar({
      parent: this
    });
    this.list = new SieveDataList({
      parent: this,
      model: this.model,
      initialFetchCount: 3
    });
  },
  render: function() {
    this.$el.empty().append(this.list.render().el, this.toolbar.render().el);
    return this;
  }
});
function updateFrameContent(doc, uri, html2) {
  const base2 = doc.createElement("base");
  const baseURIMatch = html2.match(/<base\s*href=\"(.*?)\"/);
  let baseURI;
  if (baseURIMatch) {
    baseURI = baseURIMatch[1];
  } else {
    baseURI = uri;
    const index2 = html2.indexOf("</head>");
    html2 = html2.slice(0, index2) + '<base href="' + baseURI + '">' + html2.slice(index2);
  }
  base2.setAttribute("href", baseURI);
  $(doc.head || doc.documentElement).prepend(base2);
  if (window.IE) {
    html2 = html2.match(/^<html.*?>([\s\S]*)<\/html>$/)[1];
  }
  doc.documentElement.innerHTML = html2;
  $(doc.head || doc.documentElement).prepend(base2);
  $(doc.documentElement).find("a[href]").attr("target", "_blank").attr("rel", "noopener");
}
function setStyle(els, name, value) {
  _.each(els, function(el) {
    el.style[name] = value;
  });
}
function setDiffStyle(doc) {
  setStyle($(".removed"), "background-color", "#ff9494");
  setStyle($(".inserted"), "background-color", "#b7fdcb");
  setStyle($("span.inserted, span.removed"), "padding", "1px 4px");
  setStyle($("a.removed, a .removed"), "color", "#008");
  setStyle($("img.removed"), "border", "solid 2px red");
  setStyle($("img.removed"), "background-color", "transparent");
  setStyle($("img.removed"), "padding", "2px");
  setStyle($("img.inserted"), "border", "solid 2px green");
  setStyle($("img.inserted"), "background-color", "transparent");
  setStyle($("img.inserted"), "padding", "2px");
}
function create_catch_block$6(ctx) {
  return { c: noop, m: noop, p: noop, d: noop };
}
function create_then_block$6(ctx) {
  let h3;
  let t0_value = ctx[2].name + "";
  let t0;
  let t1;
  return {
    c() {
      h3 = element("h3");
      t0 = text(t0_value);
      t1 = text(" - Change History");
    },
    m(target, anchor) {
      insert(target, h3, anchor);
      append(h3, t0);
      append(h3, t1);
    },
    p(ctx2, dirty) {
      if (dirty & 4 && t0_value !== (t0_value = ctx2[2].name + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching)
        detach(h3);
    }
  };
}
function create_pending_block$6(ctx) {
  let t;
  return {
    c() {
      t = text("Loading...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_fragment$1c(ctx) {
  let t;
  let div;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$6,
    then: create_then_block$6,
    catch: create_catch_block$6
  };
  handle_promise(ctx[4], info);
  return {
    c() {
      info.block.c();
      t = space();
      div = element("div");
    },
    m(target, anchor) {
      info.block.m(target, info.anchor = anchor);
      info.mount = () => t.parentNode;
      info.anchor = t;
      insert(target, t, anchor);
      insert(target, div, anchor);
      ctx[5](div);
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i: noop,
    o: noop,
    d(detaching) {
      info.block.d(detaching);
      info.token = null;
      info = null;
      if (detaching)
        detach(t);
      if (detaching)
        detach(div);
      ctx[5](null);
    }
  };
}
function instance$1b($$self, $$props, $$invalidate) {
  let $route, $$unsubscribe_route = noop, $$subscribe_route = () => ($$unsubscribe_route(), $$unsubscribe_route = subscribe(route2, ($$value) => $$invalidate(7, $route = $$value)), route2);
  let $model;
  $$self.$$.on_destroy.push(() => $$unsubscribe_route());
  let { route: route2 } = $$props;
  $$subscribe_route();
  let el;
  let model = new Model$2.Sieve({ id: $route.id });
  component_subscribe($$self, model, (value) => $$invalidate(2, $model = value));
  let parent2 = getContext$1("view:root");
  let view;
  let promiseLoad = model.fetch();
  onMount(() => {
    view = new SieveDetail({ parent: parent2, model });
    el.appendChild(view.render().el);
    return () => view.remove();
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(1, el);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("route" in $$props2)
      $$subscribe_route($$invalidate(0, route2 = $$props2.route));
  };
  return [route2, el, $model, model, promiseLoad, div_binding];
}
class Detail extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1b, create_fragment$1c, safe_not_equal, { route: 0 });
  }
}
const $$6 = window.jQuery;
if (!$$6) {
  throw new Error("ADD jQuery");
}
const _$6 = window._;
if (!_$6) {
  throw new Error("ADD _");
}
const async$5 = window.async;
if (!async$5) {
  throw new Error("ADD async");
}
const domo$5 = window.domo;
if (!domo$5) {
  throw new Error("ADD domo");
}
const moment$3 = window.moment;
if (!moment$3) {
  throw new Error("ADD moment");
}
const Backbone$5 = window.Backbone;
if (!Backbone$5) {
  throw new Error("ADD Backbone");
}
const Base$2 = View$1.Base.extend({
  offset: 0,
  fields: ["name", "uri", "config", "tags", "content_type", "state", "rule_id", "schedule", "ts", "datasource_id"],
  load: async function() {
    const query = this.options.query || { "state.in": [40, 45] };
    this.out.value = T("l_loading");
    let limit = 5;
    let res2 = await Api.api("/sieves", "GET", _$6.extend({
      _opt: {
        order: ["ts"],
        limit,
        offset: this.offset,
        only: this.fields
      }
    }, query));
    this.list = this.list.concat(res2.data);
    this.offset += res2.count;
    if (res2.count == limit) {
      this.load();
    } else {
      this.onLoadListDone();
    }
  },
  onLoadListDone: function() {
  },
  render: function() {
    this.$el.append(DIV({
      "class": "alert alert-info",
      "style": ""
    }, this.helpText), this.out = TEXTAREA({
      "class": "from-control",
      "style": "width: 100%; min-height: 400px;"
    }), BUTTON({
      "class": "btn btn-primary"
    }, T("a_export")));
    this.list = [];
    return this;
  }
});
const AsCSV = Base$2.extend({
  name: "CSV",
  fields: ["id", "uri", "name", "tags", "content_type", "text", "err", "ts", "ts_mod", "datasource_id"],
  helpText: "Click Export button to generate CSV.",
  onLoadListDone: function() {
    let columns = [
      "Name",
      "URL",
      "Labels",
      "Content Type",
      "Created On",
      "Changed On",
      "Text",
      "Error?",
      "DatasourceID?"
    ];
    let list = this.list.map((sieve) => {
      let tags = sieve.tags;
      if (typeof tags === "string") {
        tags = _$6.compact(tags.split(",").map((id2) => {
          const tag = App.labels.get(id2);
          return tag ? tag.get("name") : void 0;
        }));
      }
      return [
        sieve.name,
        sieve.uri,
        tags ? tags.join(",") : "",
        sieve.content_type,
        sieve.ts,
        sieve.ts_mod,
        sieve.text,
        sieve.err || "",
        sieve.datasource_id || ""
      ];
    });
    this.out.value = Papa.unparse([columns, ...list]);
  }
});
const AsJSON = Base$2.extend({
  name: "JSON",
  helpText: "Data exported in JSON format will be generated below. You can use this JSON to import monitors later.\nNote: Actions are not exported. You can create actions for all monitors when importing them.\n\nClick Export button to start.",
  onLoadListDone: async function() {
    this.out.value = T("l_loading") + " " + T("l_rule");
    let data = [];
    for (let i2 = 0, len = this.list.length; i2 < len; i2 += 5) {
      data = [
        ...data,
        ...await Promise.all(this.list.slice(i2, i2 + 5).map(mapSieve))
      ];
    }
    this.out.value = JSON.stringify({
      client: Supports.agents,
      data
    });
    async function mapSieve(item) {
      if (item.rule_id) {
        try {
          item.rule = (await Api.api("/rules/" + item.rule_id, "GET", {
            _opt: {
              only: ["config"]
            }
          })).config;
        } catch (err) {
          console.error("error importing rule", err);
        }
      }
      if (!item.tags instanceof Array || typeof item.tags === "string") {
        item.tags = _$6.compact((item.tags || "").split(",").map(function(id2) {
          const tag = App.labels.get(id2);
          return tag ? tag.get("name") : void 0;
        }));
      }
      delete item.id;
      delete item.rule_id;
      delete item.ts_mod;
      delete item._state;
      return item;
    }
  }
});
const Exporter = View$1.ActionProvider.extend({
  name: "exporter",
  events: {
    "click .btn-primary": "event_click"
  },
  event_click: function() {
    this.view.load();
  },
  asCSV: function(query) {
    this.showView(new AsCSV({ parent: this, query }));
  },
  asJSON: function(query) {
    this.showView(new AsJSON({ parent: this, query }));
  },
  render: function() {
    this.$el.append(H2({ "class": "xpage-header" }, this.title = SPAN(""), SPAN(" - ", T("a_export"))));
    return this;
  },
  showView: function(view) {
    if (this.view) {
      this.view.remove();
    }
    this.$el.append(view.render().el);
    $$6(this.title).text(view.name);
    this.view = view;
  }
});
const tokenize = function(txtQuery, callback) {
  const quoteStartRegEx = new RegExp(/(\"|\').*/);
  const quoteEndRegEx = new RegExp(/.*(\"|\')$/);
  const keywords = [];
  const paramsObj = [];
  let expectingVal = false;
  let currParam = null;
  const tokens = txtQuery.split(" ");
  for (let i2 = 0; i2 < tokens.length; i2++) {
    let currToken = tokens[i2];
    if (expectingVal) {
      for (let j = i2; j < tokens.length; j++) {
        currToken = tokens[j];
        currParam.val = (currParam.val || "") + " " + currToken;
        if (currToken.match(quoteEndRegEx)) {
          expectingVal = false;
          i2 = j;
          currParam.val = currParam.val.replace('"', "");
          break;
        }
      }
    } else {
      if (currToken.indexOf(":") > -1) {
        if (currParam != null) {
          currParam.val = currParam.val.replace(/%22/g, '"');
          paramsObj.push(currParam);
        }
        currParam = {
          name: currToken.split(":")[0].trim(),
          val: ""
        };
        var tempVal = currToken.split(":")[1].trim();
        if (tempVal) {
          if (tempVal.match(quoteStartRegEx)) {
            currParam.val = (currParam.val || "") + " " + tempVal.match(quoteStartRegEx)[0].replace(/(\"|\')/gm, "");
            expectingVal = true;
          } else {
            currParam.val = (currParam.val || "") + " " + tempVal;
          }
        }
      } else {
        if (expectingVal) {
          currParam.val = (currParam.val || "") + " " + tempVal;
        } else {
          keywords.push(currToken.replace(/%22/g, '"'));
        }
      }
    }
  }
  if (currParam != null) {
    currParam.val = currParam.val.replace(/%22/g, '"');
    paramsObj.push(currParam);
  }
  paramsObj.push({
    name: "keyword",
    val: keywords.join(" ")
  });
  callback(null, paramsObj);
};
const tokenize_new = function(txtQuery, conditionClauses, callback) {
  const quoteStartRegEx = new RegExp(/(\"|\').*/);
  const quoteEndRegEx = new RegExp(/.*(\"|\')$/);
  const keywords = [];
  const paramsObj = [];
  let expectingVal = false;
  let currParam = null;
  let conditions = [];
  const tokens = txtQuery.split(" ");
  for (let i2 = 0; i2 < tokens.length; i2++) {
    let currToken = tokens[i2];
    if (expectingVal) {
      for (let j = i2; j < tokens.length; j++) {
        currToken = tokens[j];
        currParam.val = (currParam.val || "") + " " + currToken;
        if (currToken.match(quoteEndRegEx)) {
          expectingVal = false;
          i2 = j;
          currParam.val = currParam.val.replace('"', "");
          break;
        }
      }
    } else {
      if (currToken.indexOf(":") > -1) {
        if (currParam != null) {
          currParam.val = currParam.val.replace(/%22/g, '"');
          paramsObj.push(currParam);
        }
        currParam = {
          name: currToken.split(":")[0].trim(),
          val: "",
          operator: ""
        };
        var tempVal = currToken.split(":")[1].trim();
        if (tempVal) {
          if (tempVal.match(quoteStartRegEx)) {
            currParam.val = (currParam.val || "") + " " + tempVal.match(quoteStartRegEx)[0].replace(/(\"|\')/gm, "");
            expectingVal = true;
          } else {
            currParam.val = (currParam.val || "") + " " + tempVal;
          }
        }
        if (conditions.length > 0) {
          let operator = conditions.pop();
          currParam.operator = operator;
        }
      } else {
        if (expectingVal) {
          currParam.val = (currParam.val || "") + " " + tempVal;
        } else {
          if (_.contains(conditionClauses, currToken.toLowerCase())) {
            conditions.push(currToken.replace(/%22/g, '"'));
          } else {
            keywords.push(currToken.replace(/%22/g, '"'));
          }
        }
      }
    }
  }
  if (currParam != null) {
    currParam.val = currParam.val.replace(/%22/g, '"');
    paramsObj.push(currParam);
  }
  paramsObj.push({
    name: "keyword",
    val: keywords.join(" ")
  });
  callback(null, paramsObj);
};
var SearchQuery = {
  tokenize,
  tokenize_new
};
function getQuery(route2) {
  let query = {};
  switch (route2.prefix) {
    case "all": {
      query = { "state.in": [C.STATE_INIT, C.STATE_READY, C.STATE_PAUSED] };
      break;
    }
    case "error": {
      query = {
        "state.in": [C.STATE_INIT, C.STATE_READY, C.STATE_PAUSED],
        "err.ne": "$null"
      };
      break;
    }
    case "label": {
      query = {
        "state.in": [C.STATE_INIT, C.STATE_READY, C.STATE_PAUSED]
      };
      let id2 = route2.data;
      query["tags.like"] = "%" + id2 + "%";
      break;
    }
    case "search": {
      query = parseQuery(route2.query.q);
      break;
    }
    case "trash": {
      query = { "state": C.STATE_DISCARD };
      break;
    }
    case "unread": {
      query = {
        "state.in": [C.STATE_INIT, C.STATE_READY, C.STATE_PAUSED],
        "ts_view.lt": { name: "ts_data", type: "field" }
      };
      break;
    }
    default: {
      query = {
        _opt: {
          limit: 0
        }
      };
    }
  }
  if (!query || Object.keys(query).length <= 0) {
    query = {
      _opt: {
        limit: 0
      }
    };
  }
  if (App.store.get("ui.list.clientfilter") == 2) {
    query = { ...query, client_id: App.clients.defaultId };
  }
  return query;
}
function parseQuery(txtQuery) {
  let queryObj = {};
  const Ortokens = txtQuery.split(" OR ");
  if (Ortokens.length > 1) {
    let stateInFound = false;
    for (let i2 = 0; i2 < Ortokens.length; i2++) {
      let orToken = Ortokens[i2].trim();
      let andtokens = orToken.split(" AND ");
      let spaceTokens = orToken.split(" ");
      if (andtokens.length > 1) {
        let spaceTokens2 = [];
        for (let j = 0; j < andtokens.length; j++) {
          let spaceWithAndTokens = andtokens[j].split(" ");
          spaceTokens2 = [...spaceTokens2, ...spaceWithAndTokens];
        }
        if (spaceTokens2.length > 0) {
          andtokens = handleLabelsWithSpace(spaceTokens2);
        } else {
          andtokens = handleLabelsWithSpace(andtokens);
        }
        if (andtokens.length > 1) {
          let res2 = groupANDoperations(andtokens);
          let queryParams = res2.response || [];
          queryObj = {
            ...queryObj,
            "$or": [
              ...queryObj["$or"] || [],
              [...queryParams]
            ]
          };
          if (res2.stateInFound) {
            stateInFound = true;
          }
        } else if (andtokens.length == 1) {
          let queryParams = getQueryParams(andtokens[0]) || [];
          queryObj = {
            ...queryObj,
            "$or": [
              ...queryObj["$or"] || [],
              [...queryParams]
            ]
          };
          if (_.contains(queryParams, "state.in")) {
            stateInFound = true;
          }
        }
      } else if (spaceTokens.length > 1) {
        spaceTokens = handleLabelsWithSpace(spaceTokens);
        if (spaceTokens.length > 1) {
          let res2 = groupANDoperations(spaceTokens);
          let queryParams = res2.response || [];
          queryObj = {
            ...queryObj,
            "$or": [
              ...queryObj["$or"] || [],
              [...queryParams]
            ]
          };
          if (res2.stateInFound) {
            stateInFound = true;
          }
        } else if (spaceTokens.length == 1) {
          let queryParams = getQueryParams(spaceTokens[0]) || [];
          queryObj = {
            ...queryObj,
            "$or": [
              ...queryObj["$or"] || [],
              [...queryParams]
            ]
          };
          if (_.contains(queryParams, "state.in")) {
            stateInFound = true;
          }
        }
      } else {
        let queryParams = getQueryParams(orToken) || [];
        queryObj = {
          ...queryObj,
          "$or": [
            ...queryObj["$or"] || [],
            [...queryParams]
          ]
        };
        if (_.contains(queryParams, "state.in")) {
          stateInFound = true;
        }
      }
    }
    if (!stateInFound) {
      queryObj["state.in"] = [C.STATE_INIT, C.STATE_READY, C.STATE_PAUSED];
    }
  } else {
    SearchQuery.tokenize_new(txtQuery, ["and", "or"], function(error, data) {
      queryObj = buildQuery$1(data);
    });
  }
  return queryObj;
}
function groupANDoperations(tokens) {
  let queryObj = {};
  let stateInFound = false;
  for (let j = 0; j < tokens.length; j++) {
    let andToken = tokens[j].trim();
    let queryParams = getQueryParams(andToken) || [];
    queryObj = {
      ...queryObj,
      "$and": [
        ...queryObj["$and"] || [],
        [...queryParams]
      ]
    };
    if (_.contains(queryParams, "state.in")) {
      stateInFound = true;
    }
  }
  return {
    response: ["$and", queryObj["$and"]],
    stateInFound
  };
}
function handleLabelsWithSpace(tokens) {
  const quoteStartRegEx = new RegExp(/(\"|\').*/);
  const quoteEndRegEx = new RegExp(/.*(\"|\')$/);
  let currentVal = "";
  let currentKey = "";
  let expectingVal = false;
  let outputTokens = [];
  for (let i2 = 0; i2 < tokens.length; i2++) {
    let currToken = tokens[i2];
    if (expectingVal) {
      for (let j = i2; j < tokens.length; j++) {
        currToken = tokens[j];
        currentVal = (currentVal || "") + " " + currToken;
        if (currToken.match(quoteEndRegEx)) {
          expectingVal = false;
          i2 = j;
          currentVal = currentVal.replace('"', "");
          break;
        }
      }
      let currentObj = currentKey + ":" + currentVal;
      outputTokens.push(currentObj);
      currentVal = "";
      currentKey = "";
    } else {
      if (currToken.indexOf(":") > -1) {
        currentKey = currToken.split(":")[0];
        var tempVal = currToken.split(":")[1].trim();
        if (tempVal) {
          if (tempVal.match(quoteStartRegEx) && tempVal.match(quoteEndRegEx)) {
            currentVal = (currentVal || "") + tempVal.match(quoteStartRegEx)[0].replace(/(\"|\')/gm, "");
            let currentObj = currentKey + ":" + currentVal;
            outputTokens.push(currentObj);
            currentVal = "";
            currentKey = "";
          } else if (tempVal.match(quoteStartRegEx)) {
            currentVal = (currentVal || "") + tempVal.match(quoteStartRegEx)[0].replace(/(\"|\')/gm, "");
            expectingVal = true;
          } else {
            currentVal = (currentVal || "") + tempVal;
            let currentObj = currentKey + ":" + currentVal;
            outputTokens.push(currentObj);
            currentVal = "";
            currentKey = "";
          }
        }
      } else {
        if (expectingVal) {
          currentVal = (currentVal || "") + " " + tempVal;
        }
      }
    }
  }
  return outputTokens;
}
function getQueryParams(token) {
  let queryObj = [];
  const nameVal = token.split(":");
  if (nameVal.length > 1) {
    let currName = nameVal[0];
    let currVal = nameVal[1];
    switch (currName) {
      case "label":
        var labels = App.labels.where({ name: currVal });
        if (labels && labels.length > 0) {
          _.forEach(labels, function(label) {
            queryObj.push("tags.ilike");
            queryObj.push("%" + label.id + "%");
          });
        } else {
          queryObj = [];
          return;
        }
        break;
      case "is":
        if (currVal.match(/on/i) && !queryObj["state.in"]) {
          queryObj.push("state.in");
          queryObj.push([C.STATE_READY]);
          break;
        } else if (currVal.match(/on/i) && queryObj["state.in"].indexOf(C.STATE_READY) >= 0) {
          break;
        } else if (currVal.match(/off/i) && !queryObj["state.in"]) {
          queryObj.push("state.in");
          queryObj.push([C.STATE_PAUSED, C.STATE_INIT]);
          break;
        } else if (currVal.match(/off/i) && queryObj["state.in"].indexOf(C.STATE_PAUSED) >= 0) {
          break;
        } else if (currVal.match(/unread/i)) {
          queryObj.push("ts_view.lt");
          queryObj.push({ name: "ts_data", type: "field" });
          break;
        } else if (currVal.match(/read/i)) {
          queryObj.push("ts_view.gt");
          queryObj.push({ name: "ts_data", type: "field" });
          break;
        } else {
          queryObj = {};
          return;
        }
      case "has":
        if (currVal.match(/error/i)) {
          queryObj.push("err.ne");
          queryObj.push("$null");
          break;
        } else {
          queryObj = {};
          return;
        }
      case "keyword":
        queryObj.push("$or");
        queryObj.push({ "uri.ilike": "%" + currVal + "%", "name.ilike": "%" + currVal + "%" });
        break;
      case "in":
        if (currVal.match(/trash/i) && !queryObj["state.in"]) {
          queryObj.push("state.in");
          queryObj.push([C.STATE_DISCARD]);
        } else if (currVal.match(/trash/i) && queryObj["state.in"])
          ;
        else {
          queryObj = {};
          return;
        }
        break;
      default:
        queryObj.push("state.ne");
        queryObj.push(C.STATE_DEL);
        queryObj.push("$or");
        queryObj.push({ "uri.ilike": "%" + currName + ":" + currVal + "%", "name.ilike": "%" + currName + ":" + currVal + "%" });
    }
  }
  return queryObj;
}
function buildQuery$1(paramsObj) {
  let queryObj = {};
  for (let i2 = 0; i2 < paramsObj.length; i2++) {
    const currName = paramsObj[i2].name.toLowerCase();
    if (!paramsObj[i2].val)
      continue;
    const currVal = paramsObj[i2].val.trim();
    switch (currName) {
      case "label":
        var labels = App.labels.where({ name: currVal });
        if (labels && labels.length > 0) {
          queryObj["tags.ilike"] = queryObj["tags.ilike"] || [];
          _.forEach(labels, function(label) {
            queryObj["tags.ilike"].push(label.id);
          });
        } else {
          queryObj = {};
          return;
        }
        break;
      case "is":
        if (currVal.match(/on/i) && !queryObj["state.in"]) {
          queryObj["state.in"] = [C.STATE_READY];
          break;
        } else if (currVal.match(/on/i) && queryObj["state.in"].indexOf(C.STATE_READY) >= 0) {
          break;
        } else if (currVal.match(/off/i) && !queryObj["state.in"]) {
          queryObj["state.in"] = [C.STATE_PAUSED, C.STATE_INIT];
          break;
        } else if (currVal.match(/off/i) && queryObj["state.in"].indexOf(C.STATE_PAUSED) >= 0) {
          break;
        } else if (currVal.match(/unread/i)) {
          queryObj["ts_view.lt"] = { name: "ts_data", type: "field" };
          break;
        } else if (currVal.match(/read/i)) {
          queryObj["ts_view.gt"] = { name: "ts_data", type: "field" };
          break;
        } else {
          queryObj = {};
          return;
        }
      case "keyword":
        queryObj["$or"] = { "uri.ilike": "%" + currVal + "%", "name.ilike": "%" + currVal + "%" };
        break;
      case "has":
        if (currVal.match(/error/i)) {
          queryObj["err.ne"] = "$null";
          break;
        } else {
          queryObj = {};
          return;
        }
      case "in":
        if (currVal.match(/trash/i) && !queryObj["state.in"]) {
          queryObj["state.in"] = [C.STATE_DISCARD];
        } else if (currVal.match(/trash/i) && queryObj["state.in"])
          ;
        else {
          queryObj = {};
          return;
        }
        break;
      default:
        queryObj["state.ne"] = C.STATE_DEL;
        queryObj["$or"] = { "uri.ilike": "%" + currName + ":" + currVal + "%", "name.ilike": "%" + currName + ":" + currVal + "%" };
    }
  }
  if (queryObj["tags.ilike"] && queryObj["tags.ilike"].length > 0) {
    if (queryObj["tags.ilike"].length == 1) {
      queryObj["tags.ilike"] = "%" + queryObj["tags.ilike"].join("%") + "%";
    } else {
      queryObj["$andTAGS"] = _.map(queryObj["tags.ilike"], function(id2) {
        return ["tags.ilike", "%" + id2 + "%"];
      });
      delete queryObj["tags.ilike"];
    }
  }
  if (!_.isEmpty(queryObj) && !queryObj["state.in"]) {
    queryObj["state.in"] = [C.STATE_INIT, C.STATE_READY, C.STATE_PAUSED];
  }
  return queryObj;
}
function create_if_block$x(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "error";
      attr(div, "class", "error");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$1b(ctx) {
  let div1;
  let t;
  let div0;
  let if_block = ctx[1] && create_if_block$x();
  return {
    c() {
      div1 = element("div");
      if (if_block)
        if_block.c();
      t = space();
      div0 = element("div");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      if (if_block)
        if_block.m(div1, null);
      append(div1, t);
      append(div1, div0);
      ctx[4](div0);
    },
    p(ctx2, [dirty]) {
      if (ctx2[1]) {
        if (if_block)
          ;
        else {
          if_block = create_if_block$x();
          if_block.c();
          if_block.m(div1, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div1);
      if (if_block)
        if_block.d();
      ctx[4](null);
    }
  };
}
function instance$1a($$self, $$props, $$invalidate) {
  let { route: route2 } = $$props;
  let { user, clients, labels, sieves } = getContext$1("watchlist:stores");
  let root = getContext$1("view:root");
  let el;
  let view;
  let error;
  function show() {
    $$invalidate(1, error = null);
    let exportQueryInRouteData = lib.parse(route2.data);
    let query = getQuery(exportQueryInRouteData);
    if (route2.prefix == "csv") {
      view.asCSV(query);
    } else if ($$invalidate(2, route2.prefix = "json", route2)) {
      view.asJSON(query);
    } else {
      $$invalidate(1, error = "invalid export method");
    }
  }
  onMount(async () => {
    $$invalidate(3, view = new Exporter({ el, collection: sieves, parent: root }).render());
    show();
    return () => view.remove();
  });
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(0, el);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("route" in $$props2)
      $$invalidate(2, route2 = $$props2.route);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 12) {
      route2 && view && show();
    }
  };
  return [el, error, route2, view, div0_binding];
}
class Export extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1a, create_fragment$1b, safe_not_equal, { route: 2 });
  }
}
const SieveActionEditor = View$1.Base.extend({
  name: "SieveActionEditor",
  postInit: function() {
    this.listenTo(this.model, "remove", this.remove);
    this.paramsModel = new Backbone.Model(this.model.get("config"));
    this.listenTo(this.paramsModel, "change", this.onEditParams);
  },
  onDelete: function() {
    this.model.collection.remove(this.model);
  },
  onEditParams: function() {
    this.model.set("config", this.paramsModel.toJSON());
  },
  render: function() {
    const desc = this.model.desc;
    let paramsEl;
    let editors;
    if (!desc.single) {
      let del;
      this.$el.append(del = A({
        "class": "btn fa fa-trash-o xbtn-light",
        "style": "vertical-align: top;margin-top: 5px;",
        "href": "javascript:void 0",
        "title": T("h_del_action")
      }));
      del.onclick = this.onDelete;
    } else {
      this.$el.css({
        "margin-left": 30,
        "line-height": 0
      });
    }
    this.$el.append(paramsEl = DIV({ style: "display:inline-block;width:80%; margin-bottom: 5px;" })).css({ position: "relative", overflow: "visible" });
    editors = this.paramEditors = _.map(desc.params, function(param) {
      const paramEditor = Editor.create(param.type, {
        param,
        parent: this,
        model: this.paramsModel
      });
      paramsEl.appendChild(paramEditor.render().el);
      if (!param.must) {
        paramEditor.$el.hide();
      }
      return paramEditor;
    }, this);
    if (_.any(desc.params, function(param) {
      return !param.must;
    })) {
      let elToggle;
      paramsEl.appendChild(elToggle = BUTTON({ "class": "btn btn-default btn-xs xbtn-light" }, T("l_options")));
      elToggle.onclick = function() {
        _.each(editors, function(editor) {
          editor.$el.show();
        });
        $(elToggle).remove();
      };
    }
    if (desc.plugin) {
      desc.plugin(this);
    }
    return this;
  }
});
const SieveActionGroup = View$1.Base.extend({
  name: "SieveActionGroup",
  className: "xtype-group",
  postInit: function(options) {
    this.desc = options.desc;
    this.models = options.models;
    this.views = {};
    this.listenTo(this.models, "add", this.addOne);
    this.listenTo(this.models, "remove", this.onActionRemove);
  },
  addOne: function(action) {
    if (this.views[action.cid] == null && action.desc.type == this.desc.type) {
      const view = new SieveActionEditor({
        model: action,
        parent: this
      }).render();
      this.$list.append(view.el);
      this.views[action.cid] = view;
    }
  },
  isVoid: function(view) {
    return this.desc.single || this.desc.params.length == 0;
  },
  onActionAdd: function() {
    this.models.add(new Model$2.SieveAction[this.desc.type]());
  },
  onActionRemove: function(action, actionGroup) {
    if (this.models.where({ type: this.desc.type }).length == 0) {
      this.remove();
    }
  },
  onDelete: function() {
    const actions = this.models.where({ type: this.desc.type });
    _.each(actions, function(action) {
      this.models.remove(action);
    }, this);
  },
  render: function() {
    const desc = this.desc;
    let btnAdd;
    let btnDel;
    this.$list = $(DIV());
    if (desc.single) {
      this.$el.append(btnDel = BUTTON({
        "class": "btn fa fa-trash-o xbtn-light",
        "title": T("h_del_action")
      }));
      btnDel.onclick = this.onDelete;
    }
    if (!desc.single) {
      this.$el.append(btnAdd = BUTTON({ "class": "btn fa fa-plus xbtn-light pull-right" }));
      btnAdd.onclick = this.onActionAdd;
    }
    this.$el.append(SPAN({ style: "" }, SPAN(T(desc.label)), this.$list[0]));
    if (desc.groupPlugin) {
      desc.groupPlugin(this);
    }
    this.models.each(this.addOne);
    return this;
  }
});
const SieveActionsEditor = View$1.ActionProvider.extend({
  name: "SieveActionsEditor",
  actions: {
    action_global_actions: { fn: "action_global_actions" }
  },
  action_global_actions: function() {
    showGlobalActionEditor();
  },
  postInit: function(options) {
    this.actionGroups = {};
    this.dels = [];
    this.sieve = options.sieve;
    this.models = options.actions;
    this.listenTo(this.models, "add", this.addOne);
    this.listenTo(this.models, "remove", this.onActionRemove);
    this.listenTo(this.models, "reset", this.render);
    this.listenTo(App.user, "change", this.renderGlobalCount);
  },
  addOne: function(action) {
    const desc = action.desc;
    const type = desc.type;
    this.$emptyEl.remove();
    if (!this.actionGroups[type]) {
      const view = this.actionGroups[type] = new SieveActionGroup({
        models: this.models,
        desc,
        parent: this
      }).render();
      this.listenTo(view, "remove", function() {
        delete this.actionGroups[type];
      }, this);
      this.$list.append(view.el);
    }
  },
  getChanges: function() {
    return {
      dels: this.dels,
      posts: this.getPosts(),
      puts: this.getPuts()
    };
  },
  getPosts: function() {
    return this.models.filter(function(action) {
      return action.isNew();
    });
  },
  getPuts: function() {
    return this.models.filter(function(action) {
      return !action.isNew() && action.hasChanged();
    });
  },
  onAddActionMenuClick: function(e) {
    const type = $(e.currentTarget).attr("tag");
    const Type2 = Model$2.SieveAction[type];
    if (Type2.desc.single && this.models.where({ type: Type2.desc.type }).length > 0) {
      Msg.info("m_action_can_add_only_one");
      return;
    }
    this.models.add(new Type2(null, {
      parent: this.sieve
    }));
    e.preventDefault();
  },
  onActionRemove: function(action) {
    if (!action.isNew()) {
      this.dels.push(action);
    }
  },
  render: function() {
    let menu;
    this.reset();
    this.$emptyEl = $(DIV({ "class": "alert alert-warning hide" }, "No action added - add one to get alerted on changes"));
    this.$list = $(DIV());
    this.$el.empty().append(DIV({ style: "position: relative;" }, DIV({ "class": "space-x-4" }, A({
      "id": "menu_add_action",
      "class": "dropdown-toggle",
      "data-toggle": "dropdown",
      "href": "javascript:void 0"
    }, T("a_add_action"), " ", B({ "class": "caret" })), " ", menu = UL({
      "class": "dropdown-menu",
      "role": "menu",
      "aria-labelledby": "menu_add_action",
      "style": "z-index: 2000"
    }), " ", this.options.global ? "" : A({
      "href": "#",
      "class": "",
      "data-action": "action_global_actions"
    }, "Global Actions: ", this.elGlobalCount = SPAN(0))), DIV({
      "class": "right",
      "style": "margin-left:10px;"
    })), this.$emptyEl, DIV({ style: "max-height: 360px;overflow-y:auto;overflow-x-hidden;" }, this.$list[0]));
    _.each(Model$2.SieveActionDescList, function(desc) {
      menu.appendChild(LI(A({ tag: desc.type, tabindex: -1, href: "javascript:void 0" }, I({ "class": "fa " + desc.icon }), SPAN({ style: "margin-left: 10px;" }, T(desc.label), desc.paid ? " *" : ""))));
    });
    this.renderGlobalCount();
    menu.appendChild(LI({ "class": "disabled" }, A({ href: "#" }, "* " + T("m_premium_only"))));
    $(menu).find("a").click(this.onAddActionMenuClick);
    this.models.each(this.addOne);
    this.$emptyEl[this.models.length == 0 ? "removeClass" : "addClass"]("hide");
    return this;
  },
  async renderGlobalCount() {
    var _a, _b;
    if (App.user.isLoggedIn()) {
      $(this.elGlobalCount).text(((_b = (_a = USER.prefs) == null ? void 0 : _a.actions) == null ? void 0 : _b.length) || 0);
    }
  },
  reset: function() {
    _.each(this.actionGroups, function(view) {
      view.remove();
    });
    this.actionGroups = {};
    this.dels = [];
  }
});
async function showGlobalActionEditor() {
  if (!USER.id) {
    return alert("Please sign in save global actions");
  }
  let sieve = new Model$2.Sieve();
  let actions = new Model$2.SieveActions(null, { parent: sieve });
  actions.set({ data: USER.prefs.actions }, { parse: true });
  let view = new SieveActionsEditor({
    actions,
    sieve,
    parent: App.root,
    global: true
  });
  const modal = new View$1.SaveDiscardModal({
    name: "GlobalActionEditor$SaveDiscardModal",
    title: "Global Actions",
    titleEx: `taken on changes for all monitors, merged with monitor's actions`,
    view,
    parent: App.root
  });
  modal.on("save", async () => {
    modal.remove();
    let data = actions.toJSON();
    try {
      await Api.api("/prefs/actions", "PUT", data);
      USER.prefs.actions = data;
    } catch (e) {
      console.error(e);
      Msg.error("Failed to save data, please try again later");
    }
  });
  modal.on("discard", () => {
    modal.remove();
  });
  modal.show();
}
function get_each_context$l(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i2];
  return child_ctx;
}
function create_each_block$l(key_1, ctx) {
  let option;
  let t_value = T(ctx[6].label) + "";
  let t;
  return {
    key: key_1,
    first: null,
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = ctx[6].value;
      option.value = option.__value;
      attr(option, "title", T(ctx[6].title));
      this.first = option;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_fragment$1a(ctx) {
  let div;
  let span;
  let t2;
  let select;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let div_class_value;
  let mounted;
  let dispose;
  let each_value = ctx[2];
  const get_key = (ctx2) => ctx2[6].value;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$l(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$l(key, child_ctx));
  }
  let div_levels = [
    {
      class: div_class_value = "flex " + ctx[1]
    },
    ctx[3]
  ];
  let div_data = {};
  for (let i2 = 0; i2 < div_levels.length; i2 += 1) {
    div_data = assign$1(div_data, div_levels[i2]);
  }
  return {
    c() {
      div = element("div");
      span = element("span");
      span.textContent = `${T("l_num_format")}:`;
      t2 = space();
      select = element("select");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(span, "class", "pr-2");
      attr(select, "title", T("title_num_format"));
      if (ctx[0] === void 0)
        add_render_callback(() => ctx[4].call(select));
      set_attributes(div, div_data);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span);
      append(div, t2);
      append(div, select);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(select, null);
      }
      select_option(select, ctx[0]);
      if (!mounted) {
        dispose = listen(select, "change", ctx[4]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 4) {
        each_value = ctx2[2];
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, select, destroy_block, create_each_block$l, null, get_each_context$l);
      }
      if (dirty & 5) {
        select_option(select, ctx2[0]);
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & 2 && div_class_value !== (div_class_value = "flex " + ctx2[1]) && { class: div_class_value },
        dirty & 8 && ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$19($$self, $$props, $$invalidate) {
  const omit_props_names = ["format", "class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { format } = $$props;
  const OPTIONS = [
    {
      label: "rule_comma_dot",
      title: "title_format_option_comma_dot",
      value: C.NUM_FORMAT_COMMA_DOT
    },
    {
      label: "rule_dot_comma",
      title: "title_format_option_dot_comma",
      value: C.NUM_FORMAT_DOT_COMMA
    },
    {
      label: "rule_space_comma",
      title: "title_format_option_space_comma",
      value: C.NUM_FORMAT_SPACE_COMMA
    }
  ];
  format || (format = C.NUM_FORMAT_COMMA_DOT);
  let dispatch = createEventDispatcher();
  let { class: clazz } = $$props;
  function select_change_handler() {
    format = select_value(this);
    $$invalidate(0, format);
    $$invalidate(2, OPTIONS);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("format" in $$new_props)
      $$invalidate(0, format = $$new_props.format);
    if ("class" in $$new_props)
      $$invalidate(1, clazz = $$new_props.class);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      dispatch("change", format);
    }
  };
  return [format, clazz, OPTIONS, $$restProps, select_change_handler];
}
class NumberFormat extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$19, create_fragment$1a, safe_not_equal, { format: 0, class: 1 });
  }
}
const SieveRuleEditor = View$1.Base.extend({
  name: "SieveRuleEditor",
  className: "flex space-x-2",
  postInit: function() {
    this.paramsModel = new Backbone.Model(this.model.rule.params);
  },
  getConfig: function() {
    return {
      type: C.TYPE_RULE,
      contentType: this.getContentType(),
      rule: {
        type: this.getRuleType(),
        params: this.getParams()
      }
    };
  },
  getContentType: function() {
    return parseInt(this.selContentType.value);
  },
  getParams: function() {
    const keys = _.pluck(this.getRuleDesc().params, "name");
    const json = this.paramsModel.toJSON();
    return _.pick(...[json].concat(keys));
  },
  getRuleDesc: function() {
    return _.findWhere(Rules.DescList, { type: this.getRuleType() }) || {
      type: 0,
      lable: "l_rule_unknown",
      params: []
    };
  },
  getRuleType: function() {
    return parseInt(this.selRuleType.value);
  },
  onTypeChange: function() {
    this.renderParams();
    this.bubbleEvent("onTypeChange");
  },
  render: function() {
    let elParams;
    this.$el.append(this.selContentType = SELECT.apply(window, _.map(Rules.ContentList, function(item) {
      return OPTION({ value: item.type }, T(item.label));
    })), this.selRuleType = SELECT.apply(window, _.map(Rules.DescList, function(item) {
      return OPTION({ value: item.type }, T(item.label));
    })), elParams = DIV({
      style: "flex: 1"
    }));
    this.selContentType.value = this.model.contentType;
    this.selRuleType.value = this.model.rule.type;
    this.$elParams = $(elParams);
    this.renderParams();
    $(this.selRuleType).change(this.onTypeChange);
    return this;
  },
  renderParams: function() {
    const elParams = this.$elParams;
    const model = this.paramsModel;
    const desc = this.getRuleDesc();
    if (!desc)
      throw new Error("Unknown rule desc:" + this.getRuleType());
    elParams.empty();
    const els = _.map(desc.params, function(param) {
      return Editor.create(param.type, {
        param,
        parent: this,
        model
      }).render().el;
    }, this);
    elParams.append(els);
  }
});
var SieveRuleGroupEditor = View$1.Base.extend({
  name: "SieveRuleGroupEditor",
  tagName: "fieldset",
  className: "xrulegroup flex-1",
  postInit: function() {
    this.editors = [];
  },
  addOne: function(config) {
    if (config.type == C.TYPE_RULE) {
      this.addRule(config);
    } else if (config.type == C.TYPE_RULE_GROUP) {
      this.addRuleGroup(config);
    }
  },
  addEditor: function(editor, isGroup) {
    let btn;
    let wrapper;
    editor.el.style.flex = 1;
    this.$list.append(wrapper = DIV({
      "class": `flex items-start ${isGroup ? "py-4 px-4 bl border-gray-400" : ""}`
    }, editor.el, btn = BUTTON({ "class": "btn btn-default btn-sm ml-2", title: T("a_del") }, I({ "class": "fa fa-trash-o" }))));
    $(btn).click(() => {
      editor.remove();
      wrapper.remove();
      this.editors.splice(_.indexOf(this.editors, editor), 1);
    });
    this.editors.push(editor);
  },
  addRule: function(ruleConfig) {
    ruleConfig || (ruleConfig = this.defaultRule());
    const editor = new SieveRuleEditor({
      model: ruleConfig,
      parent: this
    }).render();
    this.addEditor(editor, false);
  },
  addRuleGroup: function(ruleGroupConfig) {
    ruleGroupConfig || (ruleGroupConfig = this.defaultRuleGroup());
    const editor = new SieveRuleGroupEditor({
      model: ruleGroupConfig,
      parent: this
    }).render();
    editor.setConfig(ruleGroupConfig);
    this.addEditor(editor, true);
  },
  defaultRule: function() {
    return {
      type: C.TYPE_RULE,
      contentType: C.CONTENT_TYPE_CHANGED_TEXT,
      rule: {
        type: C.RULE_HAS_TEXT,
        params: { input: "" }
      }
    };
  },
  defaultRuleGroup: function() {
    return {
      type: C.TYPE_RULE_GROUP,
      op: C.OP_AND,
      rules: [this.defaultRule()]
    };
  },
  getConfig: function() {
    return {
      type: C.TYPE_RULE_GROUP,
      op: parseInt(this.selOp.value),
      rules: _.map(this.editors, function(editor) {
        return editor.getConfig();
      })
    };
  },
  isEmpty: function() {
    return this.editors.length == 0;
  },
  onAddClick: function(e) {
    const tag = e.target.getAttribute("tag");
    if (!tag)
      return;
    if (tag == C.TYPE_RULE) {
      this.addRule();
    } else if (tag == C.TYPE_RULE_GROUP) {
      this.addRuleGroup();
    } else
      ;
  },
  render: function() {
    let list;
    let actions;
    this.$el.append(LEGEND(T("l_rule_true_if_matches_x") + " ", this.selOp = SELECT(OPTION({ value: C.OP_AND }, T("l_all")), OPTION({ value: C.OP_OR }, T("l_any"))), " " + T("l_x_of_following_rules") + ":", actions = DIV({ "class": "btn-group xadd-rule right" }, BUTTON({ "class": "btn btn-default btn-xs w-28", "tag": C.TYPE_RULE }, I({ "class": "fa fa-plus" }), " ", T("a_add")), BUTTON({
      "class": "btn btn-default btn-xs dropdown-toggle",
      "data-toggle": "dropdown"
    }, SPAN({ "class": "caret" })), UL({ "class": "dropdown-menu dropdown-menu-right", "role": "menu" }, LI(A({
      tag: C.TYPE_RULE_GROUP,
      tabindex: -1,
      href: "javascript:void 0"
    }, SPRINTF("a_action_object", "a_add", "l_rule_group")))))), list = DIV({ "class": "space-y-2" }));
    $(actions).click(this.onAddClick);
    this.$list = $(list);
    return this;
  },
  setConfig: function(model) {
    this.selOp.value = model.op;
    _.each(this.editors, function(editor) {
      editor.remove();
    });
    this.editors = [];
    _.each(model.rules, this.addOne);
  }
});
const SieveRulesEditorV1 = View$1.ActionProvider.extend({
  name: "SieveRulesEditorV1",
  numberFormat: C.NUM_FORMAT_COMMA_DOT,
  actions: {
    add_condition: { fn: "action_add" }
  },
  action_add: function() {
    this.ruleView.addRule();
    this.renderRules();
    this.trigger("onTypeChange");
  },
  postInit: function(options) {
    this.ruleView = new SieveRuleGroupEditor({
      parent: this
    }).render();
    if (!this.model.isEmpty()) {
      _.delay(this.onLoad);
    } else {
      this.ruleView.setConfig(this.model.get("config"));
    }
    this.on("onTypeChange", function() {
      let config = this.ruleView.getConfig();
      if (config) {
        let cl = this.elNumFormat.classList;
        if (containsRuleWithNumber(config)) {
          cl.remove("hide");
        } else {
          cl.add("hide");
        }
      }
    });
  },
  onLoad: function() {
    let config = this.model.get("config");
    this.numberFormat = config.numberFormat || C.NUM_FORMAT_COMMA_DOT;
    this.ruleView.setConfig(config);
    this.renderRules();
    this.renderNumberFormat();
    this.trigger("onTypeChange");
  },
  render: function() {
    let body;
    this.$el.append(body = DIV({ style: "max-height: 600px; overflow-y: auto; overflow-x:hidden;" }));
    this.$body = $(body);
    this.renderRules();
    this.renderNumberFormat();
    return this;
  },
  renderRules: function() {
    const $el = this.$body;
    $el.empty();
    if (this.ruleView.isEmpty()) {
      $el.append(A({
        href: "#",
        "data-action": "add_condition"
      }, SPRINTF("a_action_object", "a_add", "l_rule")));
    } else {
      $el.append(this.ruleView.el);
    }
  },
  renderNumberFormat: function() {
    this.$el.append(this.elNumFormat = DIV({ "class": "mt-4 hide" }));
    this.viewNumFormat = new NumberFormat({
      target: this.elNumFormat,
      props: {
        format: this.numberFormat
      }
    });
    this.viewNumFormat.$on("change", (e) => this.numberFormat = e.detail);
  },
  remove() {
    SieveRulesEditorV1.__super__.remove.call(this);
    this.viewNumFormat.$destroy();
  },
  updateModel: function() {
    const config = this.ruleView.getConfig();
    config.numberFormat = this.numberFormat;
    this.model.set("config", config);
  }
});
function containsRuleWithNumber(config) {
  if (config.type === 1 && !!config.rule) {
    return Rules.NumericConditions.includes(config.rule.type);
  } else if (config.type === 2 && config.rules.length > 0) {
    return _.any(config.rules, function(config2) {
      return containsRuleWithNumber(config2);
    });
  }
  return false;
}
const get_bottom_slot_changes$1 = (dirty) => ({});
const get_bottom_slot_context$1 = (ctx) => ({});
function get_each_context$k(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list[i2];
  return child_ctx;
}
const get_top_slot_changes = (dirty) => ({});
const get_top_slot_context = (ctx) => ({});
const get_label_slot_changes = (dirty) => ({});
const get_label_slot_context = (ctx) => ({});
const get_icon_slot_changes$1 = (dirty) => ({});
const get_icon_slot_context$1 = (ctx) => ({});
function fallback_block(ctx) {
  let span1;
  let t;
  let span0;
  return {
    c() {
      span1 = element("span");
      t = text(ctx[5]);
      span0 = element("span");
      attr(span1, "class", "flex-1");
    },
    m(target, anchor) {
      insert(target, span1, anchor);
      append(span1, t);
      append(span1, span0);
    },
    p(ctx2, dirty) {
      if (dirty & 32)
        set_data(t, ctx2[5]);
    },
    d(detaching) {
      if (detaching)
        detach(span1);
    }
  };
}
function create_if_block$w(ctx) {
  let menuitem;
  let current;
  menuitem = new MenuItem$1({
    props: {
      selected: !ctx[0],
      $$slots: { default: [create_default_slot_1$6] },
      $$scope: { ctx }
    }
  });
  menuitem.$on("click", ctx[11]);
  return {
    c() {
      create_component(menuitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitem_changes = {};
      if (dirty & 1)
        menuitem_changes.selected = !ctx2[0];
      if (dirty & 8192) {
        menuitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem.$set(menuitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem, detaching);
    }
  };
}
function create_default_slot_1$6(ctx) {
  let t;
  return {
    c() {
      t = text("None (Default)");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$h(ctx) {
  let t_value = ctx[16].name + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t_value !== (t_value = ctx2[16].name + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_each_block$k(key_1, ctx) {
  let first;
  let menuitem;
  let current;
  function click_handler_1(...args) {
    return ctx[12](ctx[16], ...args);
  }
  menuitem = new MenuItem$1({
    props: {
      selected: ctx[0] == ctx[16].id,
      $$slots: { default: [create_default_slot$h] },
      $$scope: { ctx }
    }
  });
  menuitem.$on("click", click_handler_1);
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(menuitem.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(menuitem, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const menuitem_changes = {};
      if (dirty & 3)
        menuitem_changes.selected = ctx[0] == ctx[16].id;
      if (dirty & 8194) {
        menuitem_changes.$$scope = { dirty, ctx };
      }
      menuitem.$set(menuitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      destroy_component(menuitem, detaching);
    }
  };
}
function create_fragment$19(ctx) {
  let div;
  let a;
  let t0;
  let t1;
  let span;
  let a_href_value;
  let a_class_value;
  let t2;
  let ul;
  let t3;
  let t4;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t5;
  let current;
  let mounted;
  let dispose;
  const icon_slot_template = ctx[10].icon;
  const icon_slot = create_slot(icon_slot_template, ctx, ctx[13], get_icon_slot_context$1);
  const label_slot_template = ctx[10].label;
  const label_slot = create_slot(label_slot_template, ctx, ctx[13], get_label_slot_context);
  const label_slot_or_fallback = label_slot || fallback_block(ctx);
  let a_levels = [
    { href: a_href_value = "#" },
    {
      class: a_class_value = "flex items-center space-x-2 " + ctx[3]
    },
    ctx[9]
  ];
  let a_data = {};
  for (let i2 = 0; i2 < a_levels.length; i2 += 1) {
    a_data = assign$1(a_data, a_levels[i2]);
  }
  const top_slot_template = ctx[10].top;
  const top_slot = create_slot(top_slot_template, ctx, ctx[13], get_top_slot_context);
  let if_block = ctx[2] && create_if_block$w(ctx);
  let each_value = ctx[1];
  const get_key = (ctx2) => ctx2[16].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$k(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$k(key, child_ctx));
  }
  const bottom_slot_template = ctx[10].bottom;
  const bottom_slot = create_slot(bottom_slot_template, ctx, ctx[13], get_bottom_slot_context$1);
  return {
    c() {
      div = element("div");
      a = element("a");
      if (icon_slot)
        icon_slot.c();
      t0 = space();
      if (label_slot_or_fallback)
        label_slot_or_fallback.c();
      t1 = space();
      span = element("span");
      t2 = space();
      ul = element("ul");
      if (top_slot)
        top_slot.c();
      t3 = space();
      if (if_block)
        if_block.c();
      t4 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t5 = space();
      if (bottom_slot)
        bottom_slot.c();
      attr(span, "class", "caret");
      set_attributes(a, a_data);
      attr(ul, "class", "dropdown-menu");
      attr(div, "class", "drowdown relative");
      toggle_class(div, "open", ctx[4]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, a);
      if (icon_slot) {
        icon_slot.m(a, null);
      }
      append(a, t0);
      if (label_slot_or_fallback) {
        label_slot_or_fallback.m(a, null);
      }
      append(a, t1);
      append(a, span);
      append(div, t2);
      append(div, ul);
      if (top_slot) {
        top_slot.m(ul, null);
      }
      append(ul, t3);
      if (if_block)
        if_block.m(ul, null);
      append(ul, t4);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(ul, null);
      }
      append(ul, t5);
      if (bottom_slot) {
        bottom_slot.m(ul, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(a, "click", prevent_default(ctx[6])),
          action_destroyer(clickOutside$1.call(null, div)),
          action_destroyer(keypressEscape$1.call(null, div)),
          listen(div, "outclick", ctx[7]),
          listen(div, "escape", ctx[7])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & 8192)) {
          update_slot_base(icon_slot, icon_slot_template, ctx2, ctx2[13], !current ? get_all_dirty_from_scope(ctx2[13]) : get_slot_changes(icon_slot_template, ctx2[13], dirty, get_icon_slot_changes$1), get_icon_slot_context$1);
        }
      }
      if (label_slot) {
        if (label_slot.p && (!current || dirty & 8192)) {
          update_slot_base(label_slot, label_slot_template, ctx2, ctx2[13], !current ? get_all_dirty_from_scope(ctx2[13]) : get_slot_changes(label_slot_template, ctx2[13], dirty, get_label_slot_changes), get_label_slot_context);
        }
      } else {
        if (label_slot_or_fallback && label_slot_or_fallback.p && (!current || dirty & 32)) {
          label_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        { href: a_href_value },
        (!current || dirty & 8 && a_class_value !== (a_class_value = "flex items-center space-x-2 " + ctx2[3])) && { class: a_class_value },
        dirty & 512 && ctx2[9]
      ]));
      if (top_slot) {
        if (top_slot.p && (!current || dirty & 8192)) {
          update_slot_base(top_slot, top_slot_template, ctx2, ctx2[13], !current ? get_all_dirty_from_scope(ctx2[13]) : get_slot_changes(top_slot_template, ctx2[13], dirty, get_top_slot_changes), get_top_slot_context);
        }
      }
      if (ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$w(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(ul, t4);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (dirty & 259) {
        each_value = ctx2[1];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, ul, outro_and_destroy_block, create_each_block$k, t5, get_each_context$k);
        check_outros();
      }
      if (bottom_slot) {
        if (bottom_slot.p && (!current || dirty & 8192)) {
          update_slot_base(bottom_slot, bottom_slot_template, ctx2, ctx2[13], !current ? get_all_dirty_from_scope(ctx2[13]) : get_slot_changes(bottom_slot_template, ctx2[13], dirty, get_bottom_slot_changes$1), get_bottom_slot_context$1);
        }
      }
      if (dirty & 16) {
        toggle_class(div, "open", ctx2[4]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon_slot, local);
      transition_in(label_slot_or_fallback, local);
      transition_in(top_slot, local);
      transition_in(if_block);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(bottom_slot, local);
      current = true;
    },
    o(local) {
      transition_out(icon_slot, local);
      transition_out(label_slot_or_fallback, local);
      transition_out(top_slot, local);
      transition_out(if_block);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(bottom_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (icon_slot)
        icon_slot.d(detaching);
      if (label_slot_or_fallback)
        label_slot_or_fallback.d(detaching);
      if (top_slot)
        top_slot.d(detaching);
      if (if_block)
        if_block.d();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      if (bottom_slot)
        bottom_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$18($$self, $$props, $$invalidate) {
  const omit_props_names = ["id", "items", "allowNull", "class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  let { id: id2 } = $$props;
  let { items } = $$props;
  let { allowNull = true } = $$props;
  let { class: clazz = "" } = $$props;
  let dispatch = createEventDispatcher();
  let open = false;
  let label;
  function getLabel() {
    var _a;
    return !id2 ? "<None>" : ((_a = items.find((item) => item.id == id2)) == null ? void 0 : _a.name) || "<Deleted>";
  }
  function onClick() {
    $$invalidate(4, open = !open);
    dispatch(open ? "open" : "close");
  }
  function close() {
    $$invalidate(4, open = false);
    dispatch("close");
  }
  function onSelect(_id) {
    $$invalidate(0, id2 = _id);
    dispatch("select", id2);
    close();
  }
  const click_handler2 = (e) => onSelect(null);
  const click_handler_1 = (item, e) => onSelect(item.id);
  $$self.$$set = ($$new_props) => {
    $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("id" in $$new_props)
      $$invalidate(0, id2 = $$new_props.id);
    if ("items" in $$new_props)
      $$invalidate(1, items = $$new_props.items);
    if ("allowNull" in $$new_props)
      $$invalidate(2, allowNull = $$new_props.allowNull);
    if ("class" in $$new_props)
      $$invalidate(3, clazz = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(13, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $$invalidate(5, label = getLabel());
    }
  };
  return [
    id2,
    items,
    allowNull,
    clazz,
    open,
    label,
    onClick,
    close,
    onSelect,
    $$restProps,
    slots,
    click_handler2,
    click_handler_1,
    $$scope
  ];
}
class Menu$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$18, create_fragment$19, safe_not_equal, { id: 0, items: 1, allowNull: 2, class: 3 });
  }
}
function create_fragment$18(ctx) {
  let li;
  let a;
  let current;
  const default_slot_template = ctx[3].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[2], null);
  let a_levels = [{ href: ctx[0] }, ctx[1]];
  let a_data = {};
  for (let i2 = 0; i2 < a_levels.length; i2 += 1) {
    a_data = assign$1(a_data, a_levels[i2]);
  }
  return {
    c() {
      li = element("li");
      a = element("a");
      if (default_slot)
        default_slot.c();
      set_attributes(a, a_data);
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, a);
      if (default_slot) {
        default_slot.m(a, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[2], !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(default_slot_template, ctx2[2], dirty, null), null);
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        (!current || dirty & 1) && { href: ctx2[0] },
        dirty & 2 && ctx2[1]
      ]));
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$17($$self, $$props, $$invalidate) {
  const omit_props_names = ["href"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  let { href: href2 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("href" in $$new_props)
      $$invalidate(0, href2 = $$new_props.href);
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  return [href2, $$restProps, $$scope, slots];
}
class MenuItemLink extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$17, create_fragment$18, safe_not_equal, { href: 0 });
  }
}
function create_default_slot$g(ctx) {
  let t;
  return {
    c() {
      t = text("Learn More");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_bottom_slot$2(ctx) {
  let li;
  let t;
  let menuitemlink;
  let current;
  menuitemlink = new MenuItemLink({
    props: {
      href: URL_WEBSITE + "/docs/web-monitor/using-conditions-to-get-alert-on-important-changes/",
      target: "_blank",
      $$slots: { default: [create_default_slot$g] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      li = element("li");
      t = space();
      create_component(menuitemlink.$$.fragment);
      attr(li, "class", "divider");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      insert(target, t, anchor);
      mount_component(menuitemlink, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitemlink_changes = {};
      if (dirty & 16) {
        menuitemlink_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemlink.$set(menuitemlink_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitemlink.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitemlink.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      if (detaching)
        detach(t);
      destroy_component(menuitemlink, detaching);
    }
  };
}
function create_fragment$17(ctx) {
  let menu;
  let updating_id;
  let current;
  function menu_id_binding(value) {
    ctx[2](value);
  }
  let menu_props = {
    items: ctx[1],
    allowNull: false,
    class: "btn btn-default btn-sm w-40 text-start",
    style: "text-align: start;",
    $$slots: { bottom: [create_bottom_slot$2] },
    $$scope: { ctx }
  };
  if (ctx[0] !== void 0) {
    menu_props.id = ctx[0];
  }
  menu = new Menu$1({ props: menu_props });
  binding_callbacks.push(() => bind$2(menu, "id", menu_id_binding));
  menu.$on("search", onSearch);
  return {
    c() {
      create_component(menu.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menu, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const menu_changes = {};
      if (dirty & 16) {
        menu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_id && dirty & 1) {
        updating_id = true;
        menu_changes.id = ctx2[0];
        add_flush_callback(() => updating_id = false);
      }
      menu.$set(menu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menu, detaching);
    }
  };
}
function onSearch(e) {
  e.detail;
}
function instance$16($$self, $$props, $$invalidate) {
  createEventDispatcher();
  let { id: id2 } = $$props;
  let items = [
    { id: "$new", name: T("l_text") },
    {
      id: "$diff.new",
      name: T("l_added_text")
    },
    { id: "$diff.old", name: T("l_text_del") },
    { id: "$old", name: T("l_text_old") }
  ];
  function menu_id_binding(value) {
    id2 = value;
    $$invalidate(0, id2);
  }
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(0, id2 = $$props2.id);
  };
  return [id2, items, menu_id_binding];
}
class Left extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$16, create_fragment$17, safe_not_equal, { id: 0 });
  }
}
const get_icon_slot_changes = (dirty) => ({});
const get_icon_slot_context = (ctx) => ({});
const get_bottom_slot_changes = (dirty) => ({});
const get_bottom_slot_context = (ctx) => ({});
function create_icon_slot$3(ctx) {
  let current;
  const icon_slot_template = ctx[6].icon;
  const icon_slot = create_slot(icon_slot_template, ctx, ctx[12], get_icon_slot_context);
  return {
    c() {
      if (icon_slot)
        icon_slot.c();
    },
    m(target, anchor) {
      if (icon_slot) {
        icon_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & 4096)) {
          update_slot_base(icon_slot, icon_slot_template, ctx2, ctx2[12], !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(icon_slot_template, ctx2[12], dirty, get_icon_slot_changes), get_icon_slot_context);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon_slot, local);
      current = true;
    },
    o(local) {
      transition_out(icon_slot, local);
      current = false;
    },
    d(detaching) {
      if (icon_slot)
        icon_slot.d(detaching);
    }
  };
}
function create_top_slot(ctx) {
  let li;
  let div;
  let input_1;
  let mounted;
  let dispose;
  return {
    c() {
      li = element("li");
      div = element("div");
      input_1 = element("input");
      attr(input_1, "type", "text");
      attr(input_1, "class", "mx-4 flex-grow");
      attr(input_1, "placeholder", "Search");
      attr(div, "class", "flex");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, div);
      append(div, input_1);
      ctx[8](input_1);
      if (!mounted) {
        dispose = [
          listen(input_1, "input", ctx[9]),
          listen(div, "click", prevent_default(ctx[7]))
        ];
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(li);
      ctx[8](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_bottom_slot$1(ctx) {
  let current;
  const bottom_slot_template = ctx[6].bottom;
  const bottom_slot = create_slot(bottom_slot_template, ctx, ctx[12], get_bottom_slot_context);
  return {
    c() {
      if (bottom_slot)
        bottom_slot.c();
    },
    m(target, anchor) {
      if (bottom_slot) {
        bottom_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (bottom_slot) {
        if (bottom_slot.p && (!current || dirty & 4096)) {
          update_slot_base(bottom_slot, bottom_slot_template, ctx2, ctx2[12], !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(bottom_slot_template, ctx2[12], dirty, get_bottom_slot_changes), get_bottom_slot_context);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(bottom_slot, local);
      current = true;
    },
    o(local) {
      transition_out(bottom_slot, local);
      current = false;
    },
    d(detaching) {
      if (bottom_slot)
        bottom_slot.d(detaching);
    }
  };
}
function create_fragment$16(ctx) {
  let menu;
  let updating_id;
  let current;
  const menu_spread_levels = [{ items: ctx[1] }, ctx[5]];
  function menu_id_binding(value) {
    ctx[10](value);
  }
  let menu_props = {
    $$slots: {
      bottom: [create_bottom_slot$1],
      top: [create_top_slot],
      icon: [create_icon_slot$3]
    },
    $$scope: { ctx }
  };
  for (let i2 = 0; i2 < menu_spread_levels.length; i2 += 1) {
    menu_props = assign$1(menu_props, menu_spread_levels[i2]);
  }
  if (ctx[0] !== void 0) {
    menu_props.id = ctx[0];
  }
  menu = new Menu$1({ props: menu_props });
  binding_callbacks.push(() => bind$2(menu, "id", menu_id_binding));
  menu.$on("open", ctx[4]);
  menu.$on("select", ctx[11]);
  return {
    c() {
      create_component(menu.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menu, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const menu_changes = dirty & 34 ? get_spread_update(menu_spread_levels, [
        dirty & 2 && { items: ctx2[1] },
        dirty & 32 && get_spread_object(ctx2[5])
      ]) : {};
      if (dirty & 4100) {
        menu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_id && dirty & 1) {
        updating_id = true;
        menu_changes.id = ctx2[0];
        add_flush_callback(() => updating_id = false);
      }
      menu.$set(menu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menu, detaching);
    }
  };
}
function instance$15($$self, $$props, $$invalidate) {
  const omit_props_names = ["id", "items"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  let { id: id2 } = $$props;
  let { items } = $$props;
  let input;
  const dispatch = createEventDispatcher();
  function focus() {
    setTimeout(() => input.focus(), 100);
  }
  function click_handler2(event) {
    bubble.call(this, $$self, event);
  }
  function input_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      input = $$value;
      $$invalidate(2, input);
    });
  }
  const input_handler = (e) => dispatch("search", e.target.value.trim());
  function menu_id_binding(value) {
    id2 = value;
    $$invalidate(0, id2);
  }
  function select_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("id" in $$new_props)
      $$invalidate(0, id2 = $$new_props.id);
    if ("items" in $$new_props)
      $$invalidate(1, items = $$new_props.items);
    if ("$$scope" in $$new_props)
      $$invalidate(12, $$scope = $$new_props.$$scope);
  };
  return [
    id2,
    items,
    input,
    dispatch,
    focus,
    $$restProps,
    slots,
    click_handler2,
    input_1_binding,
    input_handler,
    menu_id_binding,
    select_handler,
    $$scope
  ];
}
class SearchableMenu extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$15, create_fragment$16, safe_not_equal, { id: 0, items: 1 });
  }
}
function create_fragment$15(ctx) {
  let searchablemenu;
  let updating_id;
  let current;
  function searchablemenu_id_binding(value) {
    ctx[3](value);
  }
  let searchablemenu_props = {
    items: ctx[1],
    allowNull: false,
    class: "btn btn-default btn-sm"
  };
  if (ctx[0] !== void 0) {
    searchablemenu_props.id = ctx[0];
  }
  searchablemenu = new SearchableMenu({ props: searchablemenu_props });
  binding_callbacks.push(() => bind$2(searchablemenu, "id", searchablemenu_id_binding));
  searchablemenu.$on("search", ctx[2]);
  searchablemenu.$on("select", ctx[4]);
  return {
    c() {
      create_component(searchablemenu.$$.fragment);
    },
    m(target, anchor) {
      mount_component(searchablemenu, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const searchablemenu_changes = {};
      if (dirty & 2)
        searchablemenu_changes.items = ctx2[1];
      if (!updating_id && dirty & 1) {
        updating_id = true;
        searchablemenu_changes.id = ctx2[0];
        add_flush_callback(() => updating_id = false);
      }
      searchablemenu.$set(searchablemenu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(searchablemenu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(searchablemenu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(searchablemenu, detaching);
    }
  };
}
function instance$14($$self, $$props, $$invalidate) {
  createEventDispatcher();
  let { id: id2 } = $$props;
  let { items = [] } = $$props;
  let allItems = [...items];
  function onSearch2(e) {
    let query = e.detail.toLowerCase();
    $$invalidate(1, items = allItems.filter((item) => item.name.toLowerCase().includes(query)));
  }
  function searchablemenu_id_binding(value) {
    id2 = value;
    $$invalidate(0, id2);
  }
  function select_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(0, id2 = $$props2.id);
    if ("items" in $$props2)
      $$invalidate(1, items = $$props2.items);
  };
  return [id2, items, onSearch2, searchablemenu_id_binding, select_handler];
}
class Operator extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$14, create_fragment$15, safe_not_equal, { id: 0, items: 1 });
  }
}
function create_fragment$14(ctx) {
  let div;
  let input0;
  let input0_value_value;
  let t;
  let input1;
  let input1_value_value;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      input0 = element("input");
      t = space();
      input1 = element("input");
      attr(input0, "class", "form-control xform-control-sm");
      attr(input0, "type", "text");
      input0.value = input0_value_value = ctx[0].expr;
      attr(input0, "autocomplete", "off");
      attr(input0, "placeholder", "Expression");
      attr(input1, "class", "form-control xform-control-sm w-20");
      attr(input1, "type", "text");
      input1.value = input1_value_value = ctx[0].flags;
      attr(input1, "autocomplete", "off");
      attr(input1, "placeholder", "Flags");
      attr(div, "class", "flex space-x-2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input0);
      append(div, t);
      append(div, input1);
      if (!mounted) {
        dispose = [
          listen(input0, "input", ctx[2]),
          listen(input1, "input", ctx[3])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 1 && input0_value_value !== (input0_value_value = ctx2[0].expr) && input0.value !== input0_value_value) {
        input0.value = input0_value_value;
      }
      if (dirty & 1 && input1_value_value !== (input1_value_value = ctx2[0].flags) && input1.value !== input1_value_value) {
        input1.value = input1_value_value;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$13($$self, $$props, $$invalidate) {
  let { regex } = $$props;
  let dispatch = createEventDispatcher();
  function set(key, value) {
    $$invalidate(0, regex[key] = value, regex);
    dispatch("ahange", regex);
  }
  const input_handler = (e) => set("expr", e.target.value);
  const input_handler_1 = (e) => set("flags", e.target.value);
  $$self.$$set = ($$props2) => {
    if ("regex" in $$props2)
      $$invalidate(0, regex = $$props2.regex);
  };
  return [regex, set, input_handler, input_handler_1];
}
class Regex extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$13, create_fragment$14, safe_not_equal, { regex: 0 });
  }
}
function create_if_block_3$7(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "class", "form-control xform-control-sm");
      attr(input, "type", ctx[2]);
      input.value = ctx[0];
      attr(input, "autocomplete", "off");
      attr(input, "placeholder", ctx[2]);
    },
    m(target, anchor) {
      insert(target, input, anchor);
      if (!mounted) {
        dispose = listen(input, "input", ctx[4]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 4) {
        attr(input, "type", ctx2[2]);
      }
      if (dirty & 1 && input.value !== ctx2[0]) {
        input.value = ctx2[0];
      }
      if (dirty & 4) {
        attr(input, "placeholder", ctx2[2]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_2$b(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "class", "form-control xform-control-sm");
      attr(input, "type", ctx[2]);
      input.value = ctx[0];
      attr(input, "autocomplete", "off");
      attr(input, "placeholder", ctx[2]);
    },
    m(target, anchor) {
      insert(target, input, anchor);
      if (!mounted) {
        dispose = listen(input, "input", ctx[3]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 4) {
        attr(input, "type", ctx2[2]);
      }
      if (dirty & 1 && input.value !== ctx2[0]) {
        input.value = ctx2[0];
      }
      if (dirty & 4) {
        attr(input, "placeholder", ctx2[2]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$j(ctx) {
  let regex;
  let current;
  regex = new Regex({ props: { regex: ctx[0] } });
  return {
    c() {
      create_component(regex.$$.fragment);
    },
    m(target, anchor) {
      mount_component(regex, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const regex_changes = {};
      if (dirty & 1)
        regex_changes.regex = ctx2[0];
      regex.$set(regex_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(regex.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(regex.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(regex, detaching);
    }
  };
}
function create_if_block$v(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "Unknown operator - upgrading app maybe needed";
      attr(div, "class", "error");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$13(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$v, create_if_block_1$j, create_if_block_2$b, create_if_block_3$7];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!defs[ctx2[1]])
      return 0;
    if (ctx2[2] === "regex")
      return 1;
    if (ctx2[2] == "number")
      return 2;
    if (ctx2[2] != null)
      return 3;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$12($$self, $$props, $$invalidate) {
  let { operator } = $$props;
  let { value } = $$props;
  let type = "text";
  getDef(operator);
  function updateType(operator2) {
    let def = getDef(operator2);
    $$invalidate(2, type = def.fieldType);
  }
  const input_handler = (e) => $$invalidate(0, value = e.target.valueAsNumber);
  const input_handler_1 = (e) => $$invalidate(0, value = e.target.value);
  $$self.$$set = ($$props2) => {
    if ("operator" in $$props2)
      $$invalidate(1, operator = $$props2.operator);
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2) {
      getDef(operator);
    }
    if ($$self.$$.dirty & 2) {
      updateType(operator);
    }
  };
  return [value, operator, type, input_handler, input_handler_1];
}
class Right extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$12, create_fragment$13, safe_not_equal, { operator: 1, value: 0 });
  }
}
function create_fragment$12(ctx) {
  let svg;
  let path;
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { fill: "none" },
    { viewBox: "0 0 24 24" },
    { stroke: "currentColor" },
    ctx[0]
  ];
  let svg_data = {};
  for (let i2 = 0; i2 < svg_levels.length; i2 += 1) {
    svg_data = assign$1(svg_data, svg_levels[i2]);
  }
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "stroke-linecap", "round");
      attr(path, "stroke-linejoin", "round");
      attr(path, "stroke-width", "2");
      attr(path, "d", "M6 18L18 6M6 6l12 12");
      set_svg_attributes(svg, svg_data);
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p(ctx2, [dirty]) {
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { fill: "none" },
        { viewBox: "0 0 24 24" },
        { stroke: "currentColor" },
        dirty & 1 && ctx2[0]
      ]));
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance$11($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  $$self.$$set = ($$new_props) => {
    $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
  };
  return [$$restProps];
}
class Cross extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$11, create_fragment$12, safe_not_equal, {});
  }
}
function create_fragment$11(ctx) {
  let div;
  let left;
  let updating_id;
  let t0;
  let operator;
  let updating_id_1;
  let t1;
  let right;
  let updating_value;
  let t2;
  let button;
  let cross;
  let current;
  let mounted;
  let dispose;
  function left_id_binding(value) {
    ctx[4](value);
  }
  let left_props = {};
  if (ctx[0][1] !== void 0) {
    left_props.id = ctx[0][1];
  }
  left = new Left({ props: left_props });
  binding_callbacks.push(() => bind$2(left, "id", left_id_binding));
  function operator_id_binding(value) {
    ctx[5](value);
  }
  let operator_props = { items: ctx[1] };
  if (ctx[0][0] !== void 0) {
    operator_props.id = ctx[0][0];
  }
  operator = new Operator({ props: operator_props });
  binding_callbacks.push(() => bind$2(operator, "id", operator_id_binding));
  operator.$on("select", ctx[3]);
  function right_value_binding(value) {
    ctx[6](value);
  }
  let right_props = { operator: ctx[0][0] };
  if (ctx[0][2] !== void 0) {
    right_props.value = ctx[0][2];
  }
  right = new Right({ props: right_props });
  binding_callbacks.push(() => bind$2(right, "value", right_value_binding));
  cross = new Cross({ props: { class: "h-5 w-5" } });
  return {
    c() {
      div = element("div");
      create_component(left.$$.fragment);
      t0 = space();
      create_component(operator.$$.fragment);
      t1 = space();
      create_component(right.$$.fragment);
      t2 = space();
      button = element("button");
      create_component(cross.$$.fragment);
      attr(button, "class", "btn btn-default btn-sm flex items-center px-2");
      attr(button, "title", T("a_del"));
      attr(div, "class", "flex flex-row mb-2 space-x-2 ");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(left, div, null);
      append(div, t0);
      mount_component(operator, div, null);
      append(div, t1);
      mount_component(right, div, null);
      append(div, t2);
      append(div, button);
      mount_component(cross, button, null);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[2]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const left_changes = {};
      if (!updating_id && dirty & 1) {
        updating_id = true;
        left_changes.id = ctx2[0][1];
        add_flush_callback(() => updating_id = false);
      }
      left.$set(left_changes);
      const operator_changes = {};
      if (!updating_id_1 && dirty & 1) {
        updating_id_1 = true;
        operator_changes.id = ctx2[0][0];
        add_flush_callback(() => updating_id_1 = false);
      }
      operator.$set(operator_changes);
      const right_changes = {};
      if (dirty & 1)
        right_changes.operator = ctx2[0][0];
      if (!updating_value && dirty & 1) {
        updating_value = true;
        right_changes.value = ctx2[0][2];
        add_flush_callback(() => updating_value = false);
      }
      right.$set(right_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(left.$$.fragment, local);
      transition_in(operator.$$.fragment, local);
      transition_in(right.$$.fragment, local);
      transition_in(cross.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(left.$$.fragment, local);
      transition_out(operator.$$.fragment, local);
      transition_out(right.$$.fragment, local);
      transition_out(cross.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(left);
      destroy_component(operator);
      destroy_component(right);
      destroy_component(cross);
      mounted = false;
      dispose();
    }
  };
}
function instance$10($$self, $$props, $$invalidate) {
  const dispatch = createEventDispatcher();
  let operators = Object.values(defs).map((def) => ({ ...def, name: T("l_" + def.id) })).filter((def) => !["and", "or"].includes(def.id));
  let { rule } = $$props;
  function onDel(event) {
    dispatch("delete");
  }
  function onOperatorChange(e) {
    let op = e.detail;
    let currentValue = rule[2];
    let defaultValue;
    let def = getDef(op);
    if (!def || def.fieldType == "text") {
      if (typeof currentValue == "string") {
        defaultValue = rule[2];
      } else {
        defaultValue = "";
      }
    } else if (def.fieldType == "number") {
      if (typeof currentValue == "number") {
        defaultValue = currentValue;
      } else {
        defaultValue = 0;
      }
    } else {
      if (def.defaultValue) {
        defaultValue = def.defaultValue();
      } else if (def.fieldType != null) {
        throw new Error("cant set default value for rule def:" + def.id);
      }
    }
    $$invalidate(0, rule[2] = defaultValue, rule);
    dispatch("operatorChange", op);
  }
  function left_id_binding(value) {
    if ($$self.$$.not_equal(rule[1], value)) {
      rule[1] = value;
      $$invalidate(0, rule);
    }
  }
  function operator_id_binding(value) {
    if ($$self.$$.not_equal(rule[0], value)) {
      rule[0] = value;
      $$invalidate(0, rule);
    }
  }
  function right_value_binding(value) {
    if ($$self.$$.not_equal(rule[2], value)) {
      rule[2] = value;
      $$invalidate(0, rule);
    }
  }
  $$self.$$set = ($$props2) => {
    if ("rule" in $$props2)
      $$invalidate(0, rule = $$props2.rule);
  };
  return [
    rule,
    operators,
    onDel,
    onOperatorChange,
    left_id_binding,
    operator_id_binding,
    right_value_binding
  ];
}
class Condition extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$10, create_fragment$11, safe_not_equal, { rule: 0 });
  }
}
function createStore(rules) {
  const { subscribe: subscribe2, set, update } = writable(["or"]);
  set(rules);
  return {
    subscribe: subscribe2,
    set,
    update,
    onAddRuleGrp: function(idxRuleGrp) {
      update((value) => (value[idxRuleGrp + 1].push(["contains", "$new", ""]), value));
    },
    addOrCondition: function() {
      update((value) => (value.push(["and", ["contains", "$new", ""]]), value));
    },
    onRemoveRule: function(idxRuleGrp, idxRule) {
      idxRuleGrp += 1;
      idxRule += 1;
      update((value) => {
        value[idxRuleGrp].splice(idxRule, 1);
        if (value[idxRuleGrp].length === 1) {
          value[idxRuleGrp].splice(0, 1);
          value.splice(idxRuleGrp, 1);
        }
        return value;
      });
    },
    addRule: function() {
      update((value) => {
        if (value.length === 0) {
          value.push("or");
        }
        value.push(["and", ["contains", "$new", "", void 0]]);
        return value;
      });
    }
  };
}
function create_fragment$10(ctx) {
  let svg;
  let path;
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { fill: "none" },
    { viewBox: "0 0 24 24" },
    { stroke: "currentColor" },
    ctx[0]
  ];
  let svg_data = {};
  for (let i2 = 0; i2 < svg_levels.length; i2 += 1) {
    svg_data = assign$1(svg_data, svg_levels[i2]);
  }
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "stroke-linecap", "round");
      attr(path, "stroke-linejoin", "round");
      attr(path, "stroke-width", "2");
      attr(path, "d", "M12 6v6m0 0v6m0-6h6m-6 0H6");
      set_svg_attributes(svg, svg_data);
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p(ctx2, [dirty]) {
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { fill: "none" },
        { viewBox: "0 0 24 24" },
        { stroke: "currentColor" },
        dirty & 1 && ctx2[0]
      ]));
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance$$($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  $$self.$$set = ($$new_props) => {
    $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
  };
  return [$$restProps];
}
class Plus extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$$, create_fragment$10, safe_not_equal, {});
  }
}
function get_each_context$j(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list[i2];
  child_ctx[12] = i2;
  return child_ctx;
}
function get_each_context_1$2(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list[i2];
  child_ctx[15] = i2;
  return child_ctx;
}
function create_else_block$k(ctx) {
  let div1;
  let div0;
  let t1;
  let t2;
  let current;
  let each_value = ctx[1].slice(1);
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$j(get_each_context$j(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  let if_block = ctx[2] && create_if_block_1$i(ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      div0.textContent = `${T("l_continue_only")}`;
      t1 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t2 = space();
      if (if_block)
        if_block.c();
      attr(div1, "class", "flex flex-col m-2");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div1, t1);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(div1, null);
      }
      append(div1, t2);
      if (if_block)
        if_block.m(div1, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 14) {
        each_value = ctx2[1].slice(1);
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$j(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$j(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div1, t2);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$i(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div1, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(if_block);
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_each(each_blocks, detaching);
      if (if_block)
        if_block.d();
    }
  };
}
function create_if_block$u(ctx) {
  let a;
  let mounted;
  let dispose;
  return {
    c() {
      a = element("a");
      a.textContent = `${SPRINTF("a_action_object", "a_add", "l_rule")}`;
      attr(a, "href", "javascript:void(0)");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      if (!mounted) {
        dispose = listen(a, "click", prevent_default(ctx[3].addRule));
        mounted = true;
      }
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(a);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block_1$2(ctx) {
  let condition;
  let current;
  function delete_handler() {
    return ctx[5](ctx[12], ctx[15]);
  }
  condition = new Condition({ props: { rule: ctx[13] } });
  condition.$on("delete", delete_handler);
  condition.$on("operatorChange", ctx[6]);
  return {
    c() {
      create_component(condition.$$.fragment);
    },
    m(target, anchor) {
      mount_component(condition, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const condition_changes = {};
      if (dirty & 2)
        condition_changes.rule = ctx[13];
      condition.$set(condition_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(condition.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(condition.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(condition, detaching);
    }
  };
}
function create_if_block_3$6(ctx) {
  let button;
  let plus;
  let t0;
  let t1_value = T("l_or") + "";
  let t1;
  let current;
  let mounted;
  let dispose;
  plus = new Plus({ props: { class: "h-5 w-5" } });
  return {
    c() {
      button = element("button");
      create_component(plus.$$.fragment);
      t0 = space();
      t1 = text(t1_value);
      attr(button, "class", "btn btn-default btn-xs w-24 flex items-center");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      mount_component(plus, button, null);
      append(button, t0);
      append(button, t1);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[3].addOrCondition);
        mounted = true;
      }
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(plus.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(plus.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(button);
      destroy_component(plus);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_2$a(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = `${T("l_continue_or")}`;
      attr(div, "class", "mt-4");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_each_block$j(ctx) {
  let t0;
  let div;
  let button;
  let plus;
  let t1;
  let t2_value = T("l_and") + "";
  let t2;
  let t3;
  let t4;
  let if_block1_anchor;
  let current;
  let mounted;
  let dispose;
  let each_value_1 = ctx[10].slice(1);
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  plus = new Plus({ props: { class: "h-5 w-5" } });
  function click_handler2() {
    return ctx[7](ctx[12]);
  }
  let if_block0 = ctx[12] + 2 === ctx[1].length && create_if_block_3$6(ctx);
  let if_block1 = ctx[12] + 2 !== ctx[1].length && create_if_block_2$a();
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t0 = space();
      div = element("div");
      button = element("button");
      create_component(plus.$$.fragment);
      t1 = space();
      t2 = text(t2_value);
      t3 = space();
      if (if_block0)
        if_block0.c();
      t4 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
      attr(button, "class", "btn btn-default btn-xs w-24 flex items-center");
      attr(div, "class", "flex flex-row space-x-2");
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(target, anchor);
      }
      insert(target, t0, anchor);
      insert(target, div, anchor);
      append(div, button);
      mount_component(plus, button, null);
      append(button, t1);
      append(button, t2);
      append(div, t3);
      if (if_block0)
        if_block0.m(div, null);
      insert(target, t4, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", click_handler2);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 14) {
        each_value_1 = ctx[10].slice(1);
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$2(ctx, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_1$2(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(t0.parentNode, t0);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (ctx[12] + 2 === ctx[1].length) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
          if (dirty & 2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_3$6(ctx);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, null);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx[12] + 2 !== ctx[1].length) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
        } else {
          if_block1 = create_if_block_2$a();
          if_block1.c();
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(plus.$$.fragment, local);
      transition_in(if_block0);
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(plus.$$.fragment, local);
      transition_out(if_block0);
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div);
      destroy_component(plus);
      if (if_block0)
        if_block0.d();
      if (detaching)
        detach(t4);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(if_block1_anchor);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$i(ctx) {
  let numberformat;
  let updating_format;
  let current;
  function numberformat_format_binding(value) {
    ctx[8](value);
  }
  let numberformat_props = { class: "mt-4" };
  if (ctx[0] !== void 0) {
    numberformat_props.format = ctx[0];
  }
  numberformat = new NumberFormat({ props: numberformat_props });
  binding_callbacks.push(() => bind$2(numberformat, "format", numberformat_format_binding));
  return {
    c() {
      create_component(numberformat.$$.fragment);
    },
    m(target, anchor) {
      mount_component(numberformat, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const numberformat_changes = {};
      if (!updating_format && dirty & 1) {
        updating_format = true;
        numberformat_changes.format = ctx2[0];
        add_flush_callback(() => updating_format = false);
      }
      numberformat.$set(numberformat_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(numberformat.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(numberformat.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(numberformat, detaching);
    }
  };
}
function create_fragment$$(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$u, create_else_block$k];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!ctx2[1] || ctx2[1].length <= 1)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$_($$self, $$props, $$invalidate) {
  let $store;
  let { config = { rules: [] } } = $$props;
  let dispatch = createEventDispatcher();
  let numberFormat = config.numberFormat;
  let store2 = createStore(config.rules);
  component_subscribe($$self, store2, (value) => $$invalidate(1, $store = value));
  let showNumFormat = false;
  const delete_handler = (idxRuleGrp, idxRule) => store2.onRemoveRule(idxRuleGrp, idxRule);
  const operatorChange_handler = (e) => $$invalidate(2, showNumFormat = hasNumeric($store));
  const click_handler2 = (idxRuleGrp) => store2.onAddRuleGrp(idxRuleGrp);
  function numberformat_format_binding(value) {
    numberFormat = value;
    $$invalidate(0, numberFormat);
  }
  $$self.$$set = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(4, config = $$props2.config);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 3) {
      dispatch("change", { rules: $store, numberFormat });
    }
    if ($$self.$$.dirty & 2) {
      $$invalidate(2, showNumFormat = hasNumeric($store));
    }
  };
  return [
    numberFormat,
    $store,
    showNumFormat,
    store2,
    config,
    delete_handler,
    operatorChange_handler,
    click_handler2,
    numberformat_format_binding
  ];
}
class Edit_rule extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$_, create_fragment$$, safe_not_equal, { config: 4 });
  }
}
const SieveRulesEditorV2 = View$1.ActionProvider.extend({
  name: "SieveRulesEditorV2",
  render: function() {
    let body;
    this.$el.append(body = DIV({ style: "max-height: 600px;" }));
    this.$body = $(body);
    this.renderRules();
    return this;
  },
  renderRules: function() {
    this.config = this.model.get("config");
    this.$body.empty();
    this.view = new Edit_rule({
      target: this.el,
      props: {
        config: this.config
      }
    });
    this.view.$on("change", (e) => this.config = e.detail);
  },
  remove() {
    SieveRulesEditorV2.__super__.remove.call(this);
    this.view.$destroy();
  },
  updateModel: function() {
    this.model.set("config", this.config);
  }
});
function create_fragment$_(ctx) {
  let div;
  let p0;
  let t1;
  let p1;
  return {
    c() {
      div = element("div");
      p0 = element("p");
      p0.textContent = "Please upgrade to the latest version of app/extension.";
      t1 = space();
      p1 = element("p");
      p1.textContent = `This condition was created using a newer version of the app which is not supported by this version. Current version is ${ctx[0]}`;
      attr(div, "class", "p-2 text-base");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, p0);
      append(div, t1);
      append(div, p1);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function instance$Z($$self) {
  let currentVersion = Supports.agents && Supports.agents.local ? serviceProxy.CFG.VERSION : "1.0.0";
  return [currentVersion];
}
class VersionUpdateMsg extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$Z, create_fragment$_, safe_not_equal, {});
  }
}
const { V1, V2 } = Model$2.SieveRule;
const SieveRuleWrapper = View$1.ActionProvider.extend({
  name: "SieveRuleWrapper",
  actions: {
    action_global_rules: { fn: "action_global_rules" }
  },
  action_global_rules() {
    showGlobalRuleEditor();
  },
  postInit(options) {
    if (!this.model.isNew()) {
      this.loading = true;
      this.model.fetch({
        success: this.onLoad,
        error: this.onError
      });
    }
    this.listenTo(this.model, "change:version", this.renderEditor);
    this.listenTo(App.user, "change:prefs", this.renderGlobalCount);
  },
  onError() {
    this.loading = false;
    this.$body.empty();
    this.$body.append(T("e_req"), " ", T("h_try_later"));
  },
  onLoad() {
    this.loading = false;
    this.renderEditor();
  },
  getGlobalRuleModel() {
    var _a;
    let config = (_a = App.user.get("prefs")) == null ? void 0 : _a.rule;
    let version = (config == null ? void 0 : config.version) || V1;
    return new Model$2.SieveRule({ config, version });
  },
  render() {
    let elVersion;
    this.$el.append(DIV({ class: "flex gap-4" }, elVersion = DIV({ class: "dropdown relative" }), this.options.global ? "" : A({
      href: "#",
      "data-action": "action_global_rules"
    }, "Global Conditions: ", this.elGlobalCount = SPAN())), this.$body = $(DIV()));
    this.$elVersion = $(elVersion);
    this.$elVersion.on("click", "li", this.onVersionSelection);
    this.renderGlobalCount();
    if (this.loading) {
      this.$body.text(T("l_loading"));
    } else {
      this.renderEditor();
    }
    return this;
  },
  renderGlobalCount() {
    let globalRule = this.getGlobalRuleModel();
    $(this.elGlobalCount).text(globalRule.getCount());
  },
  onVersionSelection(e) {
    this.model.setVersion(e.target.id);
    e.preventDefault();
  },
  renderEditor() {
    let version = this.model.get("version");
    if (USER.features.rule_default) {
      this.renderVersion(version);
    } else {
      this.$elVersion.remove();
    }
    const $el = this.$body;
    $el.empty();
    if (version && version !== V1 && version !== V2) {
      new VersionUpdateMsg({ target: this.$el[0] });
    } else if (version === V1) {
      this.editor = new SieveRulesEditorV1({ ...this.options, parent: this }).render();
      $el.append(this.editor.el);
    } else {
      this.editor = new SieveRulesEditorV2({ ...this.options, parent: this }).render();
      $el.append(this.editor.el);
    }
  },
  renderVersion(version) {
    const href2 = "javascript: void 0";
    this.$elVersion.empty().append(A({ href: href2, class: "dropdown-toggle", "data-toggle": "dropdown" }, `Version: v${version[0]}`, " ", B({ class: "caret" })), UL({ class: "dropdown-menu" }, LI({ class: "dropdown-header" }, "Change condition version"), LI({ class: version == V1 ? "active" : "" }, A({ href: href2, id: V1 }, `v${V1[0]} (classic)`)), LI({ class: version == V2 ? "active" : "" }, A({ href: href2, id: V2 }, `v${V2[0]} (modern)`))));
  },
  async duplicate(fromId) {
    const model = new Model$2.SieveRule({ id: fromId });
    await model.fetch({
      success: () => {
        this.model.set(_.omit(model.attributes, "id", "ts", "ts_mod"));
        this.onLoad();
      }
    });
  },
  updateModel() {
    if (this.editor) {
      this.editor.updateModel();
    }
  }
});
async function showGlobalRuleEditor() {
  if (!USER.id) {
    return alert("Please sign in to save global conditions");
  }
  let prefs = App.user.get("prefs") || {};
  let config = prefs.rule;
  let version = (config == null ? void 0 : config.version) || V1;
  let model = new Model$2.SieveRule({ config, version });
  let view = new SieveRuleWrapper({ model, global: true, parent: App.root });
  const modal = new View$1.SaveDiscardModal({
    name: "GlobalRuleEditor$SaveDiscardModal",
    title: "Global Conditions",
    titleEx: `used for all monitors and combined with each monitor's conditions`,
    view,
    parent: App.root
  });
  modal.on("save", async () => {
    modal.remove();
    view.updateModel();
    let config2 = model.get("config");
    let version2 = model.get("version");
    try {
      await Api.api("/prefs/rule", "PUT", { ...config2, version: version2 });
      USER.prefs.rule = config2;
    } catch (e) {
      console.error(e);
      Msg.error("Failed to save data, please try again later");
    }
  });
  modal.on("discard", () => {
    modal.remove();
  });
  modal.show();
}
const Backbone$4 = window.Backbone;
function getInterval($el, defaultUnit = "m", defaultValue = 120) {
  const units = { "s": 1, "m": 60, "h": 3600, "d": 86400, "w": 604800 };
  const parts = $el.val().trim().replace(/\s+/g, "").split(/(\d*\.*\d*)/);
  const num = parseInt(parts[1]) || defaultValue;
  const unit = (parts[2] || "").toLowerCase()[0] || defaultUnit;
  const value = num * units[unit];
  return value;
}
const WEEK_DAY_INDEX = ["Sunday", "Monday", "Tuesday", "Thursday", "Friday", "Saturday", "Sunday"];
const MONTH_INDEX = ["", "Jan", "Feb", "March", "April", "May", "June", "July", "August", "Sep", "Oct", "Nov", "Dec"];
class SieveCronScheduleEditor extends Base$3 {
  constructor(options) {
    super({
      ...options.model.toJSON(),
      params: options.model.get("schedule").toJSON().params
    });
    this.model = options.model;
    this.schedule = this.model.get("schedule");
    this.el.classList.add("xtype-group");
    this.el.classList.add("inline-block");
    this.el.style.minWidth = "480px";
  }
  onChange(name, value) {
    const index2 = ["m", "h", "dm", "mon", "dw"].indexOf(name);
    const params2 = { ...this.state.params };
    const { expr } = params2;
    const parts = expr.split(/\s/g);
    parts[index2] = value;
    params2.expr = parts.join(" ");
    this.state.params = params2;
    if (parts.length == 5 && _.all(parts, (p) => p.length > 0)) {
      this.setModelParams(params2);
    }
  }
  onPresetClick(e) {
    e.preventDefault();
    const params2 = { ...this.state.params };
    params2.expr = e.target.dataset.expr;
    this.state.params = params2;
    this.setModelParams(params2);
  }
  setModelParams(params2) {
    this.schedule.set("params", new Backbone$4.Model(params2));
    this.model.trigger("change:schedule", this.schedule);
  }
  getDesc({ m, h, dm, mon, dw }) {
    function unit(name, val) {
      if (val.includes(",")) {
        const parts = val.split(",").map((expr) => unit(name, expr));
        const last = parts.pop();
        return `${parts.join(", ")} and ${last}`;
      }
      if ("*" == val) {
        return `every ${name}`;
      }
      if (val.includes("-")) {
        let [start, end] = val.split("-");
        if (name == "month") {
          start = MONTH_INDEX[start];
          end = MONTH_INDEX[end];
        }
        if (name == "day-of-week") {
          start = WEEK_DAY_INDEX[start];
          end = WEEK_DAY_INDEX[end - 1];
        }
        return `every ${name} from ${start} through ${end}`;
      }
      if (val.includes("/")) {
        let [start, step] = val.split("/");
        const end = "";
        let startText = "every";
        if (step > 1) {
          const suffixes = ["", "st", "nd", "rd"];
          startText = step + (suffixes[step] || "th");
        }
        if ("*" == start) {
          start = null;
        } else if (name == "month") {
          start = MONTH_INDEX[start];
        } else if (name == "day-of-week") {
          start = WEEK_DAY_INDEX[start];
        }
        return `every  ${startText} ${name} ${start ? `from ${start} through ${end}` : ""}`;
      }
      if (name == "month") {
        val = MONTH_INDEX[val];
        name = "";
      }
      if (name == "day-of-week") {
        val = WEEK_DAY_INDEX[val];
        name = "";
      }
      return `${name} ${val}`;
    }
    try {
      return `At ${unit("minute", m)} past ${unit("hour", h)} on ${unit("day-of-week", dw)} in ${unit("month", mon)}`;
    } catch (e) {
      console.error(e, arguments[0]);
      return "Invalid expression";
    }
  }
  createTpl({ params: params2 }) {
    const expr = params2.expr;
    params2.tz || new Date().getTimezoneOffset();
    const [m, h, dm, mon, dw] = expr.split(/\s/g);
    const attrMap = { m, h, dm, mon, dw };
    const desc = this.getDesc(attrMap);
    const names = {
      m: "Minute",
      h: "Hour",
      dm: "Day",
      mon: "Month",
      dw: "Weekday"
    };
    return html`
      <table>
        <thead>
          ${_.map(names, (name, key) => {
      return html`<th class='col-md-2'>${name}</th>`;
    })}
          <th></th>
        </thead>
        <tbody>
          <tr>
            ${_.map(names, (name, key) => {
      return html`
                <td class='col-md-2'>
                  <input
                    style='width: 60px; padding: 0 10px;'
                    .value=${attrMap[key]}
                    placeholder=${name}
                    @keyup=${(e) => this.onChange(key, e.target.value)}>
                  </input>
                </td>
                `;
    })}
            <td>
              <div class='dropdown'>
                <a href='#' data-toggle='dropdown'>Use Preset <i class='fa fa-caret-down'></i></a>
                <ul class='dropdown-menu' @click=${(e) => this.onPresetClick(e)}>
                  <li><a href='#' data-expr='0 9 * * 1-5'>Weekdays at 9am</a></li>
                  <li><a href='#' data-expr='0 9-17 * * 1-5'>Weekdays between 9am to 5pm</a></li>
                  <li><a href='#' data-expr='0 9 * * *'>All days at 9am</a></li>
                  <li><a href='#' data-expr='0 9-17 * * *'>All days between 9am to 5pm</a></li>
                </ul>
              </div>
            </td>
          </tr>
          <tr>
            <td 
              style='width: 60px; padding: 0 12px;'
              colspan=6><div class='help'>
                ${desc}
              </div>
            </td>
          </tr>
        </tbody>
      </table>
    `;
  }
  remove() {
  }
  render() {
    return this;
  }
}
var SieveIntervalScheduleEditor = View$1.ActionProvider.extend({
  name: "SieveIntervalScheduleEditor",
  convertToSlider: function(v) {
    return Math.log(v);
  },
  convertToModel: function(v) {
    return Math.round(Math.pow(Math.E, v));
  },
  focus: function() {
    this.textInput.focus();
  },
  getSliderValue: function() {
    return this.convertToModel(this.$slider.val());
  },
  setSliderValue: function(value) {
    this.$slider.slider("setValue", this.convertToSlider(value));
  },
  remove: function() {
    if (this.$slider.data("slider")) {
      this.$slider.slider("destroy");
    }
    SieveIntervalScheduleEditor.__super__.remove.call(this);
  },
  render: function() {
    const schedule = this.model.get("schedule");
    const params2 = schedule.get("params");
    const interval = params2.get("interval");
    const value = this.convertToSlider(interval);
    this.$el.empty().append(DIV({ style: "display:flex;min-width:420px;margin-bottom:25px;" }, this.slider = INPUT({
      style: "width:100%;",
      value
    }), this.textInput = INPUT({ "class": "xschdlr-input" })), SPAN({ "class": "help" }, this.constraint = SPAN({ style: "color: red; display: none;" }, T("h_schedule_constraint_1"), T(schedule.formatInterval(USER.constraint.interval, false) + "."), BR(), T("h_schedule_constraint_2"), A({ "href": "https://distill.io/pricing", "target": "_blank" }, "Upgrade Account"))), P({ "class": "help" }, T("h_schedule_interval")));
    this.$constraint = $(this.constraint);
    this.$slider = $(this.slider).slider({
      min: 1.6,
      max: 14.78,
      step: 0.05,
      tooltip: "hide",
      value,
      "ticks": [1.6, 3.4, 5.7, 8.3, 11.55, 14.78],
      "ticks_positions": [0, 13.657, 31.107, 50.834, 75.493, 100],
      "ticks_labels": ["5s", "30s", "5m", "1h", "1d", "Never"],
      "ticks_snap_bounds": 0
    }).on("slide", this.updateValue).on("slideStop", this.updateModel);
    this.$textInput = $(this.textInput).on("change", this.textInputChanged).on("focus", function() {
      this.select();
    });
    this.updateValue();
    return this;
  },
  textInputChanged: function() {
    const value = getInterval(this.$textInput, "m", 3600);
    this.setSliderValue(value);
    this.updateValue();
    this.updateModel();
  },
  updateModel: function() {
    this.updateValue();
    const schedule = this.model.get("schedule");
    this.model.trigger("change");
    this.model.trigger("change:schedule", schedule);
  },
  updateValue: function() {
    const seconds = this.getSliderValue();
    const client_id = this.model.get("client_id");
    const schedule = this.model.get("schedule");
    const params2 = schedule.get("params");
    const constraint = USER && USER.constraint;
    const minInt = constraint && constraint.interval || 5;
    if (client_id == ModelClient.Clients.webAppId && seconds < minInt) {
      params2.set("interval", USER.constraint.interval);
      this.$constraint.css("display", "block");
    } else {
      params2.set("interval", seconds);
      this.$constraint.css("display", "none");
    }
    this.$textInput.val(schedule.getShortDisplayText());
  }
});
const SieveLiveScheduleEditor = View$1.ActionProvider.extend({
  name: "SieveLiveScheduleEditor",
  render: function() {
    this.$el.append(DIV("Use it only if page auto-updates content using JavaScript."), DIV({ "class": "help" }, T("l_schedule_live_desc")));
    return this;
  }
});
const SieveRandomScheduleEditor = View$1.ActionProvider.extend({
  name: "SieveRandomScheduleEditor",
  render: function() {
    const schedule = this.model.get("schedule");
    const params2 = schedule.get("params");
    this.$el.empty().append(DIV(SPAN("Min: "), this.minInput = INPUT({ "class": "xschdlr-input" }), SPAN({ style: "margin-left: 20px;" }, "Max: "), this.maxInput = INPUT({ "class": "xschdlr-input" })), SPAN({ "class": "help" }, this.constraint = SPAN({ style: "color: black; display: none;" }, T("h_schedule_constraint_1"), T(USER.constraint.interval + " seconds. "), BR(), T("h_schedule_constraint_2"), A({ "href": "https://distill.io/pricing", "target": "_blank" }, "Upgrade Account"))), P({ "class": "help" }, T("h_schedule_random")));
    this.$constraint = $(this.constraint);
    (this.$minInput = $(this.minInput)).val(params2.get("min"));
    (this.$maxInput = $(this.maxInput)).val(params2.get("max"));
    $([this.minInput, this.maxInput]).on("change", this.updateModel);
    this.updateValue();
    return this;
  },
  updateModel: function() {
    this.updateValue();
    const schedule = this.model.get("schedule");
    this.model.trigger("change");
    this.model.trigger("change:schedule", schedule);
  },
  updateValue: function() {
    if (getInterval(this.$minInput, "s") > getInterval(this.$maxInput, "s")) {
      var maxSecs = Math.max(this.model.get("client_id") == ModelClient.Clients.webAppId ? USER.constraint.interval : 5, getInterval(this.$minInput, "s") + 1);
    } else {
      var maxSecs = Math.max(this.model.get("client_id") == ModelClient.Clients.webAppId ? USER.constraint.interval : 5, getInterval(this.$maxInput, "s"));
    }
    const minSecs = Math.max(this.model.get("client_id") == ModelClient.Clients.webAppId ? USER.constraint.interval : 5, getInterval(this.$minInput, "s"));
    const schedule = this.model.get("schedule");
    const params2 = schedule.get("params");
    const client_id = this.model.get("client_id");
    const constraint = USER && USER.constraint;
    constraint && constraint.interval || 5;
    params2.set("min", minSecs);
    params2.set("max", maxSecs);
    this.$minInput.val(minSecs);
    this.$maxInput.val(maxSecs);
    if (client_id == ModelClient.Clients.webAppId) {
      this.$constraint.css("display", "block");
    } else {
      this.$constraint.css("display", "none");
    }
  }
});
var SieveScheduleEditor = View$1.ActionProvider.extend({
  name: "SieveScheduleEditor",
  EDITORS: {
    "INTERVAL": SieveIntervalScheduleEditor,
    "LIVE": SieveLiveScheduleEditor,
    "RANDOM": SieveRandomScheduleEditor,
    "CRON": SieveCronScheduleEditor
  },
  focus: function() {
  },
  render: function() {
    let elSelect;
    let elEditor;
    var schedule = this.model.get("schedule");
    const type = schedule.get("type");
    Supports.agents.local;
    var schedule = this.model.get("schedule");
    let editor = new this.EDITORS[type](_.extend({ parent: this }, this.options));
    this.$el.css({
      "display": "flex",
      "flex-direction": "row"
    }).empty().append(DIV(elSelect = SELECT({ style: "margin-right: 20px;" }, OPTION({ value: "INTERVAL" }, "Interval"), OPTION({ value: "RANDOM" }, "Random"), OPTION({ value: "LIVE" }, "Live (beta)"), USER.account_id ? OPTION({ value: "CRON" }, "Crontab *") : OPTION({ value: "CRON", disabled: "" }, "Crontab *"), OPTION({ value: "", disabled: "" }, "*For Enterprise"))), elEditor = DIV({ style: "flex:1" }, editor.render().el));
    $(elSelect).val(type).on("change", () => {
      const type2 = elSelect.value;
      const schedule2 = new Model$2.Schedule({ type: type2 });
      if (type2 == "RANDOM") {
        schedule2.get("params").set({ min: 60, max: 120 });
      }
      if (type2 == "CRON") {
        schedule2.get("params").set({
          expr: "* * * * *",
          tz: new Date().getTimezoneOffset()
        });
      }
      editor.remove();
      this.model.set("schedule", schedule2);
      this.model.trigger("change:schedule", schedule2);
      editor = new this.EDITORS[type2](_.extend({ parent: this }, this.options));
      $(elEditor).empty().append(editor.render().el);
    });
    return this;
  }
});
var TagsEditor = View$1.Base.extend({
  name: "TagsEditor",
  className: "flex flex-wrap",
  events: {
    "click :checkbox": "event_check"
  },
  event_check: function(e) {
    const el = e.target;
    const id2 = el.dataset.id;
    const checked = el.checked;
    const tag = App.labels.get(id2);
    if (checked) {
      this.tags.push(tag);
    } else {
      this.tags = _.without(this.tags, tag);
    }
    this.model.set("tags", _.pluck(this.tags, "id").join(","));
  },
  postInit: function() {
    this.tags = this.model.getTags(App.labels);
    this.listenTo(App.labels, "sync", this.render);
  },
  render: function() {
    this.$el.empty();
    if (App.labels.length > 0) {
      this.$el.append(_.map(App.labels.models, (tag) => {
        const input = INPUT({
          "type": "checkbox",
          "style": "vertical-align: top; margin: 0 4px;",
          "data-id": tag.id
        });
        const el = LABEL({
          "class": "flex font-normal mr-2"
        }, input, tag.get("name"));
        if (this.tags.indexOf(tag) >= 0) {
          input.checked = true;
        }
        return el;
      }));
    } else {
      this.$el.append("No label found.");
    }
    return this;
  }
});
const domo$4 = window.domo;
if (!domo$4) {
  throw new Error("ADD domo");
}
function SieveConstraints(constraint) {
  return DIV({ "class": "xmonitor-limit" }, DIV({ "class": "alert alert-danger" }, SPRINTF("m_monitor_constraint_1", constraint.count, constraint.limit), " ", SPRINTF("m_monitor_constraint_2"), UL(LI(A({ href: urls.watchlist }, I({ "class": "fa fa-link" }), " ", SPRINTF("a_go_to_watchlist")), ": ", SPRINTF("m_monitor_constraint_3")), LI(A({ href: urls.billing }, I({ "class": "fa fa-link" }), " ", SPRINTF("a_go_to_billing")), ": ", SPRINTF("m_monitor_constraint_4")))));
}
const $$5 = window.jQuery;
if (!$$5) {
  throw new Error("ADD jQuery");
}
const _$5 = window._;
if (!_$5) {
  throw new Error("ADD _");
}
const domo$3 = window.domo;
if (!domo$3) {
  throw new Error("ADD domo");
}
const async$4 = window.async;
if (!async$4) {
  throw new Error("ADD async");
}
const FeedFinder = View$1.ActionProvider.extend({
  events: {
    "keypress input": "event_load",
    "click .xtbar .btn.xload": "event_loadFeed",
    "click .xtbar .btn.xadd": "event_add"
  },
  event_add: function(event) {
    if (this.feed) {
      const uri = this.url;
      const attrs = this.feed.attributes;
      this.trigger("save", {
        name: attrs.title,
        uri: attrs.link,
        content_type: C.TYPE_FEED,
        config: {
          uri
        }
      });
    } else {
      this.error("Feed could not be loaded or parsed.");
    }
  },
  event_load: function(event) {
    if (event.keyCode == 13) {
      this.loadURL(this.$(".xurl").val());
    }
  },
  event_loadFeed: function(event) {
    const url = event.target.getAttribute("href");
    this.$(".xurl").val(url);
    this.$(".xtbar").empty();
    this.loadURL(url);
  },
  error: function(msg) {
    this.$(".xmsg").addClass("xerror").text(msg ? T(msg) : "");
  },
  msg: function(msg) {
    this.$(".xmsg").removeClass("xerror").text(msg ? T(msg) : "");
  },
  postInit(options) {
    FeedFinder.__super__.postInit.call(this, options);
    let query = get_store_value(route).query;
    this.url = query.url || "";
    if (this.url) {
      this.loadURL(this.url);
    }
  },
  loadURL(url) {
    this.msg("");
    if (url.indexOf(":") < 0) {
      url = "http://" + url;
    }
    if (!/[-a-zA-Z0-9@:%_\+.~#?&//=]{2,256}\.[a-z]{2,4}\b(\/[-a-zA-Z0-9@:%_\+.~#?&//=]*)?/gi.test(url)) {
      this.error("m_enter_valid_url");
      return;
    }
    this.url = url;
    if (this.feedView) {
      this.feedView.remove();
    }
    this.$(".xtbar").empty();
    this.msg("l_loading");
    fetchResource$1(url, (err, xhrObj) => {
      if (err) {
        this.error("e_load_source");
        return;
      }
      let response = xhrObj.response;
      let contentType = xhrObj.headers["content-type"];
      contentType = contentType.split(";")[0];
      if (response.nodeType === Node.DOCUMENT_NODE) {
        response = response.documentElement.outerHTML;
      }
      switch (contentType) {
        case "text/html":
        case "application/xhtml+xml":
          this.msg("m_feed_finding");
          var parser = new DOMParser();
          var doc = parser.parseFromString(response, contentType);
          if (!doc) {
            const htmlFramgment = res.match(/<link.*\/>/gim).join("");
            doc = parser.parseFromString(htmlFramgment, contentType);
          }
          findFeeds(doc, (err2, feedLinks) => {
            if (feedLinks.length == 0) {
              this.error("e_feed_in_page_na");
            } else if (feedLinks.length == 1) {
              const newURL = feedLinks[0].href;
              this.$(".xurl").val(newURL);
              this.loadURL(newURL);
            } else {
              this.showFeedSelectionList(feedLinks);
            }
          });
          break;
        case "application/xml":
        case "text/xml":
        case "application/rss+xml":
        case "application/atom+xml":
          this.msg("Parsing feed...");
          parseFeed(response, this.url, this.onParsedFeed);
          break;
        default:
          this.error(SPRINTF("e_unknown_content_type", contentType));
          break;
      }
    });
  },
  onParsedFeed: function(err, result) {
    this.msg("");
    if (err) {
      this.error(T("m_try_later") + " " + T("e_load_source"));
    } else {
      result = JSON.parse(JSON.stringify(result));
      this.feed = new Model$1.Feed(result, { parse: true });
      if (this.feedView) {
        this.feedView.remove();
      }
      this.feedView = new View.Feed({
        el: $$5("#feed")[0],
        model: this.feed,
        parent: this
      }).render();
      this.$el.append(this.feedView.el);
      this.$(".xtbar").empty().append(BUTTON({ "class": "btn btn-primary xadd" }, T("a_select")));
    }
  },
  render: function() {
    this.$el.empty().append(DIV(DIV(INPUT({
      "class": "form-control xurl",
      placeholder: T("m_enter_feed_url"),
      value: this.url
    })), DIV({ "class": "xmsg inline-block", "style": "margin: 5px 0;padding: 0 5px;" }), DIV({ "class": "xtbar " }), DIV({ "class": "xpreview" })));
    return this;
  },
  showFeedSelectionList: function(feedLinks) {
    this.msg("m_feed_multi_selection");
    this.$(".xtbar").empty().append(_$5.map(feedLinks, function(feedLink) {
      return BUTTON({
        "class": "btn btn-primary xload",
        "href": feedLink.href
      }, T("Load feed") + " - " + feedLink.title);
    }));
  }
});
function findFeeds(htmlDoc, callback) {
  if (!htmlDoc) {
    return callback({
      code: "NULL",
      msg: "HTML document is null"
    });
  }
  const result = htmlDoc.querySelectorAll('link[type="application/rss+xml"],link[type="application/atom+xml"]');
  const feedLinks = _$5.map(result, function(link) {
    return {
      title: link.getAttribute("title"),
      href: link.getAttribute("href")
    };
  });
  callback(null, feedLinks);
}
async function parseFeed(text2, url, callback) {
  if (Supports.agents.local) {
    try {
      let doc = await serviceProxy.Feed.fromString(text2, url);
      callback(null, doc);
    } catch (err) {
      console.error("Error parsing feed", err);
      callback(err);
    }
  } else {
    $$5.post(`${URL_UTILS}/v1/feed/json`, {
      text: text2
    }, function(data, status, xhr) {
      callback(xhr.status != 200 ? "Error parsing feed" : null, data);
    });
  }
}
async function fetchResource$1(url, callback) {
  if (Supports.agents.local) {
    try {
      let res2 = await serviceProxy.HTTP.get({ url });
      callback(null, res2);
    } catch (err) {
      callback(err);
    }
  } else {
    try {
      let response = await Api.utils(`/v1/http/get?url=${encodeURIComponent(url)}`);
      callback(null, { response, headers: Api.headers });
    } catch (e) {
      callback(e);
    }
  }
}
const _$4 = window._;
if (!_$4) {
  throw new Error("ADD _");
}
const Selector$2 = View$1.Base.extend({
  tagName: "div",
  events: {
    "click": "event_click"
  },
  close() {
    this.loader && this.loader.destroy();
  },
  event_click() {
    this.loader && chrome.tabs.update(this.loader.tabId, {
      active: true
    });
  },
  render() {
    this.$el.text(T("h_opening_selector_in_new_tab"));
    setTimeout(() => {
      try {
        this.renderTab();
      } catch (err) {
        console.error("Error opening Visual Selector", err);
        Msg.error(err.msg || err.message || err);
      }
    }, 400);
    return this;
  },
  async renderTab() {
    let url = this.model.get("uri") || "https://google.com";
    this.$el.text(T("h_opened_selector_in_tab"));
    let sieve = await serviceProxy.createAndOpenSelector({ url, model: this.model.toJSON() });
    sieve && (sieve = JSON.parse(JSON.stringify(sieve)));
    chrome.tabs.getCurrent(function(tab) {
      chrome.tabs.update(tab.id, { active: true });
    });
    if (!sieve) {
      this.trigger("discard");
      Msg.info("m_selection_discarded");
    } else {
      this.model.set(this.model.parse(sieve));
      this.trigger("save", null, this.model);
      Msg.info("m_selection_saved");
    }
  }
});
var SelectorModal = View$1.Modal.extend({
  name: "SelectorModal",
  title: T("l_visual_selector"),
  initialize: function(options) {
    const selector2 = this.selector = new Selector$2(_$4.pick(options, "model", "parent"));
    _$4.defaults(options, {
      width: 400,
      height: 120,
      view: selector2
    });
    this.on("discard", function() {
      options.onDiscard();
    });
    View$1.Modal.prototype.initialize.call(this, options);
    this.listenTo(selector2, "discard", options.onDiscard);
    this.listenTo(selector2, "save", options.onSave);
  },
  remove: function() {
    SelectorModal.__super__.remove.call(this);
    this.selector.close();
  }
});
var Selector$3 = { Modal: SelectorModal };
var svelteTree = "";
const APIUrl = "/json/fetch";
const JqFilterUrl = "/json/filter";
async function fetchData(api, data) {
  try {
    let res2 = await Api.utils(api, "POST", data);
    return res2.body;
  } catch (err) {
    console.error("Error filtering json data", err);
    if (err.status >= 400 && err.status < 500) {
      return {
        status: err.status,
        body: err.body || "Retry!! Something went wrong. "
      };
    } else if (err.status >= 500) {
      return {
        status: err.status,
        body: "Internal server error"
      };
    }
  }
}
function initStores(includedJSON = []) {
  const originalJson = writable("");
  const excludedJson = writable([]);
  const includedJson = writable(includedJSON.map((path) => [path, CheckState.selected]));
  return {
    originalJson,
    excludedJson,
    includedJson,
    previewJson: derived([excludedJson, includedJson], async ([$excludedJson, $includedJson], set) => {
      let exclude = "";
      let includedFilter = $includedJson.map((filter) => filter[0]);
      for (let filter of $excludedJson) {
        if (includedFilter.indexOf(filter) === -1) {
          if (exclude)
            exclude += ", " + filter;
          else
            exclude = filter;
        }
      }
      if (exclude)
        exclude = `. | del(${exclude})`;
      else
        exclude = ".";
      const output = await fetchData(JqFilterUrl, {
        filter: exclude,
        json: get_store_value(originalJson)
      });
      set(output);
    })
  };
}
const ParsedPropertyName = "parsed__properties";
const NumberOfMerges = "number__merges";
const PrimitiveProperties = "primitive__properties";
function isInternalField(name) {
  switch (name) {
    case ParsedPropertyName:
    case NumberOfMerges:
    case PrimitiveProperties:
      return true;
    default:
      return false;
  }
}
let outputTemplate = {};
function merge$1(template, obj) {
  const primitivePropertiesEncountered = {};
  Object.keys(obj).filter((k) => !isInternalField(k)).forEach((k) => {
    switch (obj[ParsedPropertyName][k]) {
      case types.OBJECT:
        if (!template[k]) {
          template[k] = {};
        }
        merge$1(template[k], obj[k]);
        break;
      case types.ARRAY_OF_OBJECTS:
        if (!template[k]) {
          template[k] = obj[k];
        } else if (template[k].length === 1 && obj[k].length === 1) {
          merge$1(template[k][0], obj[k][0]);
        }
        break;
      case types.ARRAY:
        if (!template[k]) {
          template[k] = [];
        }
        template[k].push(obj[k]);
        break;
      case types.PRIMITIVE:
        if (!template[k]) {
          template[k] = [];
          const numberOfMerges = template[NumberOfMerges] || 0;
          for (let i2 = 0; i2 < numberOfMerges; i2++) {
            template[k].push(null);
          }
        }
        if (Array.isArray(template[k]) && Array.isArray(obj[k])) {
          template[k].push(...obj[k]);
        } else {
          template[k].push(obj[k]);
        }
        if (!template[PrimitiveProperties]) {
          template[PrimitiveProperties] = {};
        }
        template[PrimitiveProperties][k] = true;
        primitivePropertiesEncountered[k] = true;
        break;
    }
  });
  if (!template[ParsedPropertyName]) {
    template[ParsedPropertyName] = obj[ParsedPropertyName];
  } else {
    template[ParsedPropertyName] = {
      ...template[ParsedPropertyName],
      ...obj[ParsedPropertyName]
    };
  }
  template[NumberOfMerges] = template[NumberOfMerges] ? ++template[NumberOfMerges] : 1;
  if (template[PrimitiveProperties]) {
    Object.keys(template[PrimitiveProperties]).filter((key) => !primitivePropertiesEncountered[key]).forEach((key) => {
      if (template[key]) {
        template[key].push(null);
      }
    });
  }
}
function createArrayTemplate(array, template) {
  let mergedObject = {};
  for (let arr of array) {
    const type = jsonType(arr);
    if (type === types.OBJECT) {
      const innerTemplate = createTemplate(arr, {});
      merge$1(mergedObject, innerTemplate);
    }
  }
  template.push(mergedObject);
  return template;
}
function createTemplate(json, template) {
  let properties = {};
  for (let key in json) {
    if (Object.prototype.hasOwnProperty.call(json, key)) {
      let type = jsonType(json[key]);
      if (type === types.OBJECT) {
        template[key] = createTemplate(json[key], {});
        properties[key] = types.OBJECT;
      } else if (type === types.ARRAY) {
        if (isArrayOfObject(json[key])) {
          template[key] = createArrayTemplate(json[key], []);
          properties[key] = types.ARRAY_OF_OBJECTS;
        } else {
          template[key] = json[key];
          properties[key] = types.ARRAY;
        }
      } else {
        template[key] = json[key];
        properties[key] = types.PRIMITIVE;
      }
    }
  }
  template[ParsedPropertyName] = properties;
  return template;
}
function performJSONParsing(json) {
  const type = jsonType(json);
  if (type === types.ARRAY) {
    if (isArrayOfObject(json)) {
      outputTemplate = createArrayTemplate(json, []);
    } else if (isArrayOfPrimitives(json)) {
      outputTemplate = json;
    } else {
      outputTemplate = "Array";
    }
  } else if (type === types.OBJECT) {
    outputTemplate = createTemplate(json, {});
  } else {
    return {
      msg: "Invalid Json"
    };
  }
  return outputTemplate;
}
function sanitize(parsedJSON, fieldName) {
  if (!parsedJSON) {
    return parsedJSON;
  } else if (Array.isArray(parsedJSON)) {
    for (let i2 = 0; i2 < parsedJSON.length; i2++) {
      sanitize(parsedJSON[i2], fieldName);
    }
  } else if (jsonType(parsedJSON) === types.OBJECT) {
    if (Object.prototype.hasOwnProperty.call(parsedJSON, fieldName)) {
      delete parsedJSON[fieldName];
    }
    Object.keys(parsedJSON).filter((k) => parsedJSON[k]).filter((k) => !isPrimitive(parsedJSON[k])).forEach((k) => sanitize(parsedJSON[k], fieldName));
  }
}
function jsonParser(json) {
  const parsedJSON = performJSONParsing(json);
  sanitize(parsedJSON, NumberOfMerges);
  sanitize(parsedJSON, PrimitiveProperties);
  return parsedJSON;
}
function prepareSchema(parsedJSON) {
  const schema = prepareSchema1(parsedJSON);
  return schema;
}
function prepareSchema1(parsedJSON) {
  const type = jsonType(parsedJSON);
  if (type === types.ARRAY) {
    if (isArrayOfObject(parsedJSON)) {
      return handleArrayOfObjects(parsedJSON);
    } else {
      return handleArrayOfPrimitives(parsedJSON);
    }
  } else if (type === types.OBJECT) {
    return handleObject(parsedJSON);
  } else {
    return parsedJSON;
  }
}
function handleObject(parsedJSON) {
  const deepCopy = JSON.parse(JSON.stringify(parsedJSON));
  const properties = parsedJSON[ParsedPropertyName];
  Object.keys(parsedJSON).filter((k) => k !== ParsedPropertyName).forEach((k) => {
    switch (properties[k]) {
      case types.PRIMITIVE:
        parsedJSON[k] = handlePrimitive(parsedJSON[k]);
        break;
      case types.ARRAY:
        parsedJSON[k] = handleArrayOfPrimitives(parsedJSON[k]);
        break;
      case types.ARRAY_OF_OBJECTS:
        parsedJSON[k] = handleArrayOfObjects(parsedJSON[k]);
        break;
      case types.OBJECT:
        parsedJSON[k] = handleObject(parsedJSON[k]);
        break;
    }
  });
  return {
    schema: parsedJSON,
    type: types.OBJECT,
    value: deepCopy
  };
}
function handlePrimitive(value) {
  return {
    value,
    type: Array.isArray(value) ? jsonType(findFirstNotNullElemFromArray(value)) : jsonType(value)
  };
}
function handleArrayOfPrimitives(value) {
  return {
    value,
    type: types.ARRAY
  };
}
function handleArrayOfObjects(value) {
  return {
    value,
    type: types.ARRAY_OF_OBJECTS,
    schema: handleObject(value[0])
  };
}
function findFirstNotNullElemFromArray(arr) {
  if (!arr) {
    return null;
  }
  for (let i2 = 0; i2 < arr.length; i2++) {
    if (arr[i2]) {
      return arr[i2];
    }
  }
  return null;
}
function create_label_slot(ctx) {
  let span;
  let t_value = ctx[0].label + "";
  let t;
  let span_title_value;
  return {
    c() {
      span = element("span");
      t = text(t_value);
      attr(span, "slot", "label");
      attr(span, "title", span_title_value = ctx[0].label);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[0].label + ""))
        set_data(t, t_value);
      if (dirty & 1 && span_title_value !== (span_title_value = ctx2[0].label)) {
        attr(span, "title", span_title_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_icon_slot$2(ctx) {
  let span;
  let div;
  let typesvg;
  let div_title_value;
  let current;
  typesvg = new TypeSVG({ props: { type: ctx[0].type } });
  return {
    c() {
      span = element("span");
      div = element("div");
      create_component(typesvg.$$.fragment);
      attr(div, "class", "tv-svg");
      attr(div, "title", div_title_value = ctx[0].type);
      attr(span, "slot", "icon");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, div);
      mount_component(typesvg, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const typesvg_changes = {};
      if (dirty & 1)
        typesvg_changes.type = ctx2[0].type;
      typesvg.$set(typesvg_changes);
      if (!current || dirty & 1 && div_title_value !== (div_title_value = ctx2[0].type)) {
        attr(div, "title", div_title_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(typesvg.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(typesvg.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      destroy_component(typesvg);
    }
  };
}
function create_meta_slot(ctx) {
  let div;
  let nodevalue;
  let div_title_value;
  let current;
  nodevalue = new NodeValue({
    props: {
      content: ctx[0].getPrettyValue()
    }
  });
  return {
    c() {
      div = element("div");
      create_component(nodevalue.$$.fragment);
      attr(div, "slot", "meta");
      set_style(div, "white-space", "normal");
      set_style(div, "overflow-wrap", "anywhere");
      attr(div, "title", div_title_value = ctx[0].getValue());
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(nodevalue, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const nodevalue_changes = {};
      if (dirty & 1)
        nodevalue_changes.content = ctx2[0].getPrettyValue();
      nodevalue.$set(nodevalue_changes);
      if (!current || dirty & 1 && div_title_value !== (div_title_value = ctx2[0].getValue())) {
        attr(div, "title", div_title_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(nodevalue.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(nodevalue.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(nodevalue);
    }
  };
}
function create_fragment$Z(ctx) {
  let div;
  let treeview;
  let current;
  treeview = new TreeView({
    props: {
      root: ctx[0],
      class: "tree-view bg-white min-w-max",
      $$slots: {
        meta: [
          create_meta_slot,
          ({ node: node2 }) => ({ 0: node2 }),
          ({ node: node2 }) => node2 ? 1 : 0
        ],
        icon: [
          create_icon_slot$2,
          ({ node: node2 }) => ({ 0: node2 }),
          ({ node: node2 }) => node2 ? 1 : 0
        ],
        label: [
          create_label_slot,
          ({ node: node2 }) => ({ 0: node2 }),
          ({ node: node2 }) => node2 ? 1 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  treeview.$on("check", ctx[7]);
  return {
    c() {
      div = element("div");
      create_component(treeview.$$.fragment);
      set_style(div, "--max-depth", ctx[3]());
      attr(div, "class", "overflow-auto bb bl br border-bootstrap-border");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(treeview, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const treeview_changes = {};
      if (dirty & 1)
        treeview_changes.root = ctx2[0];
      if (dirty & 65537) {
        treeview_changes.$$scope = { dirty, ctx: ctx2 };
      }
      treeview.$set(treeview_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(treeview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(treeview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(treeview);
    }
  };
}
const MaxAllowableDepthForWidth = 12;
const MinAllowableDepthForWidth = 8;
function instance$Y($$self, $$props, $$invalidate) {
  let $maxDepth;
  let { obj } = $$props;
  let { includedJqFilter = [] } = $$props;
  let { stores = {} } = $$props;
  let maxDepth = writable(0);
  component_subscribe($$self, maxDepth, (value) => $$invalidate(10, $maxDepth = value));
  class Node2 extends BaseNode {
    constructor({ id: id2, label, parent: parent2 = null, type = null, key = null, jqSelector = ".", value = null, checkable = true, disabled = false }) {
      super(id2, label, parent2);
      this.checkable = checkable;
      this.selectable = false;
      this.disabled = disabled;
      this._expanded = true;
      this.type = type;
      this.key = key;
      this.jqSelector = jqSelector;
      this.value = value;
    }
    isSelectable() {
      return false;
    }
    getJqSelector() {
      return this.jqSelector;
    }
    getExcludedJqSelectors() {
      let result = [];
      for (let i2 = 0; i2 < this.getChildCount(); i2++) {
        if (this.children[i2].isCheckable()) {
          if (this.children[i2].getCheckState() === CheckState.none) {
            result.push(this.children[i2].getJqSelector());
          }
          result.push(...this.children[i2].getExcludedJqSelectors());
        }
      }
      return result;
    }
    getIncludedJqSelectors() {
      let result = [];
      for (let i2 = 0; i2 < this.getChildCount(); i2++) {
        if (this.children[i2].isCheckable()) {
          let state = this.children[i2].getCheckState();
          if (state !== CheckState.none) {
            result.push([this.children[i2].getJqSelector(), state]);
          }
          result.push(...this.children[i2].getIncludedJqSelectors());
        }
      }
      return result;
    }
    changeInitialJqSelector() {
      for (let i2 = 0; i2 < this.getChildCount(); i2++) {
        let child = this.children[i2];
        let selector2 = child.getJqSelector();
        get_store_value(stores.includedJson).filter((filter) => {
          if (selector2 === filter[0]) {
            child.checkAll(CheckState.selected);
          }
        });
        child.changeInitialJqSelector();
      }
    }
    firstValue(arrayOrValue) {
      if (!arrayOrValue) {
        return "";
      }
      if (Array.isArray(arrayOrValue) && arrayOrValue && arrayOrValue.length > 0) {
        for (let i2 = 0; i2 < arrayOrValue.length; i2++) {
          if (arrayOrValue[i2]) {
            return arrayOrValue[i2];
          }
        }
        return arrayOrValue[0];
      }
      return arrayOrValue;
    }
    getValue() {
      switch (this.type) {
        case types.STRING:
          return this.value;
        default:
          return this.getPrettyValue();
      }
    }
    getPrettyValue() {
      switch (this.type) {
        case types.STRING:
        case types.NUMBER:
          return this.firstValue(this.value);
        case types.BOOLEAN:
          return this.value;
        case types.ARRAY:
          return `Array with ${this.value.length} values(s)`;
        case types.ARRAY_OF_OBJECTS:
          return "Array containing Objects";
        case types.OBJECT:
          return "";
        default:
          return this.value;
      }
    }
  }
  class ArrOfObjectNode extends Node2 {
    constructor({ id: id2, label, parent: parent2 = null, type = null, key = null, jqSelector = ".", value = null, checkable = true, previewJSONStore = null }) {
      super({
        id: id2,
        label,
        parent: parent2,
        type,
        key,
        jqSelector,
        value,
        checkable
      });
      if (this.type === types.ARRAY_OF_OBJECTS) {
        this.previewJSONStore = previewJSONStore;
        this.unsubscribe = this.previewJSONStore.subscribe((val) => {
          if (this.unsubscribe) {
            this.updatePreview(val);
          }
        });
      }
    }
    getPreviewNode() {
      if (this.children && this.children.length > 0) {
        const lastChild = this.children[this.children.length - 1];
        if (lastChild && lastChild.label === "Preview") {
          return lastChild;
        }
      }
      return null;
    }
    async updatePreview(newContent) {
      if (this.type !== types.ARRAY_OF_OBJECTS) {
        return;
      }
      if (!this.children || this.children.length === 0) {
        return;
      }
      const itemsNode = this.children[0];
      const children = await itemsNode.getChildren();
      const previewValues = {};
      let valueLength = 0;
      for (let i2 = 0; i2 < children.length; i2++) {
        const child = children[i2];
        if (isPrimitiveType(child.type) && child.checkState === CheckState.selected) {
          previewValues[child.key] = child.value;
          valueLength = child.value.length;
        }
      }
      const preview = [];
      for (let i2 = 0; i2 < valueLength; i2++) {
        const previewElem = {};
        Object.keys(previewValues).forEach((k) => {
          previewElem[k] = previewValues[k][i2];
        });
        preview.push(previewElem);
      }
      if (preview) {
        this.getPreviewNode().setChildren(jsonToNodeForPreview(preview, this.getPreviewNode()));
        this.getPreviewNode().setDisabled(false);
      } else {
        this.getPreviewNode().setChildren([]);
        this.getPreviewNode().setDisabled(true);
      }
      this.getPreviewNode().notify();
      this.notify();
    }
  }
  let count2 = 0;
  let jqExtension = "";
  let node2;
  function createNode(obj2) {
    if (types.ARRAY === jsonType(obj2)) {
      jqExtension = ".";
    }
    if (obj2 && types.ARRAY_OF_OBJECTS === obj2.type) {
      jqExtension = ".";
    }
    sanitize(obj2, ParsedPropertyName);
    $$invalidate(0, node2 = jsonToNode(obj2, "Properties", null, jqExtension, 0));
    if ($maxDepth > MaxAllowableDepthForWidth) {
      maxDepth.set(MaxAllowableDepthForWidth);
    } else if ($maxDepth < MinAllowableDepthForWidth) {
      maxDepth.set(MinAllowableDepthForWidth);
    }
    let jqSelectors = node2.getExcludedJqSelectors();
    stores.excludedJson.set(jqSelectors);
    node2.changeInitialJqSelector();
    const jq = node2.getIncludedJqSelectors();
    stores.includedJson.update((val) => jq);
  }
  function jsonToNode(json, label, parent2, jq, depth) {
    let type = json.type;
    let value;
    try {
      value = JSON.parse(JSON.stringify(json.value));
    } catch (e) {
      console.error("error while JSON conversion for creating the value", json.value, e);
    }
    let newNode;
    if ($maxDepth < depth) {
      maxDepth.set(depth);
    }
    delete json.value;
    switch (type) {
      case types.ARRAY_OF_OBJECTS:
        newNode = new ArrOfObjectNode({
          id: count2++,
          label: `${label}`,
          parent: parent2,
          type,
          key: label,
          jqSelector: jq,
          value,
          previewJSONStore: stores.previewJson
        });
        const schema = json.schema;
        newNode.children = [];
        newNode.children.push(jsonToNode(schema, "Items", newNode, jq + "[]?", depth + 1));
        newNode.children.push(new Node2({
          id: count2++,
          label: "Preview",
          parent: newNode,
          checkable: false,
          value: "",
          disabled: true,
          expandable: false
        }));
        break;
      case types.OBJECT:
        newNode = new Node2({
          id: count2++,
          label: `${label}`,
          parent: parent2,
          type,
          key: label,
          jqSelector: jq,
          value
        });
        newNode.children = Object.keys(json.schema).map((key) => jsonToNode(json.schema[key], key, newNode, jq + `."${key}"`, depth + 1));
        break;
      case types.NUMBER:
      case types.BOOLEAN:
      case types.STRING:
      case types.PRIMITIVE:
      case types.ARRAY:
      default:
        newNode = new Node2({
          id: count2++,
          label: `${label}`,
          parent: parent2,
          type,
          key: label,
          jqSelector: jq,
          value
        });
        break;
    }
    return newNode;
  }
  function onCheck(detail) {
    let { checked, node: node3 } = detail;
    let jqSelectors = node3.getRoot().getIncludedJqSelectors();
    stores.includedJson.update(function(val) {
      return jqSelectors;
    });
  }
  function jsonToNodeForPreview(obj2, parent2) {
    const newNodes = [];
    for (const key in obj2) {
      let newNode = new Node2({
        id: count2++,
        label: key,
        parent: parent2,
        value: isPrimitive(obj2[key]) || isArrayOfPrimitives(obj2[key]) ? obj2[key] : "",
        checkable: false,
        type: jsonType(obj2[key])
      });
      if (!isPrimitive(obj2[key]) && !Array.isArray(obj2[key])) {
        newNode.children = jsonToNodeForPreview(obj2[key], newNode);
      }
      newNodes.push(newNode);
    }
    return newNodes;
  }
  function getDepth() {
    let minWidth = 30, upper_bound = 40;
    let depth = minWidth + 2 * $maxDepth;
    return `${depth > upper_bound ? upper_bound : depth}%`;
  }
  const check_handler = (e) => onCheck(e.detail);
  $$self.$$set = ($$props2) => {
    if ("obj" in $$props2)
      $$invalidate(4, obj = $$props2.obj);
    if ("includedJqFilter" in $$props2)
      $$invalidate(5, includedJqFilter = $$props2.includedJqFilter);
    if ("stores" in $$props2)
      $$invalidate(6, stores = $$props2.stores);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 16) {
      createNode(obj);
    }
  };
  return [
    node2,
    maxDepth,
    onCheck,
    getDepth,
    obj,
    includedJqFilter,
    stores,
    check_handler
  ];
}
class Tree extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$Y, create_fragment$Z, safe_not_equal, { obj: 4, includedJqFilter: 5, stores: 6 });
  }
}
function create_fragment$Y(ctx) {
  let div;
  let ul;
  let li0;
  let a0;
  let t1;
  let li1;
  let a1;
  let t3;
  let pre;
  let t4_value = JSON.stringify(ctx[0] == "distilled" ? ctx[3] : ctx[1], null, 2) + "";
  let t4;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      ul = element("ul");
      li0 = element("li");
      a0 = element("a");
      a0.textContent = "Distilled";
      t1 = space();
      li1 = element("li");
      a1 = element("a");
      a1.textContent = "Response";
      t3 = space();
      pre = element("pre");
      t4 = text(t4_value);
      attr(a0, "href", "#distilled_tab");
      attr(a0, "data-toggle", "tab");
      toggle_class(li0, "active", ctx[0] === "distilled");
      attr(a1, "href", "#original_tab");
      attr(a1, "data-toggle", "tab");
      toggle_class(li1, "active", ctx[0] === "response");
      attr(ul, "class", "nav nav-tabs ");
      attr(pre, "class", "max-h-[600px] bg-white overflow-auto");
      set_style(pre, "border-top", "none");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, ul);
      append(ul, li0);
      append(li0, a0);
      append(ul, t1);
      append(ul, li1);
      append(li1, a1);
      append(div, t3);
      append(div, pre);
      append(pre, t4);
      if (!mounted) {
        dispose = [
          listen(a0, "click", ctx[6]),
          listen(a1, "click", ctx[7])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        toggle_class(li0, "active", ctx2[0] === "distilled");
      }
      if (dirty & 1) {
        toggle_class(li1, "active", ctx2[0] === "response");
      }
      if (dirty & 11 && t4_value !== (t4_value = JSON.stringify(ctx2[0] == "distilled" ? ctx2[3] : ctx2[1], null, 2) + ""))
        set_data(t4, t4_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$X($$self, $$props, $$invalidate) {
  let $previewJsonStore, $$unsubscribe_previewJsonStore = noop, $$subscribe_previewJsonStore = () => ($$unsubscribe_previewJsonStore(), $$unsubscribe_previewJsonStore = subscribe(previewJsonStore, ($$value) => $$invalidate(5, $previewJsonStore = $$value)), previewJsonStore);
  $$self.$$.on_destroy.push(() => $$unsubscribe_previewJsonStore());
  let { output = {} } = $$props;
  let { previewJsonStore } = $$props;
  $$subscribe_previewJsonStore();
  let distilledJSON = {};
  let { preview = "distilled" } = $$props;
  function onClickTabPreview(newValue) {
    $$invalidate(0, preview = newValue);
  }
  const click_handler2 = () => onClickTabPreview("distilled");
  const click_handler_1 = () => onClickTabPreview("response");
  $$self.$$set = ($$props2) => {
    if ("output" in $$props2)
      $$invalidate(1, output = $$props2.output);
    if ("previewJsonStore" in $$props2)
      $$subscribe_previewJsonStore($$invalidate(2, previewJsonStore = $$props2.previewJsonStore));
    if ("preview" in $$props2)
      $$invalidate(0, preview = $$props2.preview);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 36) {
      $$invalidate(3, distilledJSON = (previewJsonStore ? $previewJsonStore : {}) || {});
    }
  };
  return [
    preview,
    output,
    previewJsonStore,
    distilledJSON,
    onClickTabPreview,
    $previewJsonStore,
    click_handler2,
    click_handler_1
  ];
}
class DistilledJSONText extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$X, create_fragment$Y, safe_not_equal, {
      output: 1,
      previewJsonStore: 2,
      preview: 0
    });
  }
}
function create_fragment$X(ctx) {
  let div;
  let input0;
  let t0;
  let input1;
  let t1;
  let button;
  let svg;
  let path;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      input0 = element("input");
      t0 = space();
      input1 = element("input");
      t1 = space();
      button = element("button");
      svg = svg_element("svg");
      path = svg_element("path");
      attr(input0, "type", "text");
      attr(input0, "class", "form-control input-sm mr-2");
      attr(input0, "placeholder", "Key");
      attr(input1, "type", "text");
      attr(input1, "class", "form-control input-sm mr-2");
      attr(input1, "placeholder", "Value");
      attr(path, "stroke-linecap", "round");
      attr(path, "stroke-linejoin", "round");
      attr(path, "stroke-width", "2");
      attr(path, "d", "M6 18L18 6M6 6l12 12");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "class", "h-6 w-6 col-center-block");
      attr(svg, "fill", "none");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "stroke", "currentColor");
      attr(button, "class", "btn btn-default btn-sm flex items-center");
      attr(button, "title", "Delete");
      attr(div, "class", "flex flex-row item-center mb-2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input0);
      set_input_value(input0, ctx[0]);
      append(div, t0);
      append(div, input1);
      set_input_value(input1, ctx[1]);
      append(div, t1);
      append(div, button);
      append(button, svg);
      append(svg, path);
      if (!mounted) {
        dispose = [
          listen(input0, "input", ctx[4]),
          listen(input0, "input", ctx[5]),
          listen(input1, "input", ctx[6]),
          listen(input1, "input", ctx[7]),
          listen(svg, "click", function() {
            if (is_function(ctx[2]))
              ctx[2].apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (dirty & 1 && input0.value !== ctx[0]) {
        set_input_value(input0, ctx[0]);
      }
      if (dirty & 2 && input1.value !== ctx[1]) {
        set_input_value(input1, ctx[1]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$W($$self, $$props, $$invalidate) {
  const dispatch = createEventDispatcher();
  let { key } = $$props;
  let { value } = $$props;
  let { onRemove } = $$props;
  function input0_input_handler() {
    key = this.value;
    $$invalidate(0, key);
  }
  const input_handler = (e) => dispatch("keyUpdate", $$invalidate(0, key = e.target.value));
  function input1_input_handler() {
    value = this.value;
    $$invalidate(1, value);
  }
  const input_handler_1 = (e) => dispatch("valueUpdate", $$invalidate(1, value = e.target.value));
  $$self.$$set = ($$props2) => {
    if ("key" in $$props2)
      $$invalidate(0, key = $$props2.key);
    if ("value" in $$props2)
      $$invalidate(1, value = $$props2.value);
    if ("onRemove" in $$props2)
      $$invalidate(2, onRemove = $$props2.onRemove);
  };
  return [
    key,
    value,
    onRemove,
    dispatch,
    input0_input_handler,
    input_handler,
    input1_input_handler,
    input_handler_1
  ];
}
class KeyValueTable extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$W, create_fragment$X, safe_not_equal, { key: 0, value: 1, onRemove: 2 });
  }
}
function get_each_context$i(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[46] = list[i2];
  child_ctx[47] = list;
  child_ctx[48] = i2;
  return child_ctx;
}
function get_each_context_1$1(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[49] = list[i2];
  return child_ctx;
}
function get_each_context_2(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[46] = list[i2];
  child_ctx[52] = list;
  child_ctx[48] = i2;
  return child_ctx;
}
function get_each_context_3(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[46] = list[i2];
  child_ctx[48] = i2;
  return child_ctx;
}
function get_each_context_4(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[54] = list[i2];
  child_ctx[48] = i2;
  return child_ctx;
}
function create_each_block_4(ctx) {
  let li;
  let a;
  let t0_value = ctx[54] + "";
  let t0;
  let t1;
  let mounted;
  let dispose;
  function click_handler2() {
    return ctx[25](ctx[54]);
  }
  return {
    c() {
      li = element("li");
      a = element("a");
      t0 = text(t0_value);
      t1 = space();
      attr(a, "href", "javascript:void(0)");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, a);
      append(a, t0);
      append(li, t1);
      if (!mounted) {
        dispose = listen(li, "click", click_handler2);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block_3(ctx) {
  let keyvaluetable;
  let current;
  function func() {
    return ctx[32](ctx[48]);
  }
  function keyUpdate_handler(...args) {
    return ctx[33](ctx[48], ...args);
  }
  function valueUpdate_handler(...args) {
    return ctx[34](ctx[48], ...args);
  }
  keyvaluetable = new KeyValueTable({
    props: {
      key: ctx[46][0],
      value: ctx[46][1],
      onRemove: func
    }
  });
  keyvaluetable.$on("keyUpdate", keyUpdate_handler);
  keyvaluetable.$on("valueUpdate", valueUpdate_handler);
  return {
    c() {
      create_component(keyvaluetable.$$.fragment);
    },
    m(target, anchor) {
      mount_component(keyvaluetable, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const keyvaluetable_changes = {};
      if (dirty[0] & 512)
        keyvaluetable_changes.key = ctx[46][0];
      if (dirty[0] & 512)
        keyvaluetable_changes.value = ctx[46][1];
      keyvaluetable.$set(keyvaluetable_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(keyvaluetable.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(keyvaluetable.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(keyvaluetable, detaching);
    }
  };
}
function create_each_block_2(ctx) {
  let keyvaluetable;
  let updating_key;
  let updating_value;
  let current;
  function func_1() {
    return ctx[35](ctx[48]);
  }
  function keyvaluetable_key_binding(value) {
    ctx[36](value, ctx[46]);
  }
  function keyvaluetable_value_binding(value) {
    ctx[37](value, ctx[46]);
  }
  let keyvaluetable_props = { onRemove: func_1 };
  if (ctx[46][0] !== void 0) {
    keyvaluetable_props.key = ctx[46][0];
  }
  if (ctx[46][1] !== void 0) {
    keyvaluetable_props.value = ctx[46][1];
  }
  keyvaluetable = new KeyValueTable({ props: keyvaluetable_props });
  binding_callbacks.push(() => bind$2(keyvaluetable, "key", keyvaluetable_key_binding));
  binding_callbacks.push(() => bind$2(keyvaluetable, "value", keyvaluetable_value_binding));
  return {
    c() {
      create_component(keyvaluetable.$$.fragment);
    },
    m(target, anchor) {
      mount_component(keyvaluetable, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const keyvaluetable_changes = {};
      if (!updating_key && dirty[0] & 32) {
        updating_key = true;
        keyvaluetable_changes.key = ctx[46][0];
        add_flush_callback(() => updating_key = false);
      }
      if (!updating_value && dirty[0] & 32) {
        updating_value = true;
        keyvaluetable_changes.value = ctx[46][1];
        add_flush_callback(() => updating_value = false);
      }
      keyvaluetable.$set(keyvaluetable_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(keyvaluetable.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(keyvaluetable.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(keyvaluetable, detaching);
    }
  };
}
function create_each_block_1$1(ctx) {
  let option;
  let t_value = ctx[49] + "";
  let t;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = ctx[49];
      option.value = option.__value;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_if_block_1$h(ctx) {
  let div;
  let textarea;
  let t;
  let mounted;
  let dispose;
  let if_block = ctx[8] && create_if_block_2$9();
  return {
    c() {
      div = element("div");
      textarea = element("textarea");
      t = space();
      if (if_block)
        if_block.c();
      attr(textarea, "placeholder", "JSON");
      attr(textarea, "rows", "6");
      attr(textarea, "name", "bodyjson");
      attr(textarea, "class", "form-control");
      textarea.value = ctx[7];
      attr(div, "class", "flex flex-col");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, textarea);
      append(div, t);
      if (if_block)
        if_block.m(div, null);
      if (!mounted) {
        dispose = [
          listen(textarea, "input", ctx[42]),
          listen(textarea, "blur", ctx[14])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 128) {
        textarea.value = ctx2[7];
      }
      if (ctx2[8]) {
        if (if_block)
          ;
        else {
          if_block = create_if_block_2$9();
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$t(ctx) {
  let t0;
  let button;
  let current;
  let mounted;
  let dispose;
  let each_value = ctx[4].data;
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$i(get_each_context$i(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t0 = space();
      button = element("button");
      button.textContent = "Add Field";
      attr(button, "class", "btn btn-default btn-xs");
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(target, anchor);
      }
      insert(target, t0, anchor);
      insert(target, button, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[16]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 131088) {
        each_value = ctx2[4].data;
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$i(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$i(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(t0.parentNode, t0);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_2$9(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "Invalid Json!!";
      attr(div, "class", "alert alert-danger");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_each_block$i(ctx) {
  let keyvaluetable;
  let updating_key;
  let updating_value;
  let current;
  function func_2() {
    return ctx[39](ctx[48]);
  }
  function keyvaluetable_key_binding_1(value) {
    ctx[40](value, ctx[46]);
  }
  function keyvaluetable_value_binding_1(value) {
    ctx[41](value, ctx[46]);
  }
  let keyvaluetable_props = { onRemove: func_2 };
  if (ctx[46][0] !== void 0) {
    keyvaluetable_props.key = ctx[46][0];
  }
  if (ctx[46][1] !== void 0) {
    keyvaluetable_props.value = ctx[46][1];
  }
  keyvaluetable = new KeyValueTable({ props: keyvaluetable_props });
  binding_callbacks.push(() => bind$2(keyvaluetable, "key", keyvaluetable_key_binding_1));
  binding_callbacks.push(() => bind$2(keyvaluetable, "value", keyvaluetable_value_binding_1));
  return {
    c() {
      create_component(keyvaluetable.$$.fragment);
    },
    m(target, anchor) {
      mount_component(keyvaluetable, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const keyvaluetable_changes = {};
      if (!updating_key && dirty[0] & 16) {
        updating_key = true;
        keyvaluetable_changes.key = ctx[46][0];
        add_flush_callback(() => updating_key = false);
      }
      if (!updating_value && dirty[0] & 16) {
        updating_value = true;
        keyvaluetable_changes.value = ctx[46][1];
        add_flush_callback(() => updating_value = false);
      }
      keyvaluetable.$set(keyvaluetable_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(keyvaluetable.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(keyvaluetable.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(keyvaluetable, detaching);
    }
  };
}
function create_fragment$W(ctx) {
  let div1;
  let div0;
  let button0;
  let span0;
  let t0_value = ctx[0].method + "";
  let t0;
  let t1;
  let span1;
  let t2;
  let ul0;
  let t3;
  let input;
  let input_placeholder_value;
  let t4;
  let span2;
  let button1;
  let t6;
  let ul1;
  let li0;
  let a0;
  let t8;
  let li1;
  let a1;
  let t10;
  let li2;
  let a2;
  let t12;
  let div6;
  let div2;
  let t13;
  let button2;
  let t15;
  let div3;
  let t16;
  let button3;
  let t18;
  let div5;
  let div4;
  let label_1;
  let t20;
  let select;
  let select_value_value;
  let t21;
  let hr;
  let t22;
  let current_block_type_index;
  let if_block;
  let current;
  let mounted;
  let dispose;
  let each_value_4 = ctx[12];
  let each_blocks_3 = [];
  for (let i2 = 0; i2 < each_value_4.length; i2 += 1) {
    each_blocks_3[i2] = create_each_block_4(get_each_context_4(ctx, each_value_4, i2));
  }
  let each_value_3 = ctx[9];
  let each_blocks_2 = [];
  for (let i2 = 0; i2 < each_value_3.length; i2 += 1) {
    each_blocks_2[i2] = create_each_block_3(get_each_context_3(ctx, each_value_3, i2));
  }
  const out = (i2) => transition_out(each_blocks_2[i2], 1, 1, () => {
    each_blocks_2[i2] = null;
  });
  let each_value_2 = ctx[5];
  let each_blocks_1 = [];
  for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
    each_blocks_1[i2] = create_each_block_2(get_each_context_2(ctx, each_value_2, i2));
  }
  const out_1 = (i2) => transition_out(each_blocks_1[i2], 1, 1, () => {
    each_blocks_1[i2] = null;
  });
  let each_value_1 = ctx[11];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i2));
  }
  const if_block_creators = [create_if_block$t, create_if_block_1$h];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[4].type === "urlencoded")
      return 0;
    if (ctx2[4].type === "json")
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      button0 = element("button");
      span0 = element("span");
      t0 = text(t0_value);
      t1 = space();
      span1 = element("span");
      t2 = space();
      ul0 = element("ul");
      for (let i2 = 0; i2 < each_blocks_3.length; i2 += 1) {
        each_blocks_3[i2].c();
      }
      t3 = space();
      input = element("input");
      t4 = space();
      span2 = element("span");
      button1 = element("button");
      button1.textContent = "Send";
      t6 = space();
      ul1 = element("ul");
      li0 = element("li");
      a0 = element("a");
      a0.textContent = "Params";
      t8 = space();
      li1 = element("li");
      a1 = element("a");
      a1.textContent = "Header";
      t10 = space();
      li2 = element("li");
      a2 = element("a");
      a2.textContent = "Body";
      t12 = space();
      div6 = element("div");
      div2 = element("div");
      for (let i2 = 0; i2 < each_blocks_2.length; i2 += 1) {
        each_blocks_2[i2].c();
      }
      t13 = space();
      button2 = element("button");
      button2.textContent = "Add Query Param";
      t15 = space();
      div3 = element("div");
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        each_blocks_1[i2].c();
      }
      t16 = space();
      button3 = element("button");
      button3.textContent = "Add Header";
      t18 = space();
      div5 = element("div");
      div4 = element("div");
      label_1 = element("label");
      label_1.textContent = "Content Type";
      t20 = space();
      select = element("select");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t21 = space();
      hr = element("hr");
      t22 = space();
      if (if_block)
        if_block.c();
      attr(span1, "class", "caret");
      attr(button0, "type", "button");
      attr(button0, "class", "btn btn-default dropdown-toggle");
      attr(button0, "data-toggle", "dropdown");
      attr(button0, "id", "method-type");
      attr(ul0, "class", "dropdown-menu");
      attr(ul0, "role", "menu");
      attr(ul0, "aria-labelledby", "method-type");
      attr(div0, "class", "input-group-btn search-panel");
      attr(input, "type", "text");
      attr(input, "class", "form-control");
      attr(input, "placeholder", input_placeholder_value = "Enter URL to monitor " + ctx[2]);
      attr(button1, "class", "btn btn-success");
      attr(button1, "type", "button");
      attr(span2, "class", "input-group-btn");
      attr(div1, "class", "input-group");
      attr(a0, "href", "#params_tab");
      attr(a0, "data-toggle", "tab");
      toggle_class(li0, "active", ctx[6] == 1);
      attr(a1, "href", "#header_tab");
      attr(a1, "data-toggle", "tab");
      toggle_class(li1, "active", ctx[6] == 2);
      attr(a2, "href", "#body_tab");
      attr(a2, "data-toggle", "tab");
      toggle_class(li2, "active", ctx[6] == 3);
      attr(ul1, "class", "nav nav-tabs mt-2");
      attr(button2, "class", "btn btn-default btn-xs");
      attr(div2, "class", "tab-pane");
      attr(div2, "id", "params_tab");
      toggle_class(div2, "active", ctx[6] == 1);
      attr(button3, "class", "btn btn-default btn-xs");
      attr(div3, "class", "tab-pane");
      attr(div3, "id", "header_tab");
      toggle_class(div3, "active", ctx[6] == 2);
      attr(div4, "class", "mlb-3");
      attr(hr, "class", "m-3");
      attr(div5, "class", "tab-pane");
      attr(div5, "id", "body_tab");
      toggle_class(div5, "active", ctx[6] === 3);
      attr(div6, "class", "tab-content bg-white bb bl br border-bootstrap-border p-4");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, button0);
      append(button0, span0);
      append(span0, t0);
      append(button0, t1);
      append(button0, span1);
      append(div0, t2);
      append(div0, ul0);
      for (let i2 = 0; i2 < each_blocks_3.length; i2 += 1) {
        each_blocks_3[i2].m(ul0, null);
      }
      append(div1, t3);
      append(div1, input);
      set_input_value(input, ctx[1]);
      append(div1, t4);
      append(div1, span2);
      append(span2, button1);
      insert(target, t6, anchor);
      insert(target, ul1, anchor);
      append(ul1, li0);
      append(li0, a0);
      append(ul1, t8);
      append(ul1, li1);
      append(li1, a1);
      append(ul1, t10);
      append(ul1, li2);
      append(li2, a2);
      insert(target, t12, anchor);
      insert(target, div6, anchor);
      append(div6, div2);
      for (let i2 = 0; i2 < each_blocks_2.length; i2 += 1) {
        each_blocks_2[i2].m(div2, null);
      }
      append(div2, t13);
      append(div2, button2);
      append(div6, t15);
      append(div6, div3);
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        each_blocks_1[i2].m(div3, null);
      }
      append(div3, t16);
      append(div3, button3);
      append(div6, t18);
      append(div6, div5);
      append(div5, div4);
      append(div4, label_1);
      append(div4, t20);
      append(div4, select);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(select, null);
      }
      select_option(select, ctx[4].type);
      append(div5, t21);
      append(div5, hr);
      append(div5, t22);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div5, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(input, "input", ctx[26]),
          listen(input, "input", ctx[27]),
          listen(button1, "click", ctx[28]),
          listen(a0, "click", ctx[29]),
          listen(a1, "click", ctx[30]),
          listen(a2, "click", ctx[31]),
          listen(button2, "click", ctx[20]),
          listen(button3, "click", ctx[18]),
          listen(select, "input", ctx[38])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & 1) && t0_value !== (t0_value = ctx2[0].method + ""))
        set_data(t0, t0_value);
      if (dirty[0] & 4104) {
        each_value_4 = ctx2[12];
        let i2;
        for (i2 = 0; i2 < each_value_4.length; i2 += 1) {
          const child_ctx = get_each_context_4(ctx2, each_value_4, i2);
          if (each_blocks_3[i2]) {
            each_blocks_3[i2].p(child_ctx, dirty);
          } else {
            each_blocks_3[i2] = create_each_block_4(child_ctx);
            each_blocks_3[i2].c();
            each_blocks_3[i2].m(ul0, null);
          }
        }
        for (; i2 < each_blocks_3.length; i2 += 1) {
          each_blocks_3[i2].d(1);
        }
        each_blocks_3.length = each_value_4.length;
      }
      if (!current || dirty[0] & 4 && input_placeholder_value !== (input_placeholder_value = "Enter URL to monitor " + ctx2[2])) {
        attr(input, "placeholder", input_placeholder_value);
      }
      if (dirty[0] & 2 && input.value !== ctx2[1]) {
        set_input_value(input, ctx2[1]);
      }
      if (dirty[0] & 64) {
        toggle_class(li0, "active", ctx2[6] == 1);
      }
      if (dirty[0] & 64) {
        toggle_class(li1, "active", ctx2[6] == 2);
      }
      if (dirty[0] & 64) {
        toggle_class(li2, "active", ctx2[6] == 3);
      }
      if (dirty[0] & 27263488) {
        each_value_3 = ctx2[9];
        let i2;
        for (i2 = 0; i2 < each_value_3.length; i2 += 1) {
          const child_ctx = get_each_context_3(ctx2, each_value_3, i2);
          if (each_blocks_2[i2]) {
            each_blocks_2[i2].p(child_ctx, dirty);
            transition_in(each_blocks_2[i2], 1);
          } else {
            each_blocks_2[i2] = create_each_block_3(child_ctx);
            each_blocks_2[i2].c();
            transition_in(each_blocks_2[i2], 1);
            each_blocks_2[i2].m(div2, t13);
          }
        }
        group_outros();
        for (i2 = each_value_3.length; i2 < each_blocks_2.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (dirty[0] & 64) {
        toggle_class(div2, "active", ctx2[6] == 1);
      }
      if (dirty[0] & 524320) {
        each_value_2 = ctx2[5];
        let i2;
        for (i2 = 0; i2 < each_value_2.length; i2 += 1) {
          const child_ctx = get_each_context_2(ctx2, each_value_2, i2);
          if (each_blocks_1[i2]) {
            each_blocks_1[i2].p(child_ctx, dirty);
            transition_in(each_blocks_1[i2], 1);
          } else {
            each_blocks_1[i2] = create_each_block_2(child_ctx);
            each_blocks_1[i2].c();
            transition_in(each_blocks_1[i2], 1);
            each_blocks_1[i2].m(div3, t16);
          }
        }
        group_outros();
        for (i2 = each_value_2.length; i2 < each_blocks_1.length; i2 += 1) {
          out_1(i2);
        }
        check_outros();
      }
      if (dirty[0] & 64) {
        toggle_class(div3, "active", ctx2[6] == 2);
      }
      if (dirty[0] & 2048) {
        each_value_1 = ctx2[11];
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$1(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_1$1(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(select, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
      if (!current || dirty[0] & 2064 && select_value_value !== (select_value_value = ctx2[4].type)) {
        select_option(select, ctx2[4].type);
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(div5, null);
        } else {
          if_block = null;
        }
      }
      if (dirty[0] & 64) {
        toggle_class(div5, "active", ctx2[6] === 3);
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_3.length; i2 += 1) {
        transition_in(each_blocks_2[i2]);
      }
      for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
        transition_in(each_blocks_1[i2]);
      }
      transition_in(if_block);
      current = true;
    },
    o(local) {
      each_blocks_2 = each_blocks_2.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks_2.length; i2 += 1) {
        transition_out(each_blocks_2[i2]);
      }
      each_blocks_1 = each_blocks_1.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        transition_out(each_blocks_1[i2]);
      }
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_each(each_blocks_3, detaching);
      if (detaching)
        detach(t6);
      if (detaching)
        detach(ul1);
      if (detaching)
        detach(t12);
      if (detaching)
        detach(div6);
      destroy_each(each_blocks_2, detaching);
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function getParams(uri) {
  let params2 = [];
  try {
    let url = new URL(uri);
    let searchParams = new URLSearchParams(url.search);
    for (let [key, value] of searchParams.entries()) {
      params2.push([key, value]);
    }
  } catch (e) {
  }
  return params2;
}
function getParameterizedURL(url, params2) {
  let [left, rest] = url.split("?");
  if (!left.startsWith("http")) {
    left = `https://${left}`;
  }
  let search = new URLSearchParams(params2.filter(([key, value]) => key));
  return `${left}?${search}`;
}
function instance$V($$self, $$props, $$invalidate) {
  let { request } = $$props;
  let { uri = "" } = $$props;
  let { label } = $$props;
  let dispatch = createEventDispatcher();
  const bodyTypes = ["none", "urlencoded", "json"];
  const methods = ["GET", "POST", "PATCH", "PUT", "DELETE"];
  let currentTab = 1;
  let { method, body, headers } = request;
  let jsonStr = null;
  let isBodyJSONInvalid = false;
  onBodyTypeChange(body.type);
  function onBodyTypeChange(type) {
    let data = body.data;
    switch (type) {
      case "json":
        if (data == null || !_.isObject(data) || _.isArray(data)) {
          $$invalidate(4, body.data = {}, body);
        }
        $$invalidate(7, jsonStr = JSON.stringify(body.data, null, 2));
        $$invalidate(8, isBodyJSONInvalid = false);
        break;
      case "urlencoded":
        if (!_.isArray(data)) {
          $$invalidate(4, body.data = [["", ""]], body);
        }
        break;
      default:
        $$invalidate(4, body.data = null, body);
    }
    $$invalidate(4, body.type = type, body);
  }
  function formatJSON(e) {
    try {
      $$invalidate(7, jsonStr = JSON.stringify(JSON.parse(e.target.value), null, 2));
    } catch (e2) {
    }
  }
  function parseBodyJSON(str) {
    try {
      $$invalidate(4, body.data = JSON.parse(str), body);
      $$invalidate(8, isBodyJSONInvalid = false);
    } catch (e) {
      $$invalidate(8, isBodyJSONInvalid = true);
    }
  }
  function checkFormBody() {
    body.data || $$invalidate(4, body.data = [], body);
  }
  function addURLEncodedParam() {
    checkFormBody();
    body.data.push(["", ""]);
    $$invalidate(4, body);
  }
  function onRemoveUrlencoded(index2) {
    body.data.splice(index2, 1);
    $$invalidate(4, body);
  }
  function addHeader() {
    headers.push(["", ""]);
    $$invalidate(5, headers);
  }
  function onRemoveHeader(index2) {
    headers.splice(index2, 1);
    $$invalidate(5, headers);
  }
  let params2 = uri ? getParams(uri) : [];
  function addNewParams() {
    $$invalidate(9, params2 = [...params2, ["", ""]]);
  }
  function onRemoveParam(index2) {
    params2.splice(index2, 1);
    $$invalidate(9, params2);
    $$invalidate(1, uri = getParameterizedURL(uri, params2));
  }
  let onURLInputUpdateParams = _.debounce((value) => {
    $$invalidate(9, params2 = []);
    try {
      let url = new URL(value);
      if (url.search) {
        let searchParams = new URLSearchParams(url.search);
        for (let [key, value2] of searchParams.entries()) {
          if (key || value2)
            params2.push([key, value2]);
        }
      }
    } catch (e) {
    }
  }, 200, false);
  let updateParamKey = _.debounce((index2, key) => {
    $$invalidate(9, params2[index2][0] = key, params2);
    $$invalidate(1, uri = getParameterizedURL(uri, params2));
  }, 200, false);
  let updateParamValue = _.debounce((index2, value) => {
    $$invalidate(9, params2[index2][1] = value, params2);
    $$invalidate(1, uri = getParameterizedURL(uri, params2));
  }, 200, false);
  const click_handler2 = (_method) => $$invalidate(3, method = _method);
  function input_input_handler() {
    uri = this.value;
    $$invalidate(1, uri);
  }
  const input_handler = ({ target: { value } }) => onURLInputUpdateParams(value);
  const click_handler_1 = (e) => dispatch("fetch");
  const click_handler_2 = (e) => $$invalidate(6, currentTab = 1);
  const click_handler_3 = (e) => $$invalidate(6, currentTab = 2);
  const click_handler_4 = (e) => $$invalidate(6, currentTab = 3);
  const func = (i2) => onRemoveParam(i2);
  const keyUpdate_handler = (i2, e) => updateParamKey(i2, e.detail);
  const valueUpdate_handler = (i2, e) => updateParamValue(i2, e.detail);
  const func_1 = (i2) => onRemoveHeader(i2);
  function keyvaluetable_key_binding(value, keyValue) {
    if ($$self.$$.not_equal(keyValue[0], value)) {
      keyValue[0] = value;
      $$invalidate(5, headers);
    }
  }
  function keyvaluetable_value_binding(value, keyValue) {
    if ($$self.$$.not_equal(keyValue[1], value)) {
      keyValue[1] = value;
      $$invalidate(5, headers);
    }
  }
  const input_handler_1 = (e) => onBodyTypeChange(e.target.value);
  const func_2 = (i2) => onRemoveUrlencoded(i2);
  function keyvaluetable_key_binding_1(value, keyValue) {
    if ($$self.$$.not_equal(keyValue[0], value)) {
      keyValue[0] = value;
      $$invalidate(4, body);
    }
  }
  function keyvaluetable_value_binding_1(value, keyValue) {
    if ($$self.$$.not_equal(keyValue[1], value)) {
      keyValue[1] = value;
      $$invalidate(4, body);
    }
  }
  const input_handler_2 = (e) => parseBodyJSON(e.target.value);
  $$self.$$set = ($$props2) => {
    if ("request" in $$props2)
      $$invalidate(0, request = $$props2.request);
    if ("uri" in $$props2)
      $$invalidate(1, uri = $$props2.uri);
    if ("label" in $$props2)
      $$invalidate(2, label = $$props2.label);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 56) {
      $$invalidate(0, request = { method, body, headers });
    }
  };
  return [
    request,
    uri,
    label,
    method,
    body,
    headers,
    currentTab,
    jsonStr,
    isBodyJSONInvalid,
    params2,
    dispatch,
    bodyTypes,
    methods,
    onBodyTypeChange,
    formatJSON,
    parseBodyJSON,
    addURLEncodedParam,
    onRemoveUrlencoded,
    addHeader,
    onRemoveHeader,
    addNewParams,
    onRemoveParam,
    onURLInputUpdateParams,
    updateParamKey,
    updateParamValue,
    click_handler2,
    input_input_handler,
    input_handler,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    click_handler_4,
    func,
    keyUpdate_handler,
    valueUpdate_handler,
    func_1,
    keyvaluetable_key_binding,
    keyvaluetable_value_binding,
    input_handler_1,
    func_2,
    keyvaluetable_key_binding_1,
    keyvaluetable_value_binding_1,
    input_handler_2
  ];
}
class FetchConfig extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$V, create_fragment$W, safe_not_equal, { request: 0, uri: 1, label: 2 }, null, [-1, -1]);
  }
}
function create_catch_block$5(ctx) {
  let p;
  let t0;
  let t1_value = ctx[30] + "";
  let t1;
  return {
    c() {
      p = element("p");
      t0 = text("Retry ");
      t1 = text(t1_value);
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, t0);
      append(p, t1);
    },
    p(ctx2, dirty) {
      if (dirty & 16 && t1_value !== (t1_value = ctx2[30] + ""))
        set_data(t1, t1_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
function create_then_block$5(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[6] && create_if_block$s(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[6]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 64) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$s(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block$s(ctx) {
  let div2;
  let div1;
  let ul;
  let li0;
  let a;
  let t1;
  let li1;
  let div0;
  let label_1;
  let input;
  let t2;
  let t3;
  let tree;
  let t4;
  let t5;
  let div3;
  let button;
  let t6;
  let button_disabled_value;
  let t7;
  let current;
  let mounted;
  let dispose;
  tree = new Tree({
    props: {
      obj: prepareSchema(jsonParser(ctx[6])),
      stores: ctx[9]
    }
  });
  let if_block0 = ctx[2] && create_if_block_2$8(ctx);
  let if_block1 = !ctx[5] && create_if_block_1$g();
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      ul = element("ul");
      li0 = element("li");
      a = element("a");
      a.textContent = `${T("a_select_properties")}`;
      t1 = space();
      li1 = element("li");
      div0 = element("div");
      label_1 = element("label");
      input = element("input");
      t2 = text("\n                  Preview JSON");
      t3 = space();
      create_component(tree.$$.fragment);
      t4 = space();
      if (if_block0)
        if_block0.c();
      t5 = space();
      div3 = element("div");
      button = element("button");
      t6 = text("Save");
      t7 = space();
      if (if_block1)
        if_block1.c();
      attr(a, "href", "#default");
      attr(a, "data-toggle", "tab");
      attr(li0, "class", "active");
      attr(input, "type", "checkbox");
      attr(div0, "class", "mt-2 mx-2 my-lg-0");
      attr(li1, "class", "pull-right");
      attr(ul, "class", "nav nav-tabs");
      attr(div1, "class", "flex flex-col flex-1");
      attr(div2, "class", "flex flex-row mt-4");
      attr(button, "class", "btn btn-primary");
      button.disabled = button_disabled_value = !ctx[5];
      attr(div3, "class", "mt1");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, ul);
      append(ul, li0);
      append(li0, a);
      append(ul, t1);
      append(ul, li1);
      append(li1, div0);
      append(div0, label_1);
      append(label_1, input);
      input.checked = ctx[2];
      append(label_1, t2);
      append(div1, t3);
      mount_component(tree, div1, null);
      append(div2, t4);
      if (if_block0)
        if_block0.m(div2, null);
      insert(target, t5, anchor);
      insert(target, div3, anchor);
      append(div3, button);
      append(button, t6);
      append(div3, t7);
      if (if_block1)
        if_block1.m(div3, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input, "change", ctx[17]),
          listen(button, "click", ctx[13])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 4) {
        input.checked = ctx2[2];
      }
      const tree_changes = {};
      if (dirty & 64)
        tree_changes.obj = prepareSchema(jsonParser(ctx2[6]));
      tree.$set(tree_changes);
      if (ctx2[2]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_2$8(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div2, null);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!current || dirty & 32 && button_disabled_value !== (button_disabled_value = !ctx2[5])) {
        button.disabled = button_disabled_value;
      }
      if (!ctx2[5]) {
        if (if_block1)
          ;
        else {
          if_block1 = create_if_block_1$g();
          if_block1.c();
          if_block1.m(div3, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(tree.$$.fragment, local);
      transition_in(if_block0);
      current = true;
    },
    o(local) {
      transition_out(tree.$$.fragment, local);
      transition_out(if_block0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      destroy_component(tree);
      if (if_block0)
        if_block0.d();
      if (detaching)
        detach(t5);
      if (detaching)
        detach(div3);
      if (if_block1)
        if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_2$8(ctx) {
  let div;
  let distilledjsontext;
  let current;
  distilledjsontext = new DistilledJSONText({
    props: {
      output: ctx[6],
      preview: "distilled",
      previewJsonStore: ctx[9].previewJson
    }
  });
  return {
    c() {
      div = element("div");
      create_component(distilledjsontext.$$.fragment);
      attr(div, "class", "flex-1");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(distilledjsontext, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const distilledjsontext_changes = {};
      if (dirty & 64)
        distilledjsontext_changes.output = ctx2[6];
      distilledjsontext.$set(distilledjsontext_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(distilledjsontext.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(distilledjsontext.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(distilledjsontext);
    }
  };
}
function create_if_block_1$g(ctx) {
  let p;
  return {
    c() {
      p = element("p");
      p.textContent = "Invalid api/json";
      attr(p, "class", "text-danger");
    },
    m(target, anchor) {
      insert(target, p, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
function create_pending_block$5(ctx) {
  let p;
  return {
    c() {
      p = element("p");
      p.textContent = "Fetching data.....";
    },
    m(target, anchor) {
      insert(target, p, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
function create_fragment$V(ctx) {
  let fetchconfig;
  let updating_uri;
  let updating_request;
  let t;
  let await_block_anchor;
  let promise;
  let current;
  function fetchconfig_uri_binding(value) {
    ctx[15](value);
  }
  function fetchconfig_request_binding(value) {
    ctx[16](value);
  }
  let fetchconfig_props = { label: ctx[8] };
  if (ctx[0] !== void 0) {
    fetchconfig_props.uri = ctx[0];
  }
  if (ctx[3] !== void 0) {
    fetchconfig_props.request = ctx[3];
  }
  fetchconfig = new FetchConfig({ props: fetchconfig_props });
  binding_callbacks.push(() => bind$2(fetchconfig, "uri", fetchconfig_uri_binding));
  binding_callbacks.push(() => bind$2(fetchconfig, "request", fetchconfig_request_binding));
  fetchconfig.$on("fetch", ctx[12]);
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: true,
    pending: create_pending_block$5,
    then: create_then_block$5,
    catch: create_catch_block$5,
    value: 29,
    error: 30,
    blocks: [, , ,]
  };
  handle_promise(promise = ctx[4], info);
  return {
    c() {
      create_component(fetchconfig.$$.fragment);
      t = space();
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      mount_component(fetchconfig, target, anchor);
      insert(target, t, anchor);
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      const fetchconfig_changes = {};
      if (!updating_uri && dirty & 1) {
        updating_uri = true;
        fetchconfig_changes.uri = ctx[0];
        add_flush_callback(() => updating_uri = false);
      }
      if (!updating_request && dirty & 8) {
        updating_request = true;
        fetchconfig_changes.request = ctx[3];
        add_flush_callback(() => updating_request = false);
      }
      fetchconfig.$set(fetchconfig_changes);
      info.ctx = ctx;
      if (dirty & 16 && promise !== (promise = ctx[4]) && handle_promise(promise, info))
        ;
      else {
        update_await_block_branch(info, ctx, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(fetchconfig.$$.fragment, local);
      transition_in(info.block);
      current = true;
    },
    o(local) {
      transition_out(fetchconfig.$$.fragment, local);
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      destroy_component(fetchconfig, detaching);
      if (detaching)
        detach(t);
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function instance$U($$self, $$props, $$invalidate) {
  let savable;
  let $includedJson;
  let $config;
  let $model, $$unsubscribe_model = noop, $$subscribe_model = () => ($$unsubscribe_model(), $$unsubscribe_model = subscribe(model, ($$value) => $$invalidate(20, $model = $$value)), model);
  let $originalJson;
  $$self.$$.on_destroy.push(() => $$unsubscribe_model());
  let expanded = true;
  let { onSave } = $$props;
  let { model } = $$props;
  $$subscribe_model();
  let { uri } = $$props;
  const labels = {
    [C.DS_ID_JSON]: "json",
    [C.DS_ID_UPTIME]: "uptime"
  };
  const fetchMethods = {
    [C.DS_ID_JSON]: fetchJSONAPI,
    [C.DS_ID_UPTIME]: fetchUptime
  };
  let datasource_id = $model.datasource_id;
  let config = $model.config || new Model$2.SieveConfigJSON({}, { parse: true, datasource_id });
  component_subscribe($$self, config, (value) => $$invalidate(19, $config = value));
  let label = labels[datasource_id] || "<unsupported type>";
  let request = $config.request;
  const stores = initStores($config.filters.included);
  const { includedJson, originalJson } = stores;
  component_subscribe($$self, includedJson, (value) => $$invalidate(18, $includedJson = value));
  component_subscribe($$self, originalJson, (value) => $$invalidate(6, $originalJson = value));
  let outputPromise;
  async function fetchJSONAPI(body) {
    try {
      $$invalidate(5, savable = false);
      let data = await Api.utils(APIUrl, "POST", body);
      if (data.body) {
        $$invalidate(5, savable = true);
        originalJson.update((val) => data.body);
      } else {
        originalJson.update((val) => data);
      }
    } catch (e) {
      let error = {
        status: 500,
        body: e || "Internal server error, Retry"
      };
      originalJson.update((val) => error);
    }
  }
  async function fetchUptime(body) {
    try {
      $$invalidate(5, savable = false);
      let res2 = await Api.api(`/datasources/${datasource_id}/fetch`, "POST", getSieve());
      originalJson.update((val) => res2);
      $$invalidate(5, savable = true);
    } catch (e) {
      let error = {
        status: 500,
        body: e.message || e.msg || "Internal server error, Retry"
      };
      originalJson.update((val) => error);
    }
  }
  function fetchData2() {
    let method = fetchMethods[datasource_id];
    $$invalidate(4, outputPromise = method(getSieve()));
  }
  if (uri) {
    fetchData2();
  }
  function getSieve() {
    let uriObj = new URL(uri);
    return {
      name: uriObj.host,
      uri,
      config: getConfig()
    };
  }
  function getConfig() {
    return { request, filters: getFilters() };
  }
  function getFilters() {
    return {
      included: $includedJson.map((value) => value[1] === CheckState.selected ? value[0] : null).filter((value) => value)
    };
  }
  function save() {
    onSave(getSieve());
  }
  function fetchconfig_uri_binding(value) {
    uri = value;
    $$invalidate(0, uri);
  }
  function fetchconfig_request_binding(value) {
    request = value;
    $$invalidate(3, request);
  }
  function input_change_handler() {
    expanded = this.checked;
    $$invalidate(2, expanded);
  }
  $$self.$$set = ($$props2) => {
    if ("onSave" in $$props2)
      $$invalidate(14, onSave = $$props2.onSave);
    if ("model" in $$props2)
      $$subscribe_model($$invalidate(1, model = $$props2.model));
    if ("uri" in $$props2)
      $$invalidate(0, uri = $$props2.uri);
  };
  $$invalidate(5, savable = false);
  return [
    uri,
    model,
    expanded,
    request,
    outputPromise,
    savable,
    $originalJson,
    config,
    label,
    stores,
    includedJson,
    originalJson,
    fetchData2,
    save,
    onSave,
    fetchconfig_uri_binding,
    fetchconfig_request_binding,
    input_change_handler
  ];
}
class Json extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$U, create_fragment$V, safe_not_equal, { onSave: 14, model: 1, uri: 0 });
  }
}
const JSONSelector = View$1.ActionProvider.extend({
  name: "JSONSelector",
  onSave: function(sieve) {
    this.trigger("save", sieve);
  },
  async postInit() {
    this.model.get("config") || new Model$2.SieveConfigJSON({}, {
      parse: true,
      datasource_id: this.model.get("datasource_id")
    });
    this.view = new Json({
      target: this.el,
      props: {
        onSave: this.onSave,
        model: this.model,
        uri: this.model.get("uri")
      }
    });
  },
  remove: function() {
    JSONSelector.__super__.remove.call(this);
    this.view.$destroy();
  }
});
const $$4 = window.jQuery;
if (!$$4) {
  throw new Error("ADD jQuery");
}
const _$3 = window._;
if (!_$3) {
  throw new Error("ADD _");
}
const domo$2 = window.domo;
if (!domo$2) {
  throw new Error("ADD domo");
}
const async$3 = window.async;
if (!async$3) {
  throw new Error("ADD async");
}
const XMLSelector = View$1.ActionProvider.extend({
  events: {
    "keypress input": "event_load",
    "click .xtbar .btn.xadd": "event_add"
  },
  event_add: function(event) {
    if (this.xml) {
      this.trigger("save", {
        uri: this.url,
        content_type: C.TYPE_XML,
        config: {
          selection: {
            excludes: [],
            includes: [{
              type: "xpath",
              expr: "/*"
            }]
          }
        }
      });
    } else {
      this.error("XML could not be loaded or parsed.");
    }
  },
  event_load: function(event) {
    if (event.keyCode == 13) {
      this.loadURL(this.$(".xurl").val());
    }
  },
  error: function(msg) {
    this.$(".xpreview").addClass("xerror").text(msg ? T(msg) : "");
  },
  msg: function(msg) {
    this.$(".xpreview").removeClass("xerror").text(msg ? T(msg) : "");
  },
  loadURL: function(url) {
    const self = this;
    this.msg("");
    if (url.indexOf(":") < 0) {
      url = "http://" + url;
    }
    if (!/[-a-zA-Z0-9@:%_\+.~#?&//=]{2,256}\.[a-z]{2,4}\b(\/[-a-zA-Z0-9@:%_\+.~#?&//=]*)?/gi.test(url)) {
      this.error("m_enter_valid_url");
      return;
    }
    this.url = url;
    this.$(".xtbar").empty();
    this.msg("l_loading");
    fetchResource(url, function(err, xhrObj) {
      if (err) {
        self.error("e_load_source");
        return;
      }
      let response = xhrObj.response;
      let contentType = xhrObj.headers["content-type"];
      if (response.nodeType === Node.DOCUMENT_NODE) {
        response = response.documentElement.outerHTML;
      }
      contentType = contentType.split(";")[0];
      switch (contentType) {
        case "application/xml":
        case "text/xml":
        case "application/rss+xml":
        case "application/atom+xml":
          self.msg("Parsing xml...");
          self.onXML(response);
          break;
        default:
          self.error(SPRINTF("e_unknown_content_type", contentType));
          break;
      }
    });
  },
  onXML: function(xmlStr) {
    const xml = new DOMParser().parseFromString(xmlStr, "text/xml");
    this.msg("");
    if (!xml) {
      this.xml = null;
      this.error("Failed to parse XML");
    } else {
      this.xml = xml;
      this.$(".xpreview").text(xmlStr);
      this.$(".xtbar").empty().append(BUTTON({ "class": "btn btn-primary xadd" }, T("a_select")));
    }
  },
  render: function() {
    this.$el.empty().append(DIV(DIV(INPUT({
      "class": "form-control xurl",
      "placeholder": T("m_enter_xml_url")
    })), DIV({ "class": "xtbar " }), PRE({ "class": "xpreview", "style": "max-height: 400px;overflow:auto;" })));
    return this;
  }
});
async function fetchResource(url, callback) {
  if (Supports.agents.local) {
    try {
      let res2 = await serviceProxy.HTTP.get({ url });
      callback(null, res2);
    } catch (err) {
      callback(err);
    }
  } else {
    $$4.get(`${URL_UTILS}/v1/http/get?url=${encodeURIComponent(url)}`, function(res2, status, xhr) {
      callback(null, { xhr });
    }).fail(function() {
      callback("Error fetching resource: " + url);
    });
  }
}
class Selector$1 {
  constructor(value, meta = {}) {
    this.value = value;
    this.meta = meta;
  }
  toJSON() {
    return {
      type: this.getType(),
      meta: this.meta,
      value: this.value
    };
  }
}
class CSSSelector extends Selector$1 {
  select(doc) {
    return Promise.resolve([...doc.querySelectorAll(this.value)]);
  }
  getType() {
    return "css";
  }
}
var Feature;
(function(Feature2) {
  Feature2["command"] = "command";
  Feature2["stream_dom"] = "stream_dom";
  Feature2["state"] = "state";
  Feature2["stream_video"] = "video";
})(Feature || (Feature = {}));
var EventNames;
(function(EventNames2) {
  EventNames2["BROADCAST"] = "BS";
  EventNames2["ALL"] = "all";
  EventNames2["DOM_STREAM"] = "DS";
  EventNames2["WEBRTC_STREAM"] = "WS";
  EventNames2["FRAME_DEL"] = "frame:del";
  EventNames2["FRAME_NEW"] = "frame:new";
  EventNames2["FRAME_UPDATE"] = "frame:update";
  EventNames2["PAGE_DEL"] = "page:del";
  EventNames2["PAGE_NEW"] = "page:new";
  EventNames2["VIEWPORT"] = "viewport";
  EventNames2["MSG_EVENT"] = "EV";
  EventNames2["MSG_REQUEST"] = "RQ";
  EventNames2["MSG_RESPONSE"] = "RS";
  EventNames2["MSG_STATE"] = "ST";
  EventNames2["NET_RESPONSE"] = "NETRS";
  EventNames2["TOPIC_SUBSCRIBE"] = "topic:subscribe";
  EventNames2["TOPIC_UNSUBSCRIBE"] = "topic:unsubscribe";
  EventNames2["CHANGE"] = "change";
})(EventNames || (EventNames = {}));
var OPS;
(function(OPS2) {
  OPS2["CREATE"] = "create";
  OPS2["UPDATE"] = "update";
  OPS2["DELETE"] = "delete";
})(OPS || (OPS = {}));
var StreamTypes;
(function(StreamTypes2) {
  StreamTypes2["AUDIO"] = "audio";
  StreamTypes2["VIDEO"] = "video";
  StreamTypes2["CANVAS"] = "canvas";
})(StreamTypes || (StreamTypes = {}));
var SignalEvent;
(function(SignalEvent2) {
  SignalEvent2["STREAM_VIDEO"] = "stream-video";
  SignalEvent2["MAP_ELEMENT"] = "map-element";
  SignalEvent2["ADD_PEER"] = "add-peer";
  SignalEvent2["CLIENT_CANDIDATE"] = "client-candidate";
  SignalEvent2["CLIENT_DESCRIPTION"] = "client-description";
  SignalEvent2["SERVER_CANDIDATE"] = "server-candidate";
  SignalEvent2["SERVER_DESCRIPTION"] = "server-description";
  SignalEvent2["REMOVE_PEER"] = "remove-peer";
  SignalEvent2["DISCONNECT_ALL"] = "disconnect-all";
})(SignalEvent || (SignalEvent = {}));
var DiffOp;
(function(DiffOp2) {
  DiffOp2[DiffOp2["DEL"] = -1] = "DEL";
  DiffOp2[DiffOp2["INS"] = 1] = "INS";
  DiffOp2[DiffOp2["NOOP"] = 0] = "NOOP";
})(DiffOp || (DiffOp = {}));
var DocumentContentType;
(function(DocumentContentType2) {
  DocumentContentType2["JSON"] = "application/json";
  DocumentContentType2["HTML"] = "text/html";
})(DocumentContentType || (DocumentContentType = {}));
var Severity;
(function(Severity2) {
  Severity2["Fatal"] = "fatal";
  Severity2["Error"] = "error";
  Severity2["Warning"] = "warning";
  Severity2["Log"] = "log";
  Severity2["Info"] = "info";
  Severity2["Debug"] = "debug";
  Severity2["Critical"] = "critical";
})(Severity || (Severity = {}));
class BBXErrorEvent {
  constructor(e, type) {
    this.name = "BBXErrorEvent";
    this.metadata = {};
    this.source = "bbx-client";
    this.breadcrumbs = [];
    this.message = e.message;
    if (e.stack) {
      this.stack = e.stack;
    }
    if (type) {
      this.type = type;
    }
  }
  setPreviousEvents(crumbs) {
    this.breadcrumbs = crumbs.flatten();
    this.breadcrumbs.sort((a, b) => {
      return a.timestamp > b.timestamp ? 1 : -1;
    });
  }
}
class DOMEventError extends BBXErrorEvent {
  constructor(e, type, url, isMainFrame = false) {
    super(e, type);
    this.name = "DOMEventError";
    if (url) {
      this.metadata["url"] = url;
    }
    this.metadata["isMainFrame"] = isMainFrame;
  }
}
class AppliedDOMStreamEvent {
  constructor(event, start, err) {
    this.executions = [];
    this.event = event;
    this.add(start, err);
  }
  add(start, err) {
    this.executions.push({
      start,
      end: new Date(),
      err
    });
  }
  toBreadCrumb() {
    const breadcrumb = {
      category: this.event.name,
      timestamp: this.executions[0].start.getTime() / 1e3,
      data: {
        count: this.executions.length,
        start: this.executions[0].start,
        end: this.executions[this.executions.length - 1].end
      }
    };
    for (let i2 = 0; i2 < this.executions.length; i2++) {
      let exec = this.executions[i2];
      if (exec.err) {
        breadcrumb.message || (breadcrumb.message = exec.err.message);
        breadcrumb.data[i2] = exec.err.message;
        breadcrumb.level || (breadcrumb.level = Severity.Error);
      }
    }
    return breadcrumb;
  }
}
class AppliedDOMStreamEvents {
  constructor(maxLength) {
    this.maxLength = 15;
    this.events = [];
    this.maxLength = maxLength;
  }
  push(event, startTime, err = void 0) {
    const lastAppliedEvent = this.events[this.events.length - 1];
    if (lastAppliedEvent && lastAppliedEvent.event.name === event.name) {
      lastAppliedEvent.add(startTime, err);
      return;
    }
    if (this.events.length === this.maxLength) {
      this.events.shift();
    }
    this.events.push(new AppliedDOMStreamEvent(event, startTime, err));
  }
  flatten() {
    const breadcrumbs = [];
    this.events.map((e) => {
      return e.toBreadCrumb();
    }).forEach((crumb) => {
      breadcrumbs.push(crumb);
    });
    return breadcrumbs;
  }
}
function id(prefix = "", seed = 0) {
  return () => `${prefix}${seed++}`;
}
class EventEmitter {
  constructor() {
    this.__ee_listeners = {};
  }
  emit(name, ...args) {
    (this.__ee_listeners[name] || []).forEach((l) => l(...args));
  }
  hasListener(name) {
    return (this.__ee_listeners[name] || []).length > 0;
  }
  off(name, listener) {
    let listeners = this.__ee_listeners[name];
    if (listeners == void 0) {
      listeners = this.__ee_listeners[name] = [];
    }
    let index2 = listeners.indexOf(listener);
    while (index2 >= 0) {
      listeners.splice(index2, 1);
      index2 = listeners.indexOf(listener);
    }
    return this;
  }
  on(name, listener) {
    let listeners = this.__ee_listeners[name];
    if (listeners == void 0) {
      listeners = this.__ee_listeners[name] = [];
    }
    listeners.push(listener);
    return this;
  }
  once(name, listener) {
    const l2 = (...args) => {
      this.off(name, l2);
      listener(...args);
    };
    this.on(name, l2);
    return this;
  }
  reset() {
    this.__ee_listeners = [];
  }
  waitForEvent(name, ...selectors) {
    return new Promise((resolve) => {
      const l2 = (...args) => {
        for (let i2 = 0, length = selectors.length; i2 < length; i2 += 1) {
          if (selectors[i2] !== args[i2]) {
            return;
          }
        }
        resolve(args[0]);
      };
      this.on(name, l2);
    });
  }
}
const CLIENT_VERSION = "2.2.3";
const idFn = id("_");
class APIClient extends EventEmitter {
  constructor(options) {
    super();
    this.messageListeners = [];
    this.messageQueue = [];
    this._responseListeners = /* @__PURE__ */ new Map();
    if (!options.basePath) {
      options.basePath = "";
    }
    this.options = options;
    this.onMessage = this.onMessage.bind(this);
    this.onSocketClose = this.onSocketClose.bind(this);
    this.onSocketError = this.onSocketError.bind(this);
    this.onSocketOpen = this.onSocketOpen.bind(this);
    this._isS = !(location.protocol == "http:" && options.host.startsWith("localhost:"));
  }
  addMessageListener(messageListener) {
    this.messageListeners.push(messageListener);
  }
  removeMessageListener(messageListener) {
    let index2 = this.messageListeners.indexOf(messageListener);
    if (index2 >= 0) {
      this.messageListeners.splice(index2, 1);
    }
  }
  close() {
    if (this.socket) {
      this.removeSocketListeners();
      if (this.socket.readyState != WebSocket.CLOSED) {
        this.socket.close(1e3);
      }
    }
  }
  async connect() {
    if (this.socket) {
      this.removeSocketListeners();
    }
    let url;
    if (this.options.host) {
      url = `ws${this._isS ? "s" : ""}://${this.options.host + this.options.basePath}`;
      let checkReady = this.options.checkReady == void 0 ? true : this.options.checkReady;
      if (checkReady) {
        await this.waitForInstanceToBeReady();
      }
    } else {
      if (this.options.url) {
        console.warn(`Browser-box has deprecated Url as connect option, host can be given as option
 Eg: {host:abc.bbx.net}  `);
      } else {
        console.error(`Host was not given as option, host can be given as option
  Eg: {host:abc.bbx.net}  `);
      }
    }
    this.socket = new WebSocket(url);
    this.addSocketListeners();
  }
  async waitForInstanceToBeReady() {
    let retryCount = 22, ready = false;
    while (retryCount > 0 && !ready) {
      try {
        let res2 = await this.api("about");
        ready = true;
      } catch (e) {
        console.error("bbx runner not ready?", e);
        await wait$2(2400);
      }
      retryCount--;
    }
    if (!ready) {
      this.emit("socket:error", { message: "Browser server not ready" });
      throw new Error("Browser server not ready");
    }
  }
  addSocketListeners() {
    this.socket.addEventListener("open", this.onSocketOpen);
    this.socket.addEventListener("error", this.onSocketError);
    this.socket.addEventListener("close", this.onSocketClose);
    this.socket.addEventListener("message", this.onMessage);
  }
  removeSocketListeners() {
    this.socket.removeEventListener("open", this.onSocketOpen);
    this.socket.removeEventListener("error", this.onSocketError);
    this.socket.removeEventListener("close", this.onSocketClose);
    this.socket.removeEventListener("message", this.onMessage);
  }
  async api(path, method = "GET", data = void 0) {
    let { host, key, basePath } = this.options;
    let hasData = !!data;
    let url = `http${this._isS ? "s" : ""}://${host}${basePath}/${path}`;
    let headers = {
      "content-type": "application/json",
      "x-auth": key,
      "x-client-id": this.clientId
    };
    let res2 = await fetch(url, {
      method,
      mode: "cors",
      headers,
      body: hasData ? JSON.stringify(data) : void 0
    });
    switch (res2.status) {
      case 200:
        return await res2.json();
      case 401:
        throw new Error("Invalid authentication credentials");
      default:
        console.error("invalid response", res2);
        throw new Error("Error response received.");
    }
  }
  async call(name, ...args) {
    let id2 = idFn();
    try {
      this.send(JSON.stringify({
        type: EventNames.MSG_REQUEST,
        id: id2,
        name,
        args
      }));
      return this._waitForResponse(id2);
    } catch (e) {
      this.emit("api:error", e);
      throw e;
    }
  }
  async callPup(path, method, ...args) {
    return this.call("pup", path, method, ...args);
  }
  async _waitForResponse(id2) {
    return new Promise((resolve, reject) => {
      this._responseListeners.set(id2, (res2) => {
        let err = res2.err;
        if (err) {
          reject(res2.err);
        } else {
          resolve(res2.data);
        }
      });
    });
  }
  onMessage(msg) {
    let data = JSON.parse(msg.data);
    if (data.type == EventNames.MSG_RESPONSE) {
      this.onResponse(data);
      return;
    }
    this.messageListeners.forEach((l) => l.onMessage(data));
  }
  onResponse(response) {
    let { id: id2 } = response;
    let handler = this._responseListeners.get(id2);
    if (handler) {
      this._responseListeners.delete(id2);
      handler(response);
    } else {
      console.error("Unhandled response", response);
      throw new Error("Unhandled response: " + id2);
    }
  }
  onSocketClose(e) {
    this.emit("socket:close", { code: e.code });
  }
  onSocketError(e) {
    this.emit("socket:error");
  }
  async onSocketOpen(e) {
    let resp = await this.register();
    this.clientId = resp.clientId;
    this.messageQueue.forEach((msg) => this.send(msg));
    this.messageQueue = [];
  }
  async register() {
    let data = {
      features: this.options.features,
      key: this.options.key,
      clientVersion: CLIENT_VERSION,
      allowJSON: true
    };
    return await this.call("register", data);
  }
  send(msg) {
    let socket = this.socket;
    if (socket && socket.readyState == WebSocket.OPEN) {
      this.socket.send(msg);
    } else {
      this.messageQueue.push(msg);
    }
  }
  async sendError(e) {
    await this.api("errors", "POST", e);
  }
}
async function wait$2(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
function connect(options) {
  let apiClient = new APIClient(options);
  apiClient.connect().catch((e) => {
    apiClient.sendError(new BBXErrorEvent(e, "connect"));
  });
  return apiClient;
}
const TOPIC_ORIGIN = "t";
class BaseItem extends EventEmitter {
  constructor(data, collection) {
    super();
    this.collection = collection;
    this.id = data.id;
    this.set(data);
  }
  set(data) {
    this.data = { ...this.data, ...data };
    this.collection.emit(EventNames.ALL, {
      name: OPS.UPDATE,
      event: { data }
    });
    this.collection.emit(OPS.UPDATE, { data });
  }
}
class BaseCollection extends EventEmitter {
  constructor(name, store2, options = {}) {
    super();
    this.items = [];
    this.onTopicEvent = async (event) => {
      let resp, item;
      let id2 = event.result.id;
      switch (event.operation) {
        case OPS.CREATE:
        case OPS.UPDATE:
          resp = await this._api(`/${id2}`);
          item = this.get(resp.id);
          item ? item.set(resp) : this._add(resp);
          break;
        case OPS.DELETE:
          item = this.get(id2);
          if (item) {
            this._remove(item);
          } else {
            console.error("the item is already deleted", event.result);
          }
          break;
      }
    };
    this.name = name;
    this.store = store2;
    this.options = options;
    if (this.options.autoSync) {
      this.enableSync();
    }
  }
  async getCurrentItems() {
    let resp = await this.fetch();
    (resp.data || []).forEach((it) => {
      let item = this.get(it.id);
      item ? item.set(it) : this._add(it);
    });
  }
  enableSync() {
    if (!this._unSubscribe) {
      this._unSubscribe = this.store.subscribe(this.name, this.onTopicEvent);
    }
  }
  disableSync() {
    this._unSubscribe();
  }
  _api(path, method = "GET", data = null) {
    const url = `${TOPIC_ORIGIN}/${this.name}` + path;
    return this.store.apiClient.api(url, method, data);
  }
  get(id2) {
    return this.items.find((item) => item.id === id2);
  }
  setQuery(query) {
    this.query = new URLSearchParams(query).toString();
  }
  async fetch() {
    let path = this.query ? "?" + this.query : "";
    let resp = await this._api(path);
    return resp;
  }
  async _add(data) {
    let item = this.newItem(data);
    this.emit(OPS.CREATE, { data });
    this.emit(EventNames.ALL, {
      name: OPS.CREATE,
      event: { data }
    });
    this.items.push(item);
    return item;
  }
  async _remove(item) {
    let index2 = this.items.indexOf(item);
    this.items.splice(index2, 1);
    this.emit(OPS.DELETE, { data: item.id });
    this.emit(EventNames.ALL, {
      name: OPS.DELETE,
      event: { data: item.id }
    });
  }
}
class Clients extends BaseCollection {
  constructor(store2, options = {}) {
    super("client", store2, options);
    this.name = "client";
  }
  newItem(data) {
    return new BaseItem(data, this);
  }
}
class Base$1 extends EventEmitter {
  constructor(caller, id2) {
    super();
    this.caller = caller;
    this.id = id2;
  }
  async call(method, ...args) {
    this.emit("call", this, { method, args });
    return this.caller.call(this.getPath(), method, ...args);
  }
  getPath() {
    let parent2 = this.getParent();
    let path = parent2 ? parent2.getPath() : [];
    path.push(this.getNodeId());
    return path;
  }
}
class Frame extends Base$1 {
  constructor(page, state) {
    super(page.caller, state.id);
    this.page = page;
  }
  getIndex() {
    return this.page.frames.indexOf(this);
  }
  getNodeId() {
    return { name: "frame", id: this.id };
  }
  getParent() {
    return this.page;
  }
  isMain() {
    return this.page.mainFrame == this;
  }
  update(state) {
    Object.assign(this, state);
    this.emit("change", state);
  }
}
class Page extends Base$1 {
  constructor(browser, state) {
    super(browser.caller, state.id);
    this.frames = [];
    this.browser = browser;
    for (let i2 = 0; i2 < state.frames.length; i2 += 1) {
      let frame = new Frame(this, state.frames[i2]);
      this.frames.push(frame);
    }
    this.mainFrame = this.frames[0];
    this.mainFrame.on("change", (e) => this.emit("change", e));
  }
  addFrame(state) {
    let frame = new Frame(this, state);
    this.frames.push(frame);
    this.emit("frameadded", frame);
    return frame;
  }
  delFrame(frameId) {
    let frame = this.getFrame(frameId);
    if (frame) {
      let index2 = this.frames.indexOf(frame);
      this.frames.splice(index2, 1);
      this.emit("framedetached", frame);
    } else {
      console.warn("warn: failed to delete frame");
    }
    return frame;
  }
  async close() {
    return this.call("close");
  }
  async goto(url, options) {
    return this.call("goto", ...arguments);
  }
  async goBack() {
    return this.call("goBack", ...arguments);
  }
  async goForward() {
    return this.call("goForward", ...arguments);
  }
  async reload() {
    return this.goto(this.mainFrame.url);
  }
  async trigger(name, params2) {
    this.emit("trigger", name, params2);
    return this.browser.call("trigger", this.id, name, params2);
  }
  getFrame(frameId) {
    let frames = this.frames;
    let len = frames.length;
    for (let i2 = 0; i2 < len; i2 += 1) {
      let frame = frames[i2];
      if (frame.id == frameId) {
        return frame;
      }
    }
  }
  getNodeId() {
    return { name: "page", id: this.id };
  }
  getParent() {
    return this.browser;
  }
}
class Browser$2 extends Base$1 {
  constructor(caller, state) {
    super(caller, "0");
    this.pages = [];
    for (let i2 = 0; i2 < state.pages.length; i2 += 1) {
      this.pages.push(new Page(this, state.pages[i2]));
    }
    this.viewport = state.viewport;
  }
  async newPage() {
    let res2 = await this.call("newPage");
    let pageState = res2;
    let page = this.getPage(pageState.id);
    if (page) {
      return page;
    }
    return await this.waitForEvent("pageadded");
  }
  onNewPage(state) {
    let page = new Page(this, state);
    this.pages.push(page);
    this.emit("pageadded", page);
    return page;
  }
  onDelPage(pageId) {
    let page = this.getPage(pageId);
    if (page) {
      let index2 = this.pages.indexOf(page);
      this.pages.splice(index2, 1);
      this.emit("pagedeleted", page);
    } else {
      console.warn("warn: failed to delete page");
    }
    return page;
  }
  onViewport(viewport) {
    this.viewport = viewport;
    this.emit("viewport", viewport);
  }
  getNodeId() {
    return { name: "browser", id: this.id };
  }
  getActivePage() {
    return this.pages[this.pages.length - 1];
  }
  async setActivePage(id2) {
    throw new Error("Not implemented");
  }
  getPage(id2) {
    let pages = this.pages;
    let len = pages.length;
    for (let i2 = 0; i2 < len; i2 += 1) {
      let page = pages[i2];
      if (page.id == id2) {
        return page;
      }
    }
  }
  getParent() {
    return null;
  }
}
class StoreManager extends EventEmitter {
  constructor(apiClient) {
    super();
    this.connectedClients = [];
    this._domStreamListeners = [];
    this._webrtcStreamListeners = [];
    this.apiClient = apiClient;
    this.apiClient.addMessageListener(this);
    this.clients = new Clients(this, { autoSync: true });
  }
  subscribe(name, callback = (event) => {
  }) {
    if (!this.hasListener(`broadcast:${name}`)) {
      this.apiClient.call(EventNames.TOPIC_SUBSCRIBE, {
        name
      });
    }
    this.on(`broadcast:${name}`, callback);
    return () => {
      this.off(`broadcast:${name}`, callback);
      if (!this.hasListener(`broadcast:${name}`)) {
        this.apiClient.call(EventNames.TOPIC_UNSUBSCRIBE, {
          name
        });
      }
    };
  }
  addDOMStreamListener(listener) {
    this._domStreamListeners.push(listener);
  }
  removeDOMStreamListener(listener) {
    let index2 = this._domStreamListeners.indexOf(listener);
    while (index2 >= 0) {
      this._domStreamListeners.splice(index2, 1);
      index2 = this._domStreamListeners.indexOf(listener);
    }
  }
  addWEBRTCStreamListener(listener) {
    this._webrtcStreamListeners.push(listener);
  }
  removeWEBRTCStreamListener(listener) {
    let index2 = this._webrtcStreamListeners.indexOf(listener);
    while (index2 >= 0) {
      this._webrtcStreamListeners.splice(index2, 1);
      index2 = this._webrtcStreamListeners.indexOf(listener);
    }
  }
  onMessage(data) {
    let { type } = data;
    switch (type) {
      case EventNames.MSG_EVENT:
        this.onEvent(data);
        break;
      case EventNames.MSG_STATE:
        this.onState(data.data);
        break;
      case EventNames.BROADCAST:
        this.onBroadcast(data);
        break;
    }
  }
  onBroadcast(event) {
    let { name, data } = event;
    this.emit(`broadcast:${name}`, data);
  }
  onEvent(event) {
    let { name, data } = event;
    let obj;
    switch (name) {
      case EventNames.WEBRTC_STREAM: {
        let [pageId2, frameId2, peerId, webrtcEvent] = data;
        const webrtcData = JSON.parse(webrtcEvent);
        this._webrtcStreamListeners.forEach(async (l) => await l.onWEBRTCEvent(pageId2, frameId2, peerId, webrtcData));
        let frame2 = this.browser.getPage(pageId2).getFrame(frameId2);
        frame2.emit(EventNames.WEBRTC_STREAM, webrtcData);
        break;
      }
      case EventNames.DOM_STREAM:
        let [pageId, frameId, domEvent] = data;
        this._domStreamListeners.forEach((l) => l.onDOMEvent(pageId, frameId, domEvent));
        let page = this.browser.getPage(pageId);
        let frame = obj = page.getFrame(frameId);
        frame.emit(EventNames.DOM_STREAM, domEvent);
        break;
      case EventNames.FRAME_DEL: {
        let [pageId2, frameId2] = data;
        let page2 = obj = this.browser.getPage(pageId2);
        page2.delFrame(frameId2);
        break;
      }
      case EventNames.FRAME_NEW: {
        let [pageId2, frameState] = data;
        let page2 = this.browser.getPage(pageId2);
        obj = page2.addFrame(frameState);
        break;
      }
      case EventNames.FRAME_UPDATE: {
        let [pageId2, frameState] = data;
        let page2 = this.browser.getPage(pageId2);
        let frame2 = obj = page2.getFrame(frameState.id);
        frame2.update(frameState);
        break;
      }
      case EventNames.PAGE_DEL: {
        let [pageId2] = data;
        obj = this.browser.onDelPage(pageId2);
        break;
      }
      case EventNames.PAGE_NEW: {
        let [pageState] = data;
        obj = this.browser.onNewPage(pageState);
        break;
      }
      case EventNames.VIEWPORT: {
        let [viewport] = data;
        this.browser.onViewport(viewport);
        obj = this.browser;
        break;
      }
      default:
        console.warn("Unhandled event:", name, data);
    }
    this.emit("bbx", name, obj, data);
  }
  onState(state) {
    this.browser = new Browser$2(this, state);
    this.emit("ready");
  }
  async call(path, method, ...args) {
    this.emit("api", path, method, ...args);
    return await this.apiClient.callPup(getNodePath(path), method, ...args);
  }
}
function getNodePath(nodes) {
  return nodes.map((node2) => node2.id).join("/");
}
function debounce$1(func, wait2, immediate = false) {
  let timeout;
  return function() {
    let context = this, args = arguments;
    let callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(function() {
      timeout = null;
      if (!immediate) {
        func.apply(context, args);
      }
    }, wait2);
    if (callNow)
      func.apply(context, args);
  };
}
function findPath(child, pathArr = []) {
  let parent2 = child.parentElement;
  if (parent2 === null) {
    pathArr.reverse();
    return pathArr;
  }
  let childList = parent2.childNodes;
  let index2;
  for (let i2 = 0; i2 < childList.length; ++i2) {
    if (childList[i2] === child) {
      index2 = i2;
      break;
    }
  }
  pathArr.push(index2);
  return findPath(parent2, pathArr);
}
function getNode(path, doc) {
  let next = doc.documentElement;
  for (let i2 = 0, len = path.length; i2 < len; i2++) {
    let ind = path[i2], child;
    if (ind == -1) {
      child = next.shadowRoot;
    } else {
      child = next.childNodes[path[i2]];
    }
    if (!child) {
      throw new Error(`Failed to find node at: ${i2} for path: ${path}. Last parent found is: ${next.nodeName}`);
    }
    next = child;
  }
  return next;
}
function createElement(node2, parentNamespace) {
  if (!!node2[4]) {
    if ("http://www.w3.org/1999/xhtml" === node2[4]) {
      return document.createElementNS(node2[4], node2[1].toLowerCase());
    }
    return document.createElementNS(node2[4], node2[1]);
  } else if (!!parentNamespace && parentNamespace.length > 0) {
    if ("http://www.w3.org/1999/xhtml" === parentNamespace) {
      return document.createElementNS(parentNamespace, node2[1].toLowerCase());
    }
    return document.createElementNS(parentNamespace, node2[1]);
  } else {
    return document.createElement(node2[1].toLowerCase());
  }
}
function setAttributes(elem, attributes) {
  for (let i2 = 0; !!attributes && i2 < attributes.length; i2++) {
    let attribute = attributes[i2];
    setAttribute(attribute, elem);
  }
}
function setAttribute(attribute, elem) {
  let keys = Object.keys(attribute);
  let namespace, qualifiedName, value;
  try {
    if (!!keys && keys.length === 2) {
      if ("namespaceURI" === keys[0]) {
        namespace = attribute[keys[0]];
        qualifiedName = keys[1];
        value = attribute[keys[1]];
      } else {
        namespace = attribute[keys[1]];
        qualifiedName = keys[0];
        value = attribute[keys[0]];
      }
      elem.setAttributeNS(namespace, qualifiedName, value);
    } else if (keys.length === 1) {
      qualifiedName = keys[0];
      value = attribute[keys[0]];
      elem.setAttribute(qualifiedName, value);
    }
  } catch (err) {
    if (namespace) {
      console.error("error while setting attributesNs", namespace, qualifiedName, value);
    } else {
      console.error("error while setting attributes", qualifiedName, value);
    }
  }
}
function appendDOM(elem, child) {
  if (child) {
    if (elem.nodeType === Node.COMMENT_NODE) {
      if (child.nodeType === Node.TEXT_NODE) {
        elem.nodeValue += child.nodeValue;
      }
    } else {
      elem.appendChild(child);
    }
  }
}
function patch(elem, jsonNode) {
  let childNodes = jsonNode[3];
  for (let i2 = 0; !!childNodes && i2 < childNodes.length; i2++) {
    if (!!childNodes[i2]) {
      appendDOM(elem, toDOM(childNodes[i2], elem.namespaceURI));
    }
  }
  let attributes = jsonNode[2];
  if (!!attributes && attributes.length > 0) {
    setAttributes(elem, attributes);
  }
  return elem;
}
function toDOM(jsonNode, parentNamespace) {
  if (!jsonNode) {
    return null;
  }
  if (jsonNode[0] === Node.TEXT_NODE) {
    jsonNode = jsonNode;
    return document.createTextNode(jsonNode[1]);
  }
  if (jsonNode[0] === Node.CDATA_SECTION_NODE) {
    jsonNode = jsonNode;
    return document.createCDATASection(jsonNode[1]);
  }
  if (jsonNode[0] === Node.COMMENT_NODE) {
    jsonNode = jsonNode;
    return document.createComment(jsonNode[1]);
  }
  jsonNode = jsonNode;
  return patch(createElement(jsonNode, parentNamespace), jsonNode);
}
function parseHTML(documentContent, doc = document) {
  let node2;
  if (typeof documentContent == "string") {
    let parser = new DOMParser();
    node2 = parser.parseFromString(documentContent, "text/html").documentElement;
  } else if (documentContent.type === DocumentContentType.JSON) {
    node2 = toDOM(documentContent.content, null);
  }
  if (node2.nodeType === Node.ELEMENT_NODE) {
    let el = node2;
    revertTextNodes(el);
  }
  return node2;
}
function parseHTMLFrag(documentContent, doc) {
  let node2;
  if (typeof documentContent == "string") {
    node2 = parseHTMLUsingTemplate(documentContent, doc);
  } else if (documentContent.type === DocumentContentType.JSON) {
    node2 = toDOM(documentContent.content, null);
  }
  if (node2.nodeType == doc.ELEMENT_NODE) {
    revertTextNodes(node2);
  }
  return node2;
}
function parseHTMLUsingTemplate(html2, doc) {
  if (html2[0] == "#") {
    return doc.createTextNode(html2.slice(1));
  }
  if (html2.slice(0, 4) == "<!--") {
    return doc.createComment("");
  }
  const template = doc.createElement("template");
  template.innerHTML = html2;
  let clone = doc.importNode(template.content, true);
  return clone.childNodes[0];
}
function revertTextNodes(el) {
  const elTextNodes = Array.from(el.querySelectorAll("text-node"));
  for (let i2 = 0, len = elTextNodes.length; i2 < len; i2 += 1) {
    const tEl = elTextNodes[i2];
    tEl.replaceWith(document.createTextNode(tEl.innerHTML));
  }
}
function applyPatch(doc, path, diffs) {
  let currentInd = 0;
  const parentNode = getNode(path, doc);
  if (!parentNode) {
    throw new Error("Failed to find node for path: " + JSON.stringify(path));
  }
  diffs.forEach((diff) => {
    let op = diff[0];
    switch (op) {
      case DiffOp.NOOP: {
        let count2 = diff[1];
        currentInd += count2;
        break;
      }
      case DiffOp.DEL: {
        diff[1];
        for (let _i = 0; _i < diff[1]; _i++) {
          parentNode.childNodes[currentInd].remove();
        }
        break;
      }
      case DiffOp.INS: {
        let nodes = diff[1];
        let refNode = parentNode.childNodes[currentInd];
        for (let _i = 0; _i < nodes.length; _i++) {
          let newNode = parseHTMLFrag(nodes[_i], doc);
          parentNode.insertBefore(newNode, refNode);
        }
        currentInd += nodes.length;
        break;
      }
      default:
        throw new Error();
    }
  });
}
class WebrtcClient extends EventEmitter {
  constructor(peerId, frame, rtcConfig) {
    super();
    this._rtcEvents = [];
    this.rtcConfig = {
      "iceServers": [{
        "urls": "stun:stun.l.google.com:19302"
      }],
      "sdpSemantics": "unified-plan"
    };
    this.peerId = peerId;
    this.frame = frame;
    this.controllers = /* @__PURE__ */ new Map();
    if (rtcConfig)
      this.rtcConfig = rtcConfig;
  }
  getId() {
    return this.peerId;
  }
  addPeer() {
    this.peer = new RTCPeerConnection(this.rtcConfig);
    this.peer.ontrack = (event) => {
      const controllers = this.controllers.get(event.streams[0].id);
      if (!controllers.isTrackEmpty()) {
        controllers.initializeTrack(event);
      } else {
        controllers.appendTrack(event);
      }
    };
    this.peer.oniceconnectionstatechange = () => {
      if (this.peer.iceConnectionState === "disconnected") {
        this.removePeer();
      }
    };
    this.peer.onnegotiationneeded = async () => {
    };
    this.trigger(SignalEvent.ADD_PEER, {
      id: this.peerId,
      initiator: false,
      frameId: this.frame.store.id
    });
  }
  removePeer() {
    this.peer.close();
  }
  clientCandidate(ev) {
    if (ev.candidate) {
      this.trigger(SignalEvent.CLIENT_CANDIDATE, {
        id: this.peerId,
        initiator: false,
        candidate: ev.candidate,
        frameId: this.frame.store.id
      });
    }
  }
  clientDescription(sdp) {
    this.trigger(SignalEvent.CLIENT_DESCRIPTION, {
      id: this.peerId,
      initiator: false,
      sdp,
      frameId: this.frame.store.id
    });
  }
  async serverCandidate(candidate) {
    if (candidate) {
      await this.peer.addIceCandidate(candidate);
      this.peer.onicecandidate = this.clientCandidate.bind(this);
    }
  }
  async serverDescription(sdp) {
    if (sdp) {
      await this.peer.setRemoteDescription(sdp);
      const answer = await this.peer.createAnswer();
      await this.peer.setLocalDescription(answer);
      this.clientDescription(answer);
    }
  }
  mapElementWithStream(event) {
    try {
      let element2 = getNode(event.path, this.frame.getDoc());
      if (event.mappingType === StreamTypes.CANVAS) {
        const canvasController = new CanvasController(event.mappedId, this.frame, element2);
        this.controllers.set(event.mappedId, canvasController);
      } else if (event.mappingType === StreamTypes.VIDEO) {
        const videoController = new VideoController(event.mappedId, this.frame, element2);
        this.controllers.set(event.mappedId, videoController);
      } else if (event.mappingType === StreamTypes.AUDIO) {
        const audioController = new AudioController(event.mappedId, this.frame, element2);
        this.controllers.set(event.mappedId, audioController);
      }
    } catch (e) {
      console.error("stream element not found ", e);
    }
  }
  trigger(name, params2) {
    this.frame.triggerSignallingServer(name, params2);
  }
  async onWEBRTCEvent(peerId, event) {
    if (peerId !== this.peerId)
      return;
    if (event.initiator) {
      switch (event.name) {
        case SignalEvent.SERVER_CANDIDATE: {
          await this.serverCandidate(event.candidate);
          break;
        }
        case SignalEvent.SERVER_DESCRIPTION: {
          await this.serverDescription(event.sdp);
          break;
        }
        case SignalEvent.MAP_ELEMENT: {
          this.mapElementWithStream(event);
          break;
        }
      }
    }
  }
}
class StreamController {
  constructor(frame) {
    this.frame = frame;
    this.istrackInitialized = false;
  }
}
class VideoController extends StreamController {
  constructor(streamId, frame, element2) {
    super(frame);
    this.streamId = streamId;
    this.video = element2;
  }
  getController(id2) {
    return this;
  }
  isTrackEmpty() {
    return this.istrackInitialized;
  }
  initializeTrack(event) {
    this.video.srcObject = event.streams[0];
    this.video.addEventListener("loadeddata", () => {
      if (this.video.readyState == 4) {
        this.video.muted = true;
        this.video.autoplay = true;
        this.video.play();
      }
    });
    this.video.addEventListener("playing", (ev) => {
      this.video.muted = false;
    });
    this.video.onerror = (e) => {
      console.error("error ", e);
    };
    this.istrackInitialized = true;
  }
  appendTrack(event) {
    if (event.track.kind === "audio") {
      this.video.srcObject.addTrack(event.track);
      this.video.srcObject.getAudioTracks().forEach((audioTrack) => {
        if (audioTrack.id !== event.track.id) {
          this.video.srcObject.removeTrack(audioTrack);
        }
      });
    } else {
      this.video.srcObject.addTrack(event.track);
      this.video.srcObject.getVideoTracks().forEach((videoTrack) => {
        if (videoTrack.id !== event.track.id)
          this.video.srcObject.removeTrack(videoTrack);
      });
    }
  }
}
class CanvasController extends StreamController {
  constructor(streamId, frame, element2) {
    super(frame);
    this.streamId = streamId;
    this.element = element2;
    this.video = this._getCanvasVideo(this.element);
  }
  getController(id2) {
    return this;
  }
  isTrackEmpty() {
    return this.istrackInitialized;
  }
  initializeTrack(event) {
    this.video.srcObject = event.streams[0];
    this.video.addEventListener("loadeddata", () => {
      if (this.video.readyState == 4) {
        this.video.muted = true;
        this.video.autoplay = true;
        this.video.play();
      }
    });
    this.video.onerror = (e) => {
      console.error("error ", e);
    };
    this.istrackInitialized = true;
  }
  appendTrack(event) {
    if (event.track.kind === "audio") {
      this.video.srcObject.addTrack(event.track);
      this.video.srcObject.getAudioTracks().forEach((audioTrack) => {
        if (audioTrack.id !== event.track.id) {
          this.video.srcObject.removeTrack(audioTrack);
        }
      });
    } else {
      this.video.srcObject.addTrack(event.track);
      this.video.srcObject.getVideoTracks().forEach((videoTrack) => {
        if (videoTrack.id !== event.track.id)
          this.video.srcObject.removeTrack(videoTrack);
      });
    }
  }
  _getCanvasVideo(canvas) {
    if (canvas) {
      return this._createVideoElement(canvas);
    }
    return;
  }
  _createVideoElement(canvas) {
    const video = document.createElement("video");
    canvas.classList.forEach((value) => video.classList.add(value));
    video.setAttribute("hidden", "true");
    video.setAttribute("loop", "true");
    this.frame.elMeta.appendChild(video);
    video.addEventListener("play", () => {
      const context = canvas.getContext("2d");
      requestAnimationFrame((time) => {
        this._runVideoInCanvas(context, video);
      });
    });
    return video;
  }
  _runVideoInCanvas(context, video) {
    if (video.paused || video.ended) {
      return;
    }
    this._computeFrame(context, video);
    requestAnimationFrame((time) => {
      this._runVideoInCanvas(context, video);
    });
  }
  _computeFrame(context, video) {
    const width = context.canvas.width;
    const height = context.canvas.height;
    context.drawImage(video, 0, 0, width, height);
    return;
  }
}
class AudioController extends StreamController {
  constructor(streamId, frame, element2) {
    super(frame);
    this.streamId = streamId;
    this.audio = element2;
  }
  getController(id2) {
    return this;
  }
  isTrackEmpty() {
    return this.istrackInitialized;
  }
  initializeTrack(event) {
    this.audio.srcObject = event.streams[0];
    this.audio.addEventListener("loadeddata", () => {
      if (this.audio.readyState == 4) {
        this.audio.autoplay = true;
      }
    });
    this.audio.addEventListener("playing", (ev) => {
      this.audio.muted = false;
    });
    this.audio.onerror = (e) => {
      console.error("error ", e);
    };
    this.istrackInitialized = true;
  }
  appendTrack(event) {
    if (event.track.kind === "audio") {
      this.audio.srcObject.addTrack(event.track);
      this.audio.srcObject.getAudioTracks().forEach((audioTrack) => {
        if (audioTrack.id !== event.track.id) {
          this.audio.srcObject.removeTrack(audioTrack);
        }
      });
    } else {
      this.audio.srcObject.addTrack(event.track);
      this.audio.srcObject.getVideoTracks().forEach((videoTrack) => {
        if (videoTrack.id !== event.track.id)
          this.audio.srcObject.removeTrack(videoTrack);
      });
    }
  }
}
var FrameLoadState;
(function(FrameLoadState2) {
  FrameLoadState2[FrameLoadState2["INIT"] = 0] = "INIT";
  FrameLoadState2[FrameLoadState2["LOADING"] = 1] = "LOADING";
  FrameLoadState2[FrameLoadState2["LOADED"] = 2] = "LOADED";
  FrameLoadState2[FrameLoadState2["LOADED_DOCTYPE"] = 3] = "LOADED_DOCTYPE";
  FrameLoadState2[FrameLoadState2["LOADED_DOC"] = 4] = "LOADED_DOC";
})(FrameLoadState || (FrameLoadState = {}));
const MaxReportableErrors = 50;
class FrameView extends EventEmitter {
  constructor(pageView, store2) {
    super();
    this._altDown = null;
    this._localFrameLoadState = FrameLoadState.INIT;
    this._events = [];
    this._streamEvents = [];
    this._data = /* @__PURE__ */ new Map();
    this._scrollsSent = /* @__PURE__ */ new Set();
    this._scrollsReceived = /* @__PURE__ */ new Set();
    this._listenersActive = false;
    this.dispatchEventScroll = async (e) => {
      let el;
      let target = e.target;
      if (target.nodeType == document.DOCUMENT_NODE) {
        el = target.scrollingElement;
      } else {
        el = target;
      }
      await this._dispatchEventScroll(el);
    };
    this.pageView = pageView;
    this.store = store2;
    this.onFrameLoad = this.onFrameLoad.bind(this);
    this.elMeta = this.createMetaElement();
    this.streamMap = /* @__PURE__ */ new Map();
    this.appliedDOMEvents = new AppliedDOMStreamEvents(15);
    this._maxErrors = MaxReportableErrors;
    this._listeners = {
      blur: (e) => this.onBlur(e),
      mousedown: this.dispatchEvent("mousedown", "button"),
      mouseup: this.dispatchEvent("mouseup", "button"),
      mousemove: (e) => this.dispatchEventMousemove(e),
      keydown: this.dispatchEvent("keydown", "code", "keyCode"),
      keyup: this.dispatchEvent("keyup", "code", "keyCode"),
      wheel: (e) => this.dispatchEventWheel(e),
      change: (e) => this.dispatchEventChange(e),
      input: (e) => this.dispatchEventInput(e),
      click: (e) => {
        e.preventDefault();
        e.stopPropagation();
      }
    };
  }
  onBlur(e) {
    if (!!this._altDown) {
      this.trigger("keyup", {
        code: this._altDown,
        keyCode: 18
      }, this.getDoc().documentElement);
      this._altDown = null;
    }
  }
  addDocListeners() {
    const doc = this.getDoc();
    if (!doc) {
      console.error("FIXME trying to add listener for null document");
      return;
    }
    for (let name in this._listeners) {
      doc.addEventListener(name, this._listeners[name], true);
    }
    this._listenersActive = true;
  }
  appendHost() {
    this.getDoc().documentElement.appendChild(this.elMeta);
  }
  removeHost() {
    this.getDoc().documentElement.removeChild(this.elMeta);
  }
  createMetaElement() {
    if (!customElements.get("bbx-d")) {
      customElements.define("bbx-d", class extends HTMLElement {
        constructor() {
          super();
          this.attachShadow({ mode: "open" });
        }
      });
    } else {
      console.warn("a copy of @bbx/client has already been loaded; loading different versions can result in conflicts");
    }
    const elMeta = document.createElement("bbx-d");
    return elMeta;
  }
  destroy() {
    if (this._localFrameLoadState == FrameLoadState.LOADING) {
      this.removeDocListners();
    }
    this.elMeta.remove();
    this.emit("destroy");
    this.reset();
  }
  _dispatchEventMousemove(el, x, y) {
    if (el != this._currentMouseTarget) {
      this.dispatchEventMouseover(el);
    }
    const offset = this.getFrameOffset();
    this.trigger("mousemove", {
      path: findPath(el),
      clientX: x + offset[0],
      clientY: y + offset[1],
      frameId: this.store.id
    }, el);
    this._currentMouseTarget = el;
  }
  dispatchEventMousemove(e) {
    this._dispatchEventMousemove(e.target, e.clientX, e.clientY);
  }
  dispatchEventMousemove2(selector2, x, y) {
    let doc = this.getDoc();
    let el = doc.querySelector(selector2);
    this._dispatchEventMousemove(el, x, y);
  }
  getClientR(el) {
    if (el.nodeType != document.ELEMENT_NODE) {
      return null;
    }
    let bcr = el.getBoundingClientRect();
    let offset = this.frameOffSet(this.elFrame, this.store.parentId);
    return {
      top: bcr.top + offset.top,
      left: bcr.left + offset.left,
      bottom: bcr.bottom + offset.top,
      right: bcr.right + offset.left
    };
  }
  frameOffSet(el, parentId) {
    let mainFrameOffset = {
      top: 0,
      left: 0
    };
    let offset = this.pageView.elMainFrame == el ? mainFrameOffset : el.getBoundingClientRect();
    if (!parentId) {
      return offset;
    }
    let parentView = this.pageView.getFrame(parentId);
    let parentFrame = parentView.elFrame;
    parentId = parentView.store.parentId;
    return this.addRect(offset, this.frameOffSet(parentFrame, parentId));
  }
  addRect(a, b) {
    return {
      left: a.left + b.left,
      top: a.top + b.top
    };
  }
  dispatchEventMouseover(el) {
    this.trigger("syncsize", {
      path: findPath(el),
      rect: this.getClientR(el),
      frameId: this.store.id
    }, el);
  }
  dispatchEventChange(e) {
    let path;
    let value;
    let el = e.target;
    let name = "change";
    if (el.tagName == "INPUT") {
      let inputTarget = el;
      if (inputTarget.type == "date" || inputTarget.type == "text" || inputTarget.type == "password" || inputTarget.type == "email") {
        path = findPath(inputTarget);
        value = inputTarget.value;
      }
    } else if (el.tagName == "SELECT") {
      let selectTarget = el;
      path = findPath(selectTarget);
      value = selectTarget.value;
      name = "select";
    }
    this.trigger(name, {
      path,
      value,
      frameId: this.store.id
    }, el);
  }
  dispatchEventChange2(selector2, value) {
    let doc = this.getDoc();
    let el = doc.querySelector(selector2);
    this.trigger(el.tagName == "SELECT" ? "select" : "change", {
      path: findPath(el),
      value,
      frameId: this.store.id
    }, el);
  }
  dispatchEventInput(e) {
    let path;
    let value;
    let target = e.target;
    if (target.tagName == "INPUT") {
      path = findPath(target);
      value = target.value;
    }
    this.trigger("input", {
      path,
      value,
      frameId: this.store.id
    }, target);
  }
  async _dispatchEventScroll(el) {
    let event = {
      path: findPath(el),
      top: el.scrollTop,
      left: el.scrollLeft,
      frameId: this.store.id
    };
    const scrollEventStr = `${event.left}:${event.top}`;
    if (!this._scrollsReceived.has(scrollEventStr)) {
      let res2 = await this.trigger("scroll", event, el);
      if (!res2.noop) {
        this._scrollsSent.add(`${res2.scrollLeft}:${res2.scrollTop}`);
      }
    } else {
      this._scrollsReceived.delete(scrollEventStr);
    }
  }
  dispatchEventScroll2(selector2, left, top) {
    let el = this.getDoc().querySelector(selector2);
    el.scrollTo(left, top);
    this._dispatchEventScroll(el);
  }
  dispatchEventWheel(e) {
    let scrollEvent = e;
    let target = e.target;
    const offset = this.getFrameOffset();
    if (target.documentElement) {
      target = target.scrollingElement;
    }
    this.trigger("wheel", {
      deltaX: scrollEvent.deltaX,
      deltaY: scrollEvent.deltaY,
      path: findPath(target),
      x: scrollEvent.x + offset[0],
      y: scrollEvent.y + offset[1],
      frameId: this.store.id
    }, target);
  }
  dispatchEvent(name, ...keys) {
    if (keys.length == 0)
      console.log(name);
    return (e) => {
      if (name === "mousedown") {
        this.getDoc().addEventListener("scroll", this.dispatchEventScroll);
      } else if (name === "mouseup") {
        setTimeout(() => this.getDoc().removeEventListener("scroll", this.dispatchEventScroll), 200);
      }
      let target = e.target;
      if (target.tagName !== "SELECT" && name != "wheel") {
        e.preventDefault();
        e.stopPropagation();
      }
      let params2 = {};
      keys.forEach((key) => params2[key] = e[key]);
      params2.frameId = this.store.id;
      if (name == "keydown") {
        if (params2.code == "AltLeft" || params2.code == "AltRight") {
          this._altDown = params2.code;
        }
      }
      if (!((name == "keyup" || name == "keydown") && !params2.keyCode)) {
        this.trigger(name, params2, target);
      } else {
        console.error("Chrome bug!");
      }
    };
  }
  getDoc() {
    return this.elFrame.contentDocument;
  }
  getMetaEl() {
    return this.elMeta;
  }
  getFrameOffset() {
    return this.pageView.getOffset(this.elFrame);
  }
  getNode(path) {
    return getNode(path, this.getDoc());
  }
  getState() {
    return this._localFrameLoadState;
  }
  isDocReady() {
    return this.getState() == FrameLoadState.LOADED_DOC;
  }
  on_change_attributes({ path, patch: patch2 }) {
    let el = getNode(path, this.getDoc());
    if (!patch2.ns) {
      if (patch2.value === null) {
        el.removeAttribute(patch2.name);
      } else {
        el.setAttribute(patch2.name, patch2.value);
      }
    } else {
      if (patch2.value === null) {
        el.removeAttributeNS(patch2.ns, patch2.name);
      } else {
        el.setAttributeNS(patch2.ns, patch2.name, patch2.value);
      }
    }
  }
  on_change_childlist({ path, patches }) {
    const canAffectHost = path.length == 1;
    canAffectHost && this.removeHost();
    try {
      applyPatch(this.getDoc(), path, patches);
    } finally {
      canAffectHost && this.appendHost();
    }
  }
  on_change_checked({ path, checked }) {
    let input = getNode(path, this.getDoc());
    input.checked = checked;
  }
  on_change_value({ path, value }) {
    let dateInput = getNode(path, this.getDoc());
    dateInput.value = value;
  }
  on_change_text({ path, patch: patch2 }) {
    let node2 = getNode(path, this.getDoc());
    node2.nodeValue = patch2;
  }
  on_bbx_debug({ value }) {
    console.log("ignored on_bbx_debug");
  }
  on_bbx_debug_default({ value }) {
    console.log("on_bbx_debug", new Date(), "start comparing HTML", this.store.id);
    let nodeFromServer = parseHTML(value);
    if (nodeFromServer.nodeType === Node.ELEMENT_NODE) {
      let elementFromServer = nodeFromServer;
      let elementFromClient = this.getDoc().documentElement.cloneNode(true);
      let styleElements = elementFromClient.querySelectorAll("style");
      for (let i2 = 0; i2 < styleElements.length; i2++) {
        styleElements[i2].textContent = "";
      }
      let metaElements = elementFromClient.querySelectorAll("meta");
      for (let i2 = 0; i2 < metaElements.length; i2++) {
        metaElements[i2].outerHTML = "<meta/>";
      }
      let bbxElements = elementFromClient.querySelectorAll("bbx-d");
      for (let i2 = 0; i2 < bbxElements.length; i2++) {
        bbxElements[i2].remove();
      }
      styleElements = elementFromServer.querySelectorAll("style");
      for (let i2 = 0; i2 < styleElements.length; i2++) {
        styleElements[i2].textContent = "";
      }
      metaElements = elementFromServer.querySelectorAll("meta");
      for (let i2 = 0; i2 < metaElements.length; i2++) {
        metaElements[i2].outerHTML = "<meta/>";
      }
      const isEqual = elementFromServer.isEqualNode(elementFromClient);
      if (!isEqual) {
        console.log("on_bbx_debug", new Date(), "end comparing HTML", this.store.id, "isEqual", isEqual, elementFromClient.outerHTML === elementFromServer.outerHTML);
        this.pageView.browserView.manager.emit("frame_content_mismatch", elementFromClient, elementFromServer);
      }
    } else {
      console.error("on_bbx_debug", "Invalid Node sent from server");
    }
  }
  on_document({ value }) {
    this.setState(FrameLoadState.LOADED_DOC);
    const doc = this.getDoc();
    doc.documentElement.replaceWith(parseHTML(value, doc));
    this.appendHost();
    this._streamEvents.forEach(async (stream, index2) => {
      await this.addPeerToFrame(stream);
    });
    this._streamEvents = [];
    this.emit("document_ready", this);
    this.on_bbx_debug = this.on_bbx_debug_default;
  }
  on_document_start({ doctype }) {
    this._maxErrors = MaxReportableErrors;
    this.setState(FrameLoadState.LOADING);
    let html2 = (doctype ? `<!doctype ${doctype}>` : "") + "<html><body></body></html>";
    this.elFrame.setAttribute("srcdoc", html2);
    this.appendHost();
  }
  on_shadow_root({ path, value }) {
    let el = getNode(path, this.getDoc());
    if (!el.shadowRoot) {
      el.attachShadow({ mode: "open" });
    }
  }
  on_text_patch({ path, diff }) {
    let el = getNode(path, this.getDoc());
    let oldStr = el.nodeValue;
    let newStr = this.apply_text_patch(oldStr, diff);
    el.nodeValue = newStr;
  }
  apply_text_patch(oldStr, diff) {
    let result = "";
    let currentInd = 0;
    diff.forEach((d) => {
      switch (d[0]) {
        case DiffOp.NOOP:
          let subStr = oldStr.slice(currentInd, currentInd + d[1]);
          result = result + subStr;
          currentInd = currentInd + d[1];
          break;
        case DiffOp.DEL:
          currentInd = currentInd + d[1];
          break;
        case DiffOp.INS:
          result = result + d[1];
          break;
      }
    });
    return result;
  }
  on_focus({ path }) {
    let el = getNode(path, this.getDoc());
    el.focus();
  }
  on_frame_src({ path, childFrameId }) {
    let childFrameView = this.pageView.getFrame(childFrameId);
    let iframe = getNode(path, this.getDoc());
    if (!iframe || iframe.nodeName != "IFRAME") {
      console.error("on_frame_src", path, childFrameId, iframe);
      throw new Error("on_frame_src: mismatched path to iframe");
    }
    if (childFrameView)
      childFrameView.setIFrame(iframe);
  }
  on_input({ path, value }) {
    let el = getNode(path, this.getDoc());
    el.value = value;
  }
  on_navigated({ url }) {
    this.url = url;
    this.emit("navigated");
  }
  on_select_input({ path, start, end }) {
    let el = getNode(path, this.getDoc());
    if (!el.type || el.type == "text" || el.type == "search" || el.type == "url" || el.type == "tel" || el.type == "password") {
      el.setSelectionRange(start, end);
    }
  }
  on_select_range({ ranges }) {
    const doc = this.getDoc();
    const s = doc.getSelection();
    s.empty();
    ranges.forEach((rangeObj) => {
      let range = doc.createRange();
      let { start, end } = rangeObj;
      range.setStart(getNode(start[0], doc), start[1]);
      range.setEnd(getNode(end[0], doc), end[1]);
      s.addRange(range);
    });
  }
  on_scroll(event) {
    let path = event.path;
    let el = getNode(path, this.getDoc());
    this.on_scroll_deb(el, event);
  }
  on_scroll_deb(elScroll, event) {
    let left = event.left;
    let top = event.top;
    const scrollEventStr = `${left}:${top}`;
    if (!this._scrollsSent.has(scrollEventStr)) {
      let oldCords = { scrollTop: elScroll.scrollTop, scrollLeft: elScroll.scrollLeft };
      elScroll.scrollTo(left, top);
      let newCords = { scrollTop: elScroll.scrollTop, scrollLeft: elScroll.scrollLeft };
      if (this._listenersActive && (oldCords.scrollTop != newCords.scrollTop || oldCords.scrollLeft != newCords.scrollLeft)) {
        this._scrollsReceived.add(`${elScroll.scrollLeft}:${elScroll.scrollTop}`);
      }
    } else {
      this._scrollsSent.delete(scrollEventStr);
    }
  }
  getDebouncedFunction(el, name, func, wait2) {
    let fns = el.__fns || (el.__fns = {});
    let fn = fns[name];
    if (!fn) {
      fn = debounce$1((event) => func.call(this, el, event), wait2);
      fns[name] = fn;
    }
    return fn;
  }
  onDOMEvent(domStreamEvent) {
    if (domStreamEvent.name != "navigated" && !this._isReadyForEvents(domStreamEvent.name)) {
      this._events.push({ ...domStreamEvent });
      return;
    }
    domStreamEvent.name = domStreamEvent.name.replace(/:/g, "_");
    let method = `on_${domStreamEvent.name}`;
    let startTime = new Date();
    if (this[method]) {
      try {
        this[method](domStreamEvent);
      } catch (e) {
        console.warn(`error while processing the DOMEvent ${domStreamEvent.name}`, this.store.id, domStreamEvent, e);
        const domEventError = new DOMEventError(e, method, this.url, this.store.isMain());
        domEventError.setPreviousEvents(this.appliedDOMEvents);
        this.sendError(domEventError);
        this.appliedDOMEvents.push(domStreamEvent, startTime, e);
      }
      this.appliedDOMEvents.push(domStreamEvent, startTime);
      this.emit(domStreamEvent.name, domStreamEvent, this);
      this.emit("bbx", domStreamEvent.name, domStreamEvent, this);
    } else {
      console.warn("TODO: unhandled event:", this.store.id, domStreamEvent.name, domStreamEvent);
    }
  }
  async onWEBRTCEvent(peerId, event) {
    if (event.name === SignalEvent.STREAM_VIDEO) {
      await this.addPeerToFrame(event);
      return;
    }
    await this.webrtcClient.onWEBRTCEvent(peerId, event);
  }
  async addPeerToFrame(event) {
    if (event.name === SignalEvent.STREAM_VIDEO) {
      if (this.webrtcClient) {
        this.webrtcClient.removePeer();
        this.webrtcClient = void 0;
      }
      if (this._isReadyForStreaming()) {
        this.webrtcClient = new WebrtcClient(Math.random().toString(36), this);
        this.webrtcClient.addPeer();
      } else {
        this._streamEvents.push(event);
      }
    }
  }
  _isReadyForEvents(name) {
    if (name == "document_start") {
      return this._localFrameLoadState >= FrameLoadState.LOADED;
    } else {
      return this._localFrameLoadState >= FrameLoadState.LOADED_DOCTYPE;
    }
  }
  _isReadyForStreaming() {
    return this._localFrameLoadState >= FrameLoadState.LOADED_DOC;
  }
  onFrameLoad() {
    this.setState(FrameLoadState.LOADED);
    this.elFrame.removeEventListener("load", this.onFrameLoad);
    this.elFrame.addEventListener("load", (e) => this.onFrameLoadDoctype());
    this.appendHost();
    let eDocStart = this._events.find((e) => e.name == "document_start");
    if (eDocStart) {
      let index2 = this._events.indexOf(eDocStart);
      this._events = this._events.slice(index2 + 1);
      this.onDOMEvent(eDocStart);
    }
  }
  onFrameLoadDoctype() {
    this.setState(FrameLoadState.LOADED_DOCTYPE);
    let pendingEvents = this._events;
    this._events = [];
    let eDoc = pendingEvents.find((e) => e.name == "document");
    if (eDoc) {
      let index2 = pendingEvents.indexOf(eDoc);
      pendingEvents = pendingEvents.slice(index2);
    }
    pendingEvents.forEach((e) => this.onDOMEvent(e));
    this.removeDocListners();
    !this._paused && this.addDocListeners();
    this.appendHost();
    this.emit("ready", this);
  }
  pause() {
    this._paused = true;
    if (this._localFrameLoadState >= FrameLoadState.LOADED_DOCTYPE) {
      this.removeDocListners();
    }
  }
  resume() {
    this._paused = false;
    if (this._localFrameLoadState >= FrameLoadState.LOADED_DOCTYPE) {
      this.addDocListeners();
    }
  }
  removeDocListners() {
    const doc = this.getDoc();
    if (!doc) {
      console.error("FIXME trying to remove listener for null document");
      return;
    }
    for (let name in this._listeners) {
      doc.removeEventListener(name, this._listeners[name], true);
    }
    this._listenersActive = false;
  }
  setState(state) {
    this._localFrameLoadState = state;
  }
  setIFrame(iframe) {
    this.elFrame = iframe;
    if (iframe.contentDocument) {
      this.onFrameLoad();
    } else {
      this.elFrame.addEventListener("load", this.onFrameLoad);
    }
  }
  trigger(name, params2, target) {
    let res2 = this.pageView.store.trigger(name, params2);
    this.emit("trigger", name, params2, target, this);
    return res2;
  }
  triggerSignallingServer(name, params2) {
    this.pageView.store.browser.call("signalEvent", this.pageView.store.id, name, params2);
  }
  delData(key) {
    return this._data.delete(key);
  }
  getData(key) {
    return this._data.get(key);
  }
  setData(key, value) {
    return this._data.set(key, value);
  }
  sendError(e) {
    this._maxErrors--;
    if (this._maxErrors > 0) {
      this.pageView.sendError(e);
    } else {
      console.warn("error limit exceeded, max limit is configured to:", MaxReportableErrors, e);
    }
  }
}
class PageView extends EventEmitter {
  constructor(store2, browserView) {
    super();
    this.frameViews = /* @__PURE__ */ new Map();
    this.overlays = [];
    this.store = store2;
    this.browserView = browserView;
    this.onFrameAdded = this.onFrameAdded.bind(this);
    this.onFrameDetached = this.onFrameDetached.bind(this);
    this.addListeners();
    this.mainFrameView = this.onFrameAdded(this.store.mainFrame);
    this.store.frames.slice(1).forEach((frame) => this.onFrameAdded(frame));
    this.elMainFrame = document.createElement("iframe");
    this.elMainFrame.setAttribute("frameborder", "0");
    this.mainFrameView.setIFrame(this.elMainFrame);
  }
  addListeners() {
    this.store.on("frameadded", this.onFrameAdded);
    this.store.on("framedetached", this.onFrameDetached);
  }
  addOverlay(overlay) {
    this.overlays.push(overlay);
    for (let fv of this.frameViews.values()) {
      overlay.onFrameInit(fv);
    }
  }
  removeOverlay(overlay) {
    let index2 = this.overlays.indexOf(overlay);
    this.overlays.splice(index2, 1);
    for (let fv of this.frameViews.values()) {
      overlay.onFrameUninit(fv);
    }
  }
  destroy() {
    let fvs = [...this.frameViews.values()];
    for (let fv of fvs) {
      this.onFrameDetached(fv.store);
    }
    this.elMainFrame.remove();
    this.store.off("frameadded", this.onFrameAdded);
    this.store.off("framedetached", this.onFrameDetached);
  }
  getOffset(el) {
    if (el == this.elMainFrame) {
      return [0, 0];
    }
    let rect = el.getBoundingClientRect();
    const offset = [rect.left, rect.top];
    const elWin = el.ownerDocument.defaultView;
    const parentOffset = this.getOffset(elWin.frameElement);
    return [offset[0] + parentOffset[0], offset[1] + parentOffset[1]];
  }
  getFrame(frameId) {
    return this.frameViews.get(frameId);
  }
  onDOMEvent(frameId, event) {
    let frameView = this.getFrame(frameId);
    frameView.onDOMEvent(event);
  }
  async onWEBRTCEvent(frameId, peerId, event) {
    await this.getFrame(frameId).onWEBRTCEvent(peerId, event);
  }
  onFrameAdded(frame) {
    const fv = new FrameView(this, frame);
    this.frameViews.set(frame.id, fv);
    this.overlays.forEach((o) => o.onFrameInit(fv));
    this.emit("frameadded", fv);
    return fv;
  }
  onFrameDetached(frame) {
    let fv = this.frameViews.get(frame.id);
    if (fv) {
      for (let overlay of this.overlays) {
        overlay.onFrameUninit(fv);
      }
      fv.destroy();
      this.frameViews.delete(frame.id);
      this.emit("framedetached", fv);
    }
  }
  pause() {
    for (const fv of this.frameViews.values()) {
      fv.pause();
    }
  }
  resume() {
    for (const fv of this.frameViews.values()) {
      fv.resume();
    }
  }
  render() {
    return this.elMainFrame;
  }
  sendError(e) {
    this.browserView.sendError(e);
  }
}
class BrowserView extends EventEmitter {
  constructor(options) {
    super();
    this.overlays = [];
    this.pageViews = /* @__PURE__ */ new Map();
    Object.assign(this, options);
    this.manager.addDOMStreamListener(this);
    this.manager.addWEBRTCStreamListener(this);
    this.addListeners();
  }
  async addListeners() {
    if (!this.manager.browser) {
      await this.manager.waitForEvent("ready");
    }
    this.store = this.manager.browser;
    this.client = this.manager.apiClient;
    this.store.on("pageadded", (e) => this.onPageAdded(e));
    this.store.on("pagedeleted", (e) => this.onPageDeleted(e));
    this.store.pages.forEach((page) => this.onPageAdded(page));
  }
  addPageOverlay(overlay) {
    this.overlays.push(overlay);
    for (let pv of this.pageViews.values()) {
      pv.addOverlay(overlay);
    }
  }
  getPage(id2) {
    if (typeof id2 == "number") {
      let size = this.pageViews.size;
      let index2 = id2;
      if (index2 < 0) {
        index2 += size;
      }
      if (index2 >= size) {
        throw new Error("Page index out of bounds: " + index2);
      }
      let pages = this.pageViews.values();
      let i2 = 0;
      for (let page of pages) {
        if (i2 == index2) {
          return page;
        }
        i2 += 1;
      }
      throw new Error("(unreachable code) Page not found: " + id2);
    } else {
      return this.pageViews.get(id2);
    }
  }
  onDOMEvent(pageId, frameId, event) {
    this.getPage(pageId).onDOMEvent(frameId, event);
  }
  async onWEBRTCEvent(pageId, frameId, peerId, event) {
    await this.getPage(pageId).onWEBRTCEvent(frameId, peerId, event);
  }
  onPageAdded(page) {
    let pageView = new PageView(page, this);
    this.pageViews.set(page.id, pageView);
    this.overlays.forEach((o) => pageView.addOverlay(o));
    let el = pageView.render();
    this.setPageElStyle(el);
    this.container.appendChild(el);
    this.emit("pageadded", pageView);
  }
  onPageDeleted(page) {
    let pageView = this.getPage(page.id);
    pageView.destroy();
    this.pageViews.delete(page.id);
    this.emit("pagedeleted", pageView);
  }
  setPageElStyle(el) {
    Object.assign(el.style, {
      position: "absolute",
      height: "100%",
      width: "100%",
      backgroundColor: "#fff"
    });
  }
  getNode(pageId, frameId, path) {
    return this.getPage(pageId).getFrame(frameId).getNode(path);
  }
  async syncSize() {
    let r = this.container.getBoundingClientRect();
    await this.store.call("setViewport", {
      width: Math.trunc(r.width),
      height: Math.trunc(r.height)
    });
  }
  sendError(e) {
    this.client.sendError(e);
  }
}
async function createView({ key, host, basePath, container }) {
  let apiClient = connect({
    key,
    host,
    basePath,
    features: [Feature.command, Feature.state, Feature.stream_dom, Feature.stream_video]
  });
  let manager = new StoreManager(apiClient);
  await manager.waitForEvent("ready");
  await manager.browser.call("setContentConfig", "stream_dom", true);
  let view = new BrowserView({
    manager,
    container
  });
  view.syncSize();
  return view;
}
class BrowserListener extends EventEmitter {
  constructor(view) {
    super();
    this.view = view;
    this.mgr = view.manager;
    [
      "onAction",
      "onEffect",
      "onFrameAdded",
      "onFrameDetached",
      "onPageAdded",
      "onPageDeleted"
    ].forEach((name) => this[name] = this[name].bind(this));
  }
  onFrameAdded(fv) {
    fv.on("bbx", this.onEffect);
    fv.on("trigger", this.onAction);
  }
  onFrameDetached(fv) {
    fv.off("bbx", this.onEffect);
    fv.off("trigger", this.onAction);
  }
  onPageAdded(pv) {
    pv.on("frameadded", this.onFrameAdded);
    pv.on("framedetached", this.onFrameDetached);
    pv.frameViews.forEach(this.onFrameAdded);
  }
  onPageDeleted(pv) {
    pv.off("frameadded", this.onFrameAdded);
    pv.off("framedetached", this.onFrameDetached);
    pv.frameViews.forEach(this.onFrameDetached);
  }
  start() {
    this.view.on("pageadded", this.onPageAdded);
    this.view.on("pagedeleted", this.onPageDeleted);
    this.view.pageViews.forEach(this.onPageAdded);
  }
  stop() {
    this.view.off("pageadded", this.onPageAdded);
    this.view.off("pagedeleted", this.onPageDeleted);
    this.view.pageViews.forEach(this.onPageDeleted);
  }
}
let timeLimit = 30 * 1e3;
const stepTypes = [
  "CLICK",
  "DRAG",
  "FOCUS",
  "KEYPRESS",
  "MOUSEMOVE",
  "OPEN",
  "SCROLL",
  "SELECT",
  "TYPE",
  "WAIT_DOC",
  "WAIT_FOR_DURATION",
  "WAIT_FOR_ELEMENT"
];
function wait$1(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
class BaseStep {
  constructor(type, frame = 0, ts = Date.now(), isManuallyCreated = false) {
    this._data = {};
    this.type = type;
    this.frame = frame;
    this.ts = ts;
    this.isManuallyCreated = isManuallyCreated;
  }
  static createDefault() {
    throw new Error("method not implemented");
  }
  clone() {
    let newInstance = this.constructor.createDefault();
    for (let property in this._data) {
      newInstance.set(property, this._data[property].value);
    }
    return newInstance;
  }
  get(name) {
    if (!this._data.hasOwnProperty(name)) {
      throw new Error(`property not found: ${name}`);
    } else {
      return this._data[name];
    }
  }
  get data() {
    throw new Error(`get data() method not implemented for type ${this.type}`);
  }
  set(name, value) {
    if (!this._data.hasOwnProperty(name)) {
      throw new Error(`property not found: ${name}`);
    } else {
      let propType = this._data[name].type;
      if (TypeChecker.isOfType(propType, value)) {
        this._data[name].value = value;
      } else {
        throw new Error(`value is not valid for ${name}`);
      }
    }
  }
  is(type) {
    return this.type == type;
  }
  isEffect() {
    return false;
  }
  isKey() {
    return false;
  }
  isMouse() {
    return false;
  }
  get name() {
    return this.type;
  }
  getFrameView(view) {
    let pageView = view.getPage(-1);
    let page = pageView.store;
    let frame = page.frames[this.frame];
    return pageView.getFrame(frame.id);
  }
  toJSON() {
    let { type, data, ts, frame } = this;
    let _data = {};
    for (let propertyName of Object.keys(data)) {
      _data[propertyName] = data[propertyName].value;
    }
    return { type, data: _data, ts, frame };
  }
  async play(_view) {
    throw new Error(`${this.name}.play() not implemented`);
  }
}
class WaitForDuration extends BaseStep {
  constructor(duration, ts = Date.now(), isManuallyCreated = false) {
    super("WAIT_FOR_DURATION", 0, ts, isManuallyCreated);
    this._data = {
      duration: { value: duration, type: "NUMBER" }
    };
  }
  static createDefault() {
    return new WaitForDuration(0, Date.now(), true);
  }
  get data() {
    return this._data;
  }
  get duration() {
    return this._data.duration.value;
  }
  async play(_2) {
    await wait$1(this.duration * 1e3);
  }
}
class WaitForElement extends BaseStep {
  constructor(selector2, frame, ts, isManuallyCreated = false) {
    super("WAIT_FOR_ELEMENT", frame, ts, isManuallyCreated);
    this._data = {
      selector: { value: selector2, type: "SELECTOR" }
    };
  }
  static createDefault() {
    let selector2 = new CSSSelector("body");
    return new WaitForElement(selector2, 0, Date.now(), true);
  }
  get data() {
    return this._data;
  }
  get selector() {
    return this._data.selector.value;
  }
  async play(bv) {
    let frame = this.getFrameView(bv);
    let doc = frame.getDoc();
    let queriedEls = await this.selector.select(doc);
    let timeOut = Date.now() + timeLimit;
    while (queriedEls.length === 0 && timeOut > Date.now()) {
      await wait$1(500);
      queriedEls = await this.selector.select(doc);
    }
    if (queriedEls.length === 0) {
      throw new Error("timed out waiting for selector");
    }
  }
}
class Open extends BaseStep {
  constructor(url, frame, ts, isManuallyCreated = false) {
    super("OPEN", frame, ts, isManuallyCreated);
    this._data = {
      url: { value: url, type: "STRING" }
    };
  }
  static createDefault() {
    return new Open("", 0, Date.now(), true);
  }
  get data() {
    return this._data;
  }
  get url() {
    return this._data.url.value;
  }
  async play(view) {
    let page = view.getPage(-1);
    await page.store.goto(this.url);
  }
}
class Key extends BaseStep {
  isKey() {
    return true;
  }
}
class Mouse extends BaseStep {
  isMouse() {
    return true;
  }
}
class EffectStep extends BaseStep {
  isEffect() {
    return true;
  }
}
class Click extends Mouse {
  constructor(selector2, pos, frame, ts, isManuallyCreated = false) {
    super("CLICK", frame, ts, isManuallyCreated);
    this._data = {
      selector: { value: selector2, type: "SELECTOR" },
      pos: { value: pos, type: "POSITION" }
    };
  }
  static createDefault() {
    let selector2 = new CSSSelector("html");
    return new Click(selector2, { x: 0, y: 0 }, 0, Date.now(), true);
  }
  get data() {
    return this._data;
  }
  get selector() {
    return this._data.selector.value;
  }
  async play(view) {
    let frameView = this.getFrameView(view);
    await frameView.store.call("click", this.selector.value);
  }
}
class Keypress extends Key {
  constructor(code, _keyCode, count2, frame, ts, isManuallyCreated = false) {
    super("KEYPRESS", frame, ts, isManuallyCreated);
    this._data = {
      code: {
        value: code,
        type: "KEYPRESS_OPTION",
        options: ["Enter", "Backspace"]
      },
      count: { value: count2, type: "NUMBER" }
    };
  }
  static createDefault() {
    return new Keypress("Enter", 13, 1, 0, Date.now(), true);
  }
  get data() {
    return this._data;
  }
  get code() {
    return this._data.code.value;
  }
  get count() {
    return this._data.count.value;
  }
  set count(count2) {
    this._data.count.value = count2;
  }
  get repr() {
    return this.code + (this.count > 1 ? " x " + this.count : "");
  }
  async play(view) {
    let page = view.getPage(-1).store;
    let data = {
      code: this.code,
      keyCode: Keypress.keyCodeMap[this.code],
      count: this._data.count.value
    };
    await page.trigger("keypress", data);
  }
}
Keypress.keyCodeMap = {
  "Enter": 13,
  "Backspace": 8
};
class Drag extends Mouse {
  constructor(start, end, frame, ts, isManuallyCreated = false) {
    super("DRAG", frame, ts, isManuallyCreated);
    this._el = null;
    this._data = {
      start: { value: start, type: "TARGET" },
      end: { value: end, type: "TARGET" }
    };
  }
  static createDefault() {
    let start = { selector: new CSSSelector("body"), pos: { x: 0, y: 0 } };
    return new Drag(start, start, 0, Date.now(), true);
  }
  get data() {
    return this._data;
  }
  get start() {
    return this._data.start.value;
  }
  set start(_start) {
    this._data.start.value = _start;
  }
  get end() {
    return this._data.end.value;
  }
  set end(_end) {
    this._data.end.value = _end;
  }
  get el() {
    return this._el;
  }
  set el(el) {
    this._el = el;
  }
  async play(view) {
    let frameView = this.getFrameView(view);
    let page = frameView.pageView.store;
    var { selector: selector2, pos } = this.start;
    frameView.dispatchEventMousemove2(selector2.value, pos.x, pos.y);
    await wait$1(100);
    await page.call("mousedown");
    await wait$1(100);
    if (!this.end) {
      throw new Error("Drag's end point is null");
    }
    var { selector: selector2, pos } = this.end;
    frameView.dispatchEventMousemove2(selector2.value, pos.x, pos.y);
    await wait$1(100);
    await page.call("mouseup");
  }
}
class MouseMove extends Mouse {
  constructor(selector2, pos, frame, ts, isManuallyCreated = false) {
    super("MOUSEMOVE", frame, ts, isManuallyCreated);
    this._data = {
      selector: { value: selector2, type: "SELECTOR" },
      pos: { value: pos, type: "POSITION" }
    };
  }
  static createDefault() {
    let selector2 = new CSSSelector("html");
    let pos = { x: 0, y: 0 };
    return new MouseMove(selector2, pos, 0, Date.now(), true);
  }
  get data() {
    return this._data;
  }
  get selector() {
    return this._data.selector.value;
  }
  set selector(_selector) {
    this._data.selector.value = _selector;
  }
  get pos() {
    return this._data.pos.value;
  }
  set pos(_pos) {
    this._data.pos.value = _pos;
  }
  async play(view) {
    let frameView = this.getFrameView(view);
    frameView.dispatchEventMousemove2((await this.selector).value, this.pos.x, this.pos.y);
  }
}
class Focus extends EffectStep {
  constructor(selector2, frame, ts, isManuallyCreated = false) {
    super("FOCUS", frame, ts, isManuallyCreated);
    this._data = {
      selector: { value: selector2, type: "SELECTOR" }
    };
  }
  static createDefault() {
    let selector2 = new CSSSelector("html");
    return new Focus(selector2, 0, Date.now(), true);
  }
  get data() {
    return this._data;
  }
  get selector() {
    return this._data.selector.value;
  }
  async play(view) {
    let page = view.getPage(-1).store;
    let frame = page.frames[this.frame];
    await frame.call("focus", this.selector.value);
  }
}
class Scroll extends EffectStep {
  constructor(selector2, left, top, frame, ts, isManuallyCreated = false) {
    super("SCROLL", frame, ts, isManuallyCreated);
    this._data = {
      selector: { value: selector2, type: "SELECTOR" },
      left: { value: left, type: "NUMBER" },
      top: { value: top, type: "NUMBER" }
    };
  }
  static createDefault() {
    let selector2 = new CSSSelector("html");
    return new Scroll(selector2, 0, 0, 0, Date.now(), true);
  }
  get data() {
    return this._data;
  }
  get selector() {
    return this._data.selector.value;
  }
  get left() {
    return this._data.left.value;
  }
  set left(_left) {
    this._data.left.value = _left;
  }
  get top() {
    return this._data.top.value;
  }
  set top(_top) {
    this._data.top.value = _top;
  }
  async play(view) {
    let frameView = this.getFrameView(view);
    frameView.dispatchEventScroll2(this.selector.value, this.left, this.top);
  }
}
class WaitForDoc extends EffectStep {
  static createDefault() {
    return new WaitForDoc(0, Date.now(), true);
  }
  constructor(frame, ts, isManuallyCreated = false) {
    super("WAIT_DOC", frame, ts, isManuallyCreated);
  }
  get data() {
    return {};
  }
  async play(view) {
    let frameView = this.getFrameView(view);
    await frameView.waitForEvent("document");
    await wait$1(2e3);
  }
}
class Select extends BaseStep {
  constructor(selector2, value, frame, ts, isManuallyCreated = false) {
    super("SELECT", frame, ts, isManuallyCreated);
    this._el = null;
    this._data = {
      selector: { value: selector2, type: "SELECTOR" },
      value: { value, type: "STRING" }
    };
  }
  static createDefault() {
    let selector2 = new CSSSelector("html");
    return new Select(selector2, "", 0, Date.now(), true);
  }
  get data() {
    return this._data;
  }
  get el() {
    return this._el;
  }
  set el(el) {
    this._el = el;
  }
  get selector() {
    return this._data.selector.value;
  }
  get value() {
    return this._data.value.value;
  }
  async play(view) {
    let frameView = this.getFrameView(view);
    await frameView.store.call("select", this.selector.value, this.value);
  }
}
class Type extends Key {
  constructor(selector2, value, frame, ts, isManuallyCreated = false) {
    super("TYPE", frame, ts, isManuallyCreated);
    this._el = null;
    this._data = {
      selector: { value: selector2, type: "SELECTOR" },
      value: { value, type: "STRING" }
    };
  }
  static createDefault() {
    let selector2 = new CSSSelector("html");
    return new Type(selector2, "", 0, Date.now(), true);
  }
  get data() {
    return this._data;
  }
  get el() {
    return this._el;
  }
  set el(el) {
    this._el = el;
  }
  get selector() {
    return this._data.selector.value;
  }
  get value() {
    return this._data.value.value;
  }
  set value(_value) {
    this._data.value.value = _value;
  }
  async play(view) {
    let frameView = this.getFrameView(view);
    await frameView.store.call("type", this.selector.value, this.value);
  }
}
let stepTypeDict = {
  "CLICK": Click,
  "DRAG": Drag,
  "FOCUS": Focus,
  "KEYPRESS": Keypress,
  "MOUSEMOVE": MouseMove,
  "OPEN": Open,
  "SCROLL": Scroll,
  "SELECT": Select,
  "TYPE": Type,
  "WAIT_DOC": WaitForDoc,
  "WAIT_FOR_DURATION": WaitForDuration,
  "WAIT_FOR_ELEMENT": WaitForElement
};
function toJSON(steps) {
  return steps.map((s) => s.toJSON());
}
function toSteps(steps, selectorParser) {
  return steps.map(({ type, data, frame, ts }) => {
    frame || (frame = 0);
    ts || (ts = 0);
    let step = stepTypeDict[type].createDefault();
    step.frame = frame;
    step.ts = ts;
    for (let propertyName of Object.keys(data)) {
      let value = data[propertyName];
      if (propertyName === "keyCode") {
        continue;
      } else if (!value) {
        continue;
      }
      if (step.data[propertyName].type === "SELECTOR") {
        value = selectorParser(value);
      } else if (step.data[propertyName].type === "POSITION") {
        if (!value.x)
          value.x = 0;
        if (!value.y)
          value.y = 0;
      } else if (step.data[propertyName].type === "TARGET") {
        value.selector = selectorParser(value.selector);
        if (!value.pos.x)
          value.pos.x = 0;
        if (!value.pos.y)
          value.pos.y = 0;
      }
      step.set(propertyName, value);
    }
    return step;
  });
}
async function replay(_view, _steps) {
  throw new Error("TODO: Not implemented");
}
let REPLACE_PATTERNS = [
  [["WAIT_DOC", "WAIT_DOC"], 0],
  [["WAIT_DOC", "FOCUS"], 0],
  [["FOCUS", "CLICK"], 1],
  [["CLICK", "FOCUS"], 0],
  [["DRAG", "FOCUS"], 0],
  [["MOUSEMOVE", "FOCUS"], 1],
  [["MOUSEMOVE", "CLICK"], 1],
  [["MOUSEMOVE", "DRAG"], 1],
  [["MOUSEMOVE", "MOUSEMOVE"], 1],
  [["MOUSEMOVE", "WAIT_DOC"], 1]
];
class Base extends BrowserListener {
  constructor(view, find, initialSteps = []) {
    super(view);
    this.steps = [];
    this.find = find;
    this.steps = [...initialSteps];
  }
  addStep(newStep) {
    this.steps.push(newStep);
    if (this.steps.length > 1) {
      this.removeRedundantSteps();
    }
    this.emit("change");
  }
  deleteStep(step) {
    this.steps.splice(this.steps.indexOf(step), 1);
    this.emit("change");
  }
  getSteps() {
    return [...this.steps];
  }
  getTargetPos(el, { clientX, clientY }) {
    let elRect = el.getBoundingClientRect();
    let x = clientX - elRect.left;
    let y = clientY - elRect.top;
    return { x, y };
  }
  insertStep(newStep, i2) {
    if (i2 >= 0 && i2 <= this.steps.length) {
      this.steps.splice(i2, 0, newStep);
    } else {
      this.steps.push(newStep);
    }
    this.emit("change");
  }
  async onAction(name, params2, target, fv) {
    if (name == "select") {
      let selector3 = await this.find(target);
      this.addStep(new Select(selector3, params2.value, ...stepCtx(fv)));
      return;
    }
    let isKey = name.startsWith("key");
    let isMouse = name.startsWith("mouse");
    if (isKey) {
      let lastEl = this.dirtyEl;
      this.dirtyEl = target;
      let lastAction = this.steps[this.steps.length - 1];
      let { code, keyCode } = params2;
      if (name == "keydown" && (code == "Enter" || code == "Backspace")) {
        if (lastAction instanceof Keypress && lastAction.code == code && lastEl == this.dirtyEl) {
          lastAction.count += 1;
        } else {
          this.addStep(new Keypress(code, keyCode, 1, ...stepCtx(fv)));
        }
      }
      return;
    }
    if (!isMouse) {
      return;
    }
    let selector2 = await this.find(target);
    let pos = this.getTargetPos(target, params2);
    if (this.steps.length == 0) {
      this.addStep(new MouseMove(new CSSSelector("body"), { x: 120, y: 80 }, ...stepCtx(fv)));
    }
    let lastStep = this.steps[this.steps.length - 1];
    let suffix = name.split("mouse")[1];
    switch (suffix) {
      case "move":
        if (lastStep instanceof MouseMove && lastStep.selector.value == selector2.value) {
          lastStep.selector = selector2;
          lastStep.pos = pos;
        } else if (lastStep instanceof Drag) {
          lastStep.end = { selector: selector2, pos };
        } else {
          this.addStep(new MouseMove(selector2, pos, ...stepCtx(fv)));
        }
        break;
      case "down":
        pos = { x: 0, y: 0 };
        let drag = new Drag({ selector: selector2, pos }, { selector: selector2, pos }, ...stepCtx(fv));
        drag.el = target;
        this.addStep(drag);
        break;
      case "up":
        if (lastStep instanceof Drag) {
          if (lastStep.el == target) {
            let { selector: selector3, pos: pos2 } = lastStep.start;
            this.steps[this.steps.length - 1] = new Click(selector3, pos2, ...stepCtx(fv));
          } else {
            lastStep.end = { selector: selector2, pos };
          }
        } else if (lastStep instanceof Select)
          ;
        else {
          console.warn("invalid state error", { name, params: params2, lastStep, steps: [...this.steps] });
        }
        break;
      default:
        console.error("Invalid mouse action", { name, params: params2 });
        throw new Error("Invalid mouse action");
    }
    this.emit("change");
  }
  async onEffect(name, event, fv) {
    switch (name) {
      case "navigated":
        if (fv.store.isMain())
          ;
        break;
      case "document":
        if (fv.store.isMain()) {
          this.addStep(new WaitForDoc(...stepCtx(fv)));
        }
        break;
      case "focus": {
        let el = fv.getNode(event.path);
        this.addStep(new Focus(await this.find(el), ...stepCtx(fv)));
        break;
      }
      case "input": {
        let el = fv.getNode(event.path);
        if (el == this.dirtyEl) {
          let lastStep = this.steps[this.steps.length - 1];
          if (lastStep instanceof Type && lastStep.el === el) {
            lastStep.value = event.value;
          } else {
            let selector2 = await this.find(el);
            let type = new Type(selector2, event.value, ...stepCtx(fv));
            type.el = el;
            this.addStep(type);
          }
        }
        break;
      }
      case "scroll": {
        let lastStep = this.steps[this.steps.length - 1];
        if (lastStep && lastStep instanceof Scroll) {
          lastStep.left = event.left;
          lastStep.top = event.top;
        } else {
          let { path, left, top } = event;
          let el = fv.getNode(path);
          let selector2 = await this.find(el);
          this.addStep(new Scroll(selector2, left, top, ...stepCtx(fv)));
        }
        break;
      }
    }
    this.emit("change");
  }
  removeRedundantSteps() {
    let lastStep = this.steps[this.steps.length - 1];
    let secondLastStep = this.steps[this.steps.length - 2];
    if (lastStep.isManuallyCreated || secondLastStep.isManuallyCreated)
      return;
    for (let [pattern, idx] of REPLACE_PATTERNS) {
      if (lastStep.type === pattern[1] && secondLastStep.type === pattern[0]) {
        this.steps.splice(this.steps.length - 1 - idx, 1);
        break;
      }
    }
  }
  replaceStep(step, idx) {
    if (idx < 0 || idx > this.steps.length - 1) {
      throw new Error("step index out of bounds");
    }
    this.steps[idx] = step;
    this.emit("change");
  }
  async reset() {
    this.steps = [];
    this.emit("change");
  }
}
function stepCtx(fv) {
  let index2 = fv.store.getIndex();
  return [index2, Date.now()];
}
class TypeChecker {
  static isOfType(typeName, value) {
    if (typeName === "KEYPRESS_OPTION") {
      return this.isKeypressOption(value);
    } else if (typeName === "SELECTOR") {
      return this.isSelector(value);
    } else if (typeName === "STRING") {
      return this.isString(value);
    } else if (typeName === "POSITION") {
      return this.isPosititon(value);
    } else if (typeName === "TARGET") {
      return this.isTarget(value);
    } else if (typeName === "NUMBER") {
      return this.isNumber(value);
    } else if (typeName === "POSITIVE_NUMBER") {
      return this.isPositiveNumber(value);
    } else {
      throw new Error(`unhandled type: ${typeName}`);
    }
  }
  static isKeypressOption(value) {
    if (typeof value !== "string")
      return false;
    if (!Keypress.keyCodeMap.hasOwnProperty(value))
      return false;
    return true;
  }
  static isSelector(value) {
    if (!value)
      return false;
    if (!value.hasOwnProperty("value") || typeof value.value !== "string")
      return false;
    if (!value.hasOwnProperty("meta") || typeof value.meta !== "object")
      return false;
    if (!("select" in value) || typeof value.select !== "function")
      return false;
    if (!("toJSON" in value) || typeof value.toJSON !== "function")
      return false;
    return true;
  }
  static isString(value) {
    return typeof value === "string";
  }
  static isPosititon(value) {
    if (!value)
      return false;
    if (!value.hasOwnProperty("x"))
      return false;
    if (!value.hasOwnProperty("y"))
      return false;
    if (typeof value.x !== "number")
      return false;
    if (typeof value.y !== "number")
      return false;
    return true;
  }
  static isTarget(value) {
    if (!value)
      return false;
    if (!value.hasOwnProperty("selector"))
      return false;
    if (!value.hasOwnProperty("pos"))
      return false;
    if (!this.isSelector(value.selector))
      return false;
    if (!this.isPosititon(value.pos))
      return false;
    return true;
  }
  static isNumber(value) {
    return typeof value === "number";
  }
  static isPositiveNumber(value) {
    return this.isNumber(value) && value > 0;
  }
}
var Recorder$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  stepTypes,
  BaseStep,
  WaitForDuration,
  WaitForElement,
  Open,
  Key,
  Mouse,
  EffectStep,
  Click,
  Keypress,
  Drag,
  MouseMove,
  Focus,
  Scroll,
  WaitForDoc,
  Select,
  Type,
  stepTypeDict,
  toJSON,
  toSteps,
  replay,
  REPLACE_PATTERNS,
  Base
}, Symbol.toStringTag, { value: "Module" }));
class Macro$1 extends base.Model {
  parse(json) {
    json.steps = parseSteps(json.steps || []);
    return json;
  }
}
class Macros extends base.PagedCollection {
  constructor() {
    super(...arguments);
    __publicField(this, "model", Macro$1);
    __publicField(this, "url", "/macros");
    __publicField(this, "limit", 20);
  }
}
function parseSteps(steps) {
  return toSteps(steps, ({ type, value, meta }) => {
    switch (type) {
      case "css":
        return new CSSSelector(value, meta);
      default:
        throw new Error("Unknown selector type: " + type);
    }
  });
}
class MacroSelector extends Base$3 {
  constructor({ model, classes: classes2 }) {
    super();
    this.model = model;
    this.state.classes = classes2 || [];
    this.setId(model.get("macro_id"));
    this.state.names = {};
    this.state.macros = new Macros([], {});
    if (App.user.isLoggedIn()) {
      this.loadMacros();
    }
  }
  getTrimmedURI() {
    if (!this.model.get("uri")) {
      return "";
    }
    return new URL(this.model.get("uri")).host;
  }
  async loadMacros({ name = "" } = {}) {
    const query = {
      "_opt": {
        only: ["id", "name"]
      }
    };
    if (name) {
      query["name.ilike"] = `%${name}%`;
      query["meta:->>'url'.like"] = `%${this.getTrimmedURI()}%`;
    } else if (this.state.id) {
      query["$or"] = {
        "meta:->>'url'.like": `%${this.getTrimmedURI()}%`,
        id: this.state.id
      };
    } else {
      query["meta:->>'url'.like"] = `%${this.getTrimmedURI()}%`;
    }
    this.state.macros.setQuery(query);
    await this.state.macros.fetch();
    this.state.names = this.state.macros.models.reduce((names, m) => {
      names[m.id] = m.get("name");
      return names;
    }, {});
  }
  onSearch(e) {
    this.loadMacros({
      name: e.target.value
    });
  }
  setId(id2, e) {
    e && e.preventDefault();
    this.state.id = id2;
    this.model.set("macro_id", id2);
  }
  createTpl({ id: id2, macros, names, classes: classes2 }) {
    let loadedMacros = !!macros.models;
    let team2 = get_store_value(params).team;
    return html`<div class='drowdown relative ${classes2.join(" ")}'>
      <a class='btn btn-default dropdown-toggle' data-toggle='dropdown'
        href='#'>
        Macro - ${!macros.get(id2) ? "None" : macros.get(id2).get("name") || "Deleted"}
        <span class='caret'></span>
      </a>
      <ul class='dropdown-menu'>
        ${loadedMacros ? [
      html`
        <li>
          <div class='ma2' @click=${(e) => (e.preventDefault(), e.stopPropagation())}>
            <input type='text' class='ba0' placeholder='Search' @input=${(e) => this.onSearch(e)}></input>
          </div>
        </li>
          <li><a href='#' @click=${(e) => this.setId(null, e)}>
              <i class='mr2 fa ${!id2 ? "fa-check" : "mr4"}'></i>
              Empty (Default)</a></li>`,
      macros.models.map((s) => html`<li>
            <a data-id=${s.id} href='#' @click=${(e) => this.setId(s.id, e)}>
              <i class='mr2 fa ${id2 === s.id ? "fa-check" : "mr4"}'></i>
              ${s.get("name")}
            </a>
          </li>`),
      html`
          <li class='divider'></li>

          <li><a href='#/w/${team2}/macros/' target='_blank'>
              <span class='pl4'> Manage Macros<span></a></li>

          <li><a href='${URL_WEBSITE}/docs/web-monitor/macro-to-record-replay-actions/' target='_blank'>
              <span class='pl4'> Learn More<span></a></li>
              `
    ] : html`<li><a>Loading...</a></li>`}
      </ul>
    </div>`;
  }
}
const HTMLSelector = View$1.ActionProvider.extend({
  name: "HTMLSelector",
  render: function() {
    this.selectorModal = new Selector$3.Modal({
      model: this.model.clone(),
      parent: this,
      onDiscard: this.onSelectorDiscard,
      onSave: this.onSelectorSave
    });
    this.selectorModal.show();
    return this;
  },
  onSelectorDiscard: function() {
    this.trigger("discard");
    this.selectorModal.remove();
  },
  onSelectorSave: function(err, model) {
    if (err) {
      Msg.error("Error running visual selector: " + err);
      this.trigger("error", err);
    } else {
      this.trigger("save", _.pick(model.toJSON(), "uri", "name", "config", "content_type", "macro_id", "session_id", "datasource_id"));
    }
    this.selectorModal.remove();
  }
});
const PDFSelector = View$1.ActionProvider.extend({
  name: "PDFSelector",
  postInit: function() {
    if (USER.constraint && USER.constraint.flexi) {
      this.editor = Editor.create("url", {
        param: {
          label: "m_enter_pdf_url",
          must: true,
          name: "uri"
        },
        parent: this
      }).render();
      this.listenTo(this.editor, "change", this.save);
    } else {
      this.editor = new View$1.Base({
        el: DIV({ class: "alert alert-info" }, "PDF monitoring is available to Flexi and Enterprise customers only. Please upgrade your account or contact support for more information.")
      });
    }
  },
  save: function() {
    const uri = this.editor.getValue();
    const parts = uri.split("/");
    const name = parts[parts.length - 1];
    const attrs = {
      name: name + (name.match(/\.pdf$/) ? "" : " pdf"),
      uri,
      content_type: C.TYPE_PDF_HTML,
      config: {}
    };
    this.trigger("save", attrs);
  },
  render: function() {
    this.$el.empty().append(this.editor.el);
    return this;
  }
});
const DOCSelector = View$1.ActionProvider.extend({
  name: "DOCSelector",
  postInit: function() {
    this.editor = Editor.create("url", {
      param: {
        label: "m_enter_doc_url",
        must: true,
        name: "uri"
      },
      parent: this
    }).render();
    this.listenTo(this.editor, "change", this.save);
  },
  save: function() {
    const uri = this.editor.getValue();
    const parts = uri.split("/");
    const name = parts[parts.length - 1];
    const attrs = {
      name: name + (name.match(/\.docx?$/) ? "" : " doc"),
      uri,
      content_type: C.TYPE_DOC,
      config: {}
    };
    this.trigger("save", attrs);
  },
  render: function() {
    this.$el.empty().append(this.editor.el);
    return this;
  }
});
const SieveSourceSelector = View$1.ActionProvider.extend({
  name: "SieveSourceSelector",
  postInit: function() {
    const model = this.model;
    let view;
    switch (model.get("content_type")) {
      case C.TYPE_HTML:
        view = new HTMLSelector({ parent: this, model });
        break;
      case C.TYPE_FEED:
        view = new FeedFinder({ parent: this, model });
        break;
      case C.TYPE_XML:
        view = new XMLSelector({ parent: this, model });
        break;
      case C.TYPE_PDF_HTML:
        view = new PDFSelector({ parent: this, model });
        break;
      case C.TYPE_DOC:
        view = new DOCSelector({ parent: this, model });
        break;
      case C.TYPE_JSON: {
        let dsId = model.get("datasource_id");
        if ([C.DS_ID_JSON, C.DS_ID_UPTIME].includes(dsId) || !dsId) {
          view = new JSONSelector({ parent: this, model });
        } else {
          view = new HTMLSelector({ parent: this, model });
        }
        break;
      }
      default:
        throw new Error("Unknown content_type");
    }
    view.on("save", (attrs) => this.trigger("save", attrs));
    view.on("discard", () => this.trigger("discard"));
    this.view = view;
  },
  render: function() {
    this.$el.append(this.view.render().el);
    return this;
  }
});
const SieveSourceEditor = View$1.ActionProvider.extend({
  name: "SieveSourceEditor",
  actions: {
    edit_url: {
      fn: "action_edit_url"
    },
    force_static: {
      fn: "action_force_static"
    },
    selector_config_show: {
      fn: "action_config_show"
    },
    selector_edit: {
      fn: "action_selector_edit"
    }
  },
  action_config_show: function() {
    openConfigEditor(this.model, T("l_selection_config"), (modal) => {
      modal.remove();
    });
  },
  action_edit_url: function() {
    const model = this.model;
    const view = Editor.create("url", {
      param: {
        label: "l_url",
        must: true,
        name: "uri"
      },
      model: model.clone(),
      parent: this
    });
    const modal = new View$1.SaveDiscardModal({
      name: "SieveSourceEditor$URLModal",
      parent: this,
      title: T("l_url"),
      view
    });
    modal.show();
    modal.on("save", function() {
      model.set({ uri: view.getValue() });
      modal.remove();
    });
    modal.on("discard", function() {
      modal.remove();
    });
  },
  action_force_static: function() {
    const model = this.model;
    const config = model.get("config");
    const pages = config.get("selections");
    const page = pages && pages.at(0);
    page.set("dynamic", false);
    this.checkURI(model);
    model.trigger("change");
  },
  action_selector_edit: function() {
    if (this.sourceSelector) {
      this.onEditSourceSelectorDiscard();
    } else {
      this.openSelector();
    }
  },
  checkURI: async function(model) {
    if (model.get("content_type") != C.TYPE_HTML) {
      return;
    }
    const url = model.get("uri");
    const config = model.get("config");
    const pages = config.get("selections");
    const page = pages.at(0);
    const tabXF = Supports.tabForXFrame;
    const tabDn = Supports.tabForDynamic;
    const elMsg = this.elXFrameNotice;
    if (!url || page.get("dynamic") === false || !Supports.agents.local || !(tabXF || tabDn)) {
      return $(elMsg).addClass("hide");
    }
    if (tabDn) {
      $(elMsg).removeClass("hide");
    } else if (tabXF) {
      try {
        let res2 = await serviceProxy.HTTP.get({ url });
        if (res2.headers["x-frame-options"] || /x-frame-options/i.test(res2.response)) {
          $(elMsg).removeClass("hide");
        }
      } catch (err) {
        return Msg.error("Failed to fetch URL.", err);
      }
    }
  },
  onSourceSelectorSave: function(attrs) {
    attrs.config = this.parseConfig(typeof attrs.config == "string" ? JSON.parse(attrs.config) : attrs.config);
    if (this.model.get("name")) {
      delete attrs.name;
    }
    this.model.set(attrs);
    this.sourceSelector.remove();
    this.sourceSelector = null;
  },
  onEditSourceSelectorDiscard: function() {
    this.sourceSelector.remove();
    this.sourceSelector = null;
    if (this.model.isNew()) {
      App.navBack();
    }
  },
  openSelector: function() {
    this.sourceSelector = new SieveSourceSelector({
      parent: this,
      model: this.model
    });
    this.listenTo(this.sourceSelector, "save", this.onSourceSelectorSave);
    this.listenTo(this.sourceSelector, "discard", this.onEditSourceSelectorDiscard);
    this.sourceSelector.render();
    this.elSelector.appendChild(this.sourceSelector.el);
    this.sourceSelector.$el.css({ padding: 10 });
  },
  parseConfig: function(config) {
    const ctor = this.model.get("config").constructor;
    return new ctor(config, { parse: true });
  },
  postInit: function() {
    const model = this.model;
    this.listenTo(model, "change:config change:uri", this.render);
    if (model.isEmpty()) {
      _.defer(this.openSelector);
    }
    this.elXFrameNotice = DIV({
      "class": "alert alert-info hide",
      "style": "margin: 5px 0; padding: 5px;"
    }, T("m_xframe_notice"), " ", BUTTON({
      "class": "btn btn-default btn-xs",
      "data-action": "force_static"
    }, T("a_static_load")), " ", A({ href: "https://distill.io/help/new-tab-chrome-extension" }, T("Learn More")));
    this.listenTo(model, "change:uri", this.checkURI);
    this.checkURI(model);
  },
  getContentTypeDescription: function() {
    switch (this.model.get("content_type")) {
      case C.TYPE_HTML:
        return SPRINTF("a_open_x_selector", "l_webpage");
      case C.TYPE_FEED:
        return SPRINTF("a_open_x_selector", "l_feed");
      case C.TYPE_XML:
        return SPRINTF("a_open_x_selector", "l_xml");
      case C.TYPE_PDF_HTML:
        return SPRINTF("a_open_x_selector", "l_pdf");
      case C.TYPE_DOC:
        return SPRINTF("a_open_x_selector", "l_doc");
      case C.TYPE_JSON:
        let name = "l_datasource";
        switch (this.model.get("datasource_id")) {
          case C.DS_ID_UPTIME:
            name = "l_uptime";
            break;
          case C.DS_ID_JSON:
          case null:
            name = "l_json";
        }
        return SPRINTF("a_open_x_selector", name);
      default:
        console.warn("getContentTypeDescription", "unknown content type", this.model.get("content_type"));
        return T("a_open_selector");
    }
  },
  render: function() {
    this.macroSelector = new MacroSelector({ model: this.model, classes: [] });
    this.$el.empty().append(DIV({
      "class": "flex"
    }, DIV({
      "class": "btn-group flex mr2",
      "role": "group"
    }, BUTTON({
      "type": "button",
      "class": "btn btn-default",
      "data-action": "selector_edit",
      "title": T("h_selector_edit")
    }, this.getContentTypeDescription()), BUTTON({
      "class": "btn btn-default dropdown-toggle",
      "data-toggle": "dropdown"
    }, SPAN({ "class": "caret" })), UL({ "class": "dropdown-menu" }, LI(A({
      "data-action": "selector_config_show",
      "href": "javascript:void 0"
    }, T("h_config_show"))))), this.model.get("content_type") == C.TYPE_HTML ? DIV({
      "class": "mr2"
    }, this.macroSelector.el) : "", BUTTON({
      "class": "btn btn-default truncate mw6",
      "data-action": "edit_url"
    }, T("a_edit"), " ", this.model.get("uri"))), this.elXFrameNotice, this.elSelector = DIV());
    return this;
  }
});
const SieveOptions = View$1.ActionProvider.extend({
  name: "SieveOptions",
  actions: {
    sieve_save: { fn: "action_save" }
  },
  action_save: function(x, el) {
    const model = this.model;
    Msg.start("sieve:save", { info: "saving" });
    $(el).button("loading");
    async.series([
      (callback) => {
        const rule = this.rulesEditor.model;
        this.rulesEditor.updateModel();
        if (rule.isNew() && rule.isEmpty()) {
          return callback();
        }
        Msg.start("sieve:rule:save", { info: "l_loading" });
        rule.save(null, {
          error: function(rule2, res2) {
            Msg.stop("sieve:rule:save", { error: "e_req" });
            callback({ msg: "Failed to save conditions", err: res2 });
          },
          success: function() {
            if (model.get("rule_id") != rule.id) {
              model.set({ rule_id: rule.id }, { silent: true });
            }
            Msg.stop("sieve:rule:save");
            callback();
          }
        });
      },
      (callback) => {
        const attrs = _.omit(model.toJSON(), "err", "text", "ts", "ts_data", "ts_mod", "ts_view", "user_id");
        if (attrs.state == C.STATE_INIT) {
          attrs.state = C.STATE_READY;
        }
        model.save(null, {
          data: attrs,
          patch: true,
          silent: true,
          wait: true,
          error: function(model2, res2) {
            Msg.stop("sieve:save", { error: "Failed to save changes to server" });
            callback({ msg: "Failed to save changes", err: res2 });
          },
          success: function(model2) {
            Msg.stop("sieve:save");
            callback(null);
          }
        });
      },
      (callback) => {
        const changes = this.actionEditor.getChanges();
        if (!base.syncBatch(changes, callback)) {
          callback();
        }
      }
    ], (err, results) => {
      $(el).button("reset");
      if (err) {
        Msg.error("Failed to save data. Please check console for more info.");
      } else {
        this.trigger("save");
        App.navBack();
      }
    });
  },
  duplicate: async function(id2) {
    const model = await this.fetch(id2);
    const json = _.pick(model.toJSON(), "name", "uri", "config", "client_id", "content_type", "schedule", "tags", "datasource_id");
    json.name = "Copy of " + json.name;
    this.setModel(new this.collection.model(json, { parse: true }), {
      defaultsModel: model,
      editURL: false
    });
  },
  edit: async function(id2) {
    let model = await this.fetch(id2);
    this.setModel(model);
  },
  editNew: function(type, options) {
    let content_type = 0;
    let attrs = {};
    switch (type) {
      case "page":
        content_type = C.TYPE_HTML;
        break;
      case "feed":
        content_type = C.TYPE_FEED;
        break;
      case "xml":
        content_type = C.TYPE_XML;
        break;
      case "pdf":
        content_type = C.TYPE_PDF_HTML;
        break;
      case "doc":
        content_type = C.TYPE_DOC;
        break;
      case "json":
        content_type = C.TYPE_JSON;
        switch (options.type) {
          case C.DS_TYPE_UPTIME:
            attrs.datasource_id = C.DS_ID_UPTIME;
            break;
          case C.DS_TYPE_JSON:
          default:
            attrs.datasource_id = C.DS_ID_JSON;
        }
        break;
      default:
        Msg.error("Unknown monitor type: " + type);
        throw new Error("Unknown monitor type: " + type);
    }
    this.setModel(new Model$2.Sieve({
      ...attrs,
      content_type
    }, { parse: true }));
  },
  fetch: async function(id2) {
    let model = new Model$2.Sieve({ id: id2 });
    await model.fetch();
    return model;
  },
  initEditors: async function(model, defaultsModel) {
    const actions = new Model$2.SieveActions(null, { parent: model });
    const rule = new Model$2.SieveRule({
      id: model.get("rule_id") || void 0
    });
    this.sourceEditor = new SieveSourceEditor({
      model,
      parent: this,
      className: "controls"
    }).render();
    this.clientSelector = new ViewClients.ClientSelector({ model });
    this.nameEditor = Editor.create("text", {
      model,
      param: {
        label: "l_name",
        must: true,
        name: "name",
        type: "text"
      },
      parent: this
    }).render();
    this.scheduleEditor = new SieveScheduleEditor({
      model,
      parent: this
    }).render();
    this.actionEditor = new SieveActionsEditor({
      actions,
      sieve: model,
      parent: this
    }).render();
    this.rulesEditor = new SieveRuleWrapper({
      model: rule,
      parent: this
    }).render();
    this.tagsEditor = new TagsEditor({
      model,
      parent: this
    }).render();
    this.loadDefaults(model, actions, defaultsModel);
  },
  async createDefaults(sieve, actions, defaultsModel) {
    const uri = sieve.get("uri");
    const hostn = uri && new URL(uri).hostname;
    const colln = new Model$2.Sieves();
    if (_.isEmpty(sieve.get("name")) && uri) {
      sieve.set("name", T("l_loading"));
      $.get(URL_UTILS + "/v1/http/get?html_css_filter=title&url=" + encodeURIComponent(uri), function(res2) {
        if (res2) {
          sieve.set("name", $(res2).text().trim() || "Untitled");
        }
      });
    }
    let copyRef = (ref, defaultRules) => {
      const refActions = new Model$2.SieveActions(null, { parent: ref });
      refActions.fetch({
        data: { state: 0 },
        success: () => {
          refActions.each((action) => {
            const attrs = action.omit("id", "sieve_id", "ts", "ts_mod");
            actions.add(new Model$2.SieveAction[attrs.type](attrs, { parse: true }));
          });
          this.onChanges();
        }
      });
      let refSchedule = ref.get("schedule");
      if (refSchedule.get("type") == "LIVE") {
        refSchedule = new Model$2.Schedule({ type: "INTERVAL" });
      }
      sieve.set("schedule", refSchedule);
      this.scheduleEditor.render();
      const rule_id = ref.get("rule_id");
      if (defaultRules && rule_id) {
        this.rulesEditor.duplicate(rule_id);
      }
    };
    if (defaultsModel) {
      return copyRef(defaultsModel, true);
    }
    await colln.fetch({
      data: {
        "uri.like": "%" + hostn + "%",
        "state.in": [C.STATE_READY, C.STATE_PAUSED],
        "_opt": {
          limit: 1,
          order: ["-ts"],
          only: ["id", "schedule", "tags"]
        }
      }
    });
    if (colln.length > 0) {
      return copyRef(colln.at(0), false);
    }
    await colln.fetch({
      data: {
        "state.in": [C.STATE_READY, C.STATE_PAUSED],
        "_opt": {
          limit: 1,
          order: ["-ts"],
          only: ["id", "schedule", "tags"]
        }
      }
    });
    if (colln.length > 0) {
      return copyRef(colln.at(0), false);
    }
    _.each(Model$2.SieveActionDescList, (desc) => {
      if (desc.addByDefault(Supports)) {
        actions.add(new Model$2.SieveAction[desc.type]());
      }
    });
    this.onChanges();
  },
  loadDefaults: function(sieve, actions, defaultsModel) {
    if (sieve.isNew() || sieve.get("state") == C.STATE_INIT) {
      this.createDefaults(sieve, actions, defaultsModel);
    } else {
      actions.fetch({ data: { state: 0 } });
    }
  },
  postInit: function(options) {
    this.clients = options.clients;
  },
  showProgress: function() {
    this.$el.children(".xprogress").show();
  },
  removeProgress: function() {
    this.$el.children(".xprogress").hide();
  },
  render: function() {
    this.$el.empty().append(DIV({ "class": "xtbar xvbar-margin" }, BUTTON({
      "class": "btn btn-default",
      "data-action": "go_back"
    }, I({ "class": "fa fa-chevron-left" }), " ", T("a_discard"), " ", this.elUnsavedMsg = SPAN())), DIV({ "class": "xpage-header" }, H3(this.elHeading = SPAN())), DIV({ "class": "xprogress", "style": "margin-top: -2px;position:absolute;" }, DIV({ "class": "xindeterminate" })), DIV({ "class": "form-horizontal", "style": "padding: 10px;" }, this.elContent = DIV()));
    return this;
  },
  renderOptions: function() {
    const model = this.model;
    model.getTags(App.labels);
    $(this.elHeading).empty().append(T("l_options"), " - ", model.isNew() ? T("l_add_monitor") : model.get("name"));
    $(this.elContent).empty().append(DIV({ "class": "form-group" }, LABEL({ "class": "control-label col-md-2" }, T("l_source")), DIV({ "class": "col-md-10" }, this.sourceEditor.el, P({ "class": "help" }, T("h_sieve_source")))), DIV({ "class": "form-group" }, LABEL({ "class": "control-label col-md-2", "for": "sieve-device" }, T("l_device")), DIV({ "class": "col-md-10" }, this.clientSelector.el, P({ "class": "help" }, T("h_sieve_device")))), DIV({ "class": "form-group" }, LABEL({ "class": "control-label col-md-2", "for": "sieve-name" }, T("l_name")), DIV({ "class": "col-md-10" }, this.nameEditor.el, P({ "class": "help" }, T("h_sieve_name")))), DIV({ "class": "form-group" }, LABEL({ "class": "control-label col-md-2", "for": "sieve-schedule" }, T("l_schedule")), DIV({ "class": "col-md-10" }, this.scheduleEditor.el)), DIV({ "class": "form-group" }, LABEL({ "class": "control-label col-md-2" }, T("l_actions")), DIV({ "class": "col-md-10" }, this.actionEditor.el, P({ "class": "help" }, T("h_sieve_actions")))), DIV({ "class": "form-group" }, LABEL({ "class": "control-label col-md-2" }, T("l_conditions")), DIV({ "class": "col-md-10" }, this.rulesEditor.el, P({ "class": "help" }, T("h_sieve_rules")))), DIV({ "class": "form-group" }, LABEL({ "class": "control-label col-md-2" }, T("l_label")), DIV({ "class": "col-md-10" }, this.tagsEditor.el)), DIV({ "class": "form-group" }, DIV({ "class": "col-md-offset-2 col-md-10 xtbar-form" }, BUTTON({
      "class": "btn btn-primary xbtn-default",
      "data-action": "sieve_save"
    }, T("a_save")), BUTTON({
      "class": "btn btn-default",
      "data-action": "go_back"
    }, T("a_discard")))));
  },
  onChanges: function() {
  },
  onSaveModel: function(attrs) {
    const model = new this.collection.model(_.defaults(attrs, {
      client_id: this.clients.defaultId,
      content_type: this.model.get("content_type"),
      datasource_id: this.model.get("datasource_id"),
      schedule: {
        type: "INTERVAL",
        params: {
          interval: 10800
        }
      },
      version: 1
    }), { parse: true });
    this.setModel(model);
  },
  onNewSourceSelectorDiscard: function() {
    this.sourceSelector.remove();
    App.navBack();
  },
  setModel: async function(model, options = {
    defaultsModel: null,
    editURL: false
  }) {
    this.showProgress();
    let sieveConstraint = {};
    if (this.model) {
      this.stopListening(this.model);
    }
    this.model = model;
    this.sourceSelector && this.sourceSelector.remove();
    this.listenTo(model, "change", this.onChanges);
    $(this.elUnsavedMsg).text("");
    try {
      sieveConstraint = await checkSieveConstraint(1);
    } catch (e) {
      console.error(e);
      sieveConstraint = { isOverLimit: false };
    }
    let accessInfo = await model.getAccess(App.user);
    if (model.isNew() && !accessInfo.hasAccess) {
      $(this.elHeading).text(T("m_upgrade_account"));
      let { minPlan } = accessInfo;
      if (minPlan) {
        $(this.elContent).empty().append(`${model.getTypeName()} monitors are available in ${minPlan} or higher subscriptions. `, A({
          href: urls.billing
        }, "Manage Subscription"));
      } else {
        $(this.elContent).append("Please sign in or contact support to get more information");
      }
    } else if (model.isNew() && sieveConstraint.isOverLimit) {
      $(this.elHeading).text(T("m_monitor_limit"));
      $(this.elContent).empty().append(SieveConstraints(sieveConstraint));
    } else if (model.isEmpty()) {
      this.showSourceSelector(model);
    } else {
      await this.initEditors(model, options.defaultsModel);
      this.renderOptions();
      if (options.editURL) {
        this.sourceEditor.action_edit_url();
      }
    }
    this.removeProgress();
  },
  showSourceSelector(model) {
    const sourceSelector = new SieveSourceSelector({
      model,
      parent: this
    }).render();
    sourceSelector.on("save", this.onSaveModel);
    sourceSelector.on("discard", this.onNewSourceSelectorDiscard);
    this.sourceSelector = sourceSelector;
    $(this.elHeading).text(T("l_source"));
    $(this.elContent).empty().append(sourceSelector.el);
  }
});
const openConfigEditor = function(model, title, callback) {
  const view = Editor.create("json", {
    param: {
      label: "l_selection_config",
      must: false,
      name: "config",
      type: "json"
    },
    model: new Backbone.Model({
      config: model.get("config").toJSON()
    })
  });
  const modal = new View$1.SaveDiscardModal({
    name: "SieveSourceEditor$ConfigModal",
    title,
    view
  });
  modal.on("save", function() {
    const config = view.model.get("config");
    model.set({ config: parseConfig(config) });
    callback(modal);
  });
  modal.on("discard", function() {
    modal.remove();
  });
  modal.show();
  view.$el.find("textarea").css("height", 300);
  function parseConfig(config) {
    const ctor = model.get("config").constructor;
    return new ctor(config, { parse: true });
  }
};
function create_fragment$U(ctx) {
  let div1;
  let div0;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      ctx[3](div0);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div1);
      ctx[3](null);
    }
  };
}
function instance$T($$self, $$props, $$invalidate) {
  let { route: route2 } = $$props;
  let { user, clients, labels, sieves } = getContext$1("watchlist:stores");
  let root = getContext$1("view:root");
  let el;
  let view;
  let lastRoute = null;
  function show() {
    if (route2 == lastRoute) {
      return;
    }
    if (route2.prefix == "dup") {
      view.duplicate(route2.id);
    } else if (route2.id) {
      view.edit(route2.id);
    } else {
      view.editNew(route2.data, route2.query);
    }
    lastRoute = route2;
  }
  onMount(() => {
    $$invalidate(2, view = new SieveOptions({
      el,
      clients,
      collection: sieves,
      parent: root
    }).render());
    show();
    return () => view.remove();
  });
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(0, el);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("route" in $$props2)
      $$invalidate(1, route2 = $$props2.route);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 6) {
      route2 && view && show();
    }
  };
  return [el, route2, view, div0_binding];
}
class Edit extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$T, create_fragment$U, safe_not_equal, { route: 1 });
  }
}
const diff_match_patch$1 = window.diff_match_patch;
if (!diff_match_patch$1) {
  throw new Error("ADD diff_match_patch");
}
const $$3 = window.jQuery;
if (!$$3) {
  throw new Error("ADD jQuery");
}
const _$2 = window._;
if (!_$2) {
  throw new Error("ADD _");
}
const async$2 = window.async;
if (!async$2) {
  throw new Error("ADD async");
}
const domo$1 = window.domo;
if (!domo$1) {
  throw new Error("ADD domo");
}
const moment$2 = window.moment;
if (!moment$2) {
  throw new Error("ADD moment");
}
const Backbone$3 = window.Backbone;
if (!Backbone$3) {
  throw new Error("ADD Backbone");
}
const Work$1 = View$1.Base.extend({
  name: "Work",
  url: function() {
    const attrs = this.model.attributes;
    if (attrs.err) {
      const team2 = get_store_value(params).team;
      return `#/checks/${team2}/${this.options.sieve.id}?work=${attrs.id}`;
    } else {
      return "#";
    }
  },
  render: function() {
    const attrs = this.model.attributes;
    const err = attrs.err;
    if (err) {
      this.$el.append(DIV({ "class": "flex" }, DIV({ "class": "error popup flex-1 hover:grey", "tabindex": "0" }, SPAN(formatTime(attrs.ts)), " ", SPAN(err.code || "EUNKNOWN"), " "), A({ "href": this.url(), "target": "_blank", class: "ml1" }, "View Details"))).find(".popup").popover({
        placement: "left",
        html: true,
        trigger: "click|focus",
        container: "body",
        content: () => {
          return DIV({ class: "overflow-y-auto max-h-[300px]" }, DIV(LABEL("Code:"), " ", SPAN(err.code || "NA")), DIV(LABEL("Msg:"), " ", SPAN(err.msg || err.message || JSON.stringify(err))), DIV({ style: "padding-top: 5px;" }, STRONG("Recommended Actions"), this.getSuggestions(err)), DIV({ style: "padding-top: 5px;" }, STRONG("Need help?"), DIV("Contact us at support@distill.io"))).outerHTML;
        }
      }).click(function(e) {
        e.preventDefault();
      });
    } else {
      this.$el.append(SPAN(formatTime(attrs.ts)));
    }
    return this;
  },
  getSuggestions: function(err) {
    switch (err.code || "NA") {
      case "SELECTION_EMPTY":
        return UL({ "style": "padding-left:14px;" }, LI("Ensure that selected elements has text content."), LI("If website needs login, make sure that you are logged in."));
      case "TIMEOUT":
      case "ENOTFOUND":
      case "EREQUEST":
      case "ETIMEDOUT":
      case "ECONNREFUSED":
        return DIV("Please ensure that the webpage is accessible.");
      case "JAVASCRIPT":
        return DIV("Ensure that JavaScript is working in the page.");
      default:
        if (err.status === 0) {
          return DIV("Ensure that internet connection is working.");
        }
        return DIV("There is no information about this error.");
    }
  }
});
const Works$1 = View$1.Collection.extend({
  name: "Works",
  postInit: function() {
    this.sieve = this.collection.sieve;
    this.collection.fetch();
    this.collection.on("sync", this.onSync);
  },
  addOne: function(model) {
    const view = new Work$1({
      model,
      parent: this,
      sieve: this.sieve
    });
    this.$msg.empty();
    this.$list.append(view.render().el);
    return view;
  },
  onSync: function() {
    if (this.collection.length == 0) {
      if (this.sieve.get("client_id") == App.clients.defaultId) {
        this.$msg.text(T("m_log_na"));
      } else {
        this.$msg.text(T("Log for this monitor will be available on device that runs this monitor"));
      }
    }
  },
  renderBase: function() {
    this.$msg = $$3(DIV(T("l_loading")));
    this.$list = $$3(DIV());
    this.$el.append(this.$msg, this.$list);
  }
});
var SieveRow = View$1.Base.extend({
  name: "SieveRow",
  className: "xitem",
  tagName: "tr",
  events: {
    "click :checkbox": "event_check"
  },
  event_check: function() {
    this.model.prop("select", this.$("input[type=checkbox]:checked").length > 0);
  },
  onSelect: function(selected) {
    this.$el[selected ? "addClass" : "removeClass"]("active");
  },
  postInit: function(options) {
    const model = this.model;
    const id2 = model.id;
    this.listenTo(model, "change", this.renderRow);
    this.listenTo(model, "destroy", this.remove);
    this.listenTo(model, "remove", this.remove);
    this.listenTo(model, "sync", this.onSync);
    this.listenTo(model, "prop:select", this.onSelect);
    this.elDetail = TR(TD({ colspan: 8 }));
    this.listenTo(instance$1Q, "sieves:" + id2, this.onSieveUpdate);
    this.listenTo(instance$1Q, "sieves:run_state:" + id2, this.onSieveRunState);
    this.listenTo(instance$1Q, "sieves:on_demand_run_status:" + id2, this.onSieveRunState);
  },
  reattach: function() {
    const parentNode = this.el.parentNode;
    parentNode && parentNode.removeChild(this.el);
    parentNode && parentNode.appendChild(this.el);
    if (this.elDetail.parentNode) {
      parentNode.removeChild(this.elDetail);
      parentNode.appendChild(this.elDetail);
    }
  },
  isSelected: function() {
    return this.model.prop("select");
  },
  onSieveRunState: function(e) {
    this.runState = e.state || e.doc.state || 0;
    this.renderRow();
  },
  onSieveUpdate: function(e) {
    if (e.doc) {
      this.model.set(this.model.parse(e.doc), { silent: true });
      this.model.trigger("change");
    } else {
      this.model.fetch();
    }
  },
  onSync: function() {
    this.render();
  },
  remove: function() {
    SieveRow.__super__.remove.call(this);
    $$3(this.elDetail).remove();
  },
  removeDetail: function() {
    this.$el.removeClass("active");
    this.detail && this.detail.remove();
    $$3(this.elDetail).remove();
    this.setSelected(false);
    delete this.detail;
  },
  render: function() {
    this.renderRow();
    this.detail && this.showDetail(this.detail);
    this.setSelected(this.isSelected());
    return this;
  },
  renderRow: function() {
    let { runState } = this;
    let url = this.model.attributes.uri;
    let host = "";
    try {
      host = "//" + new URL(url).host;
    } catch (e) {
    }
    const renderRowTemplate = (model) => html`
      <td data-action = 'void 0'>
        <label class='xtd xdata xaction'>
          <input type="checkbox" style='margin:0;vertical-align:middle;'>
        </label>
      </td>
      <td data-action = 'void 0'>
        <button class='xtd xbtn xaction' style='margin: 0;' data-action= 'sieve context menu' data-action-param= '$parents [data-id]@data-id'>
          <i class="fa fa-caret-down"></i>
        </button>
      </td>
      <td>
        <a @click=${(e) => model.markRead()}
          class='xtd xdata monitor-link' href=${model.attributes.uri || "#"}
          rel='noopener' target='_blank' title=${model.attributes.name}>
          <img width=14 src=${URL_ROOT + "/v1/getfavicon?url=" + escape(host)} loading='lazy'></img>
          ${model.attributes.name || SPRINTF("l_untitled")}
        </a>
      </td>
      <td data-action= 'sieve view' data-action-param=${model.id}>
        <div class= 'xtd xdata xaction' title= 'Click to view history'>
          <i class="xcaret fa fa-angle-double-down fa-lg"></i>
          ${model.attributes.state == C.STATE_DISCARD || model.attributes.state == C.STATE_DEL ? html`<span class= 'label label-danger xlabel xlabel-small'>Deleted</span>` : html`<span></span>`}
          <span>
            ${_$2.map(model.getTags(App.labels), (tag) => {
      return html`<span class='label label-info xlabel xlabel-small'>${tag.get("name")}</span>`;
    })}
          </span>
          <span>
          ${model.attributes.text != null ? model.attributes.text || "<" + SPRINTF("h_sieve_empty") + ">" : "<" + SPRINTF("h_sieve_new") + ">"}
          </span>
        </div>
      </td>
      <td class= ${model.attributes.schedule ? model.attributes.schedule.getFrequencyClass() : "error"}>
        <a 
          class= 'xtd xdata xaction'
          title= 'Click to edit schedule'
          data-action= 'sieve schedule menu'
          data-action-param= '$parents [data-id]@data-id'
          data-toggle= 'tooltip'>
            <small>${model.attributes.schedule ? model.attributes.schedule.getShortDisplayText() : "err: unset"}</small>
            <i class="xcaret fa fa-caret-down"></i>
        </a>
      </td>
      <td>
        <a
        class= ${"xtd xdata xaction xsieve-ts-data " + (model.attributes.err ? "xsieve-err" : "")}
        title= 'Click to view check/error log'
        data-action= 'sieve log menu'
        data-action-param= '$parents [data-id]@data-id'
        data-toggle= 'tooltip'>
          <small>${runState == C.RUN_STATE_WAIT ? "Waiting" : runState == C.RUN_STATE_WIP ? "Checking" : formatTime(model.attributes.ts_data, true) || "" || "NA"}</small>
          <i class="xcaret fa fa-caret-down"></i>
        </a>
      </td>
      <td style='padding: 0'>
        <a
        class= 'xtd xdata xaction xbtn'
        title= 'Click to edit device'
        data-action= 'sieve client menu'
        data-action-param= '$parents [data-id]@data-id'
        data-toggle= 'tooltip'
        style= 'text-align:center'>
          <i class="fa fa-lg ${App.clients.get(model.attributes.client_id) ? App.clients.get(model.attributes.client_id).getIcon() : " error fa-question"}"  style= 'margin: auto;'></i>
          <i class="xcaret fa fa-caret-down"></i>
        </a>
      </td>
      <td data-action= 'void 0' style= 'padding: 0'>
        <button
          class= ${"xtd btn btn-xs " + (model.attributes.state == C.STATE_READY ? "btn-success" : "btn-default") + (model.attributes.state == C.STATE_DISCARD ? " disabled" : "")}
          style= 'border-radius:0'
          data-action= 'sieve switch'
          data-action-param= '$parents [data-id]@data-id'
          title= 'Turn monitor ON or OFF'
          data-placement= 'left'>
          ${model.attributes.state == C.STATE_READY ? "ON " : "OFF"}
        </button>
      </td>
    `;
    render(renderRowTemplate(this.model), this.el);
    if (this.model.attributes._state && this.model.attributes._state != 0) {
      this.$el.addClass("xdirty").attr("title", T("m_sync_to_save"));
    } else {
      this.$el.removeClass("xdirty").removeAttr("title");
    }
    this.$('[data-toggle="tooltip"]').tooltip({ delay: { show: 400 } });
    if (this.model.isRead()) {
      this.$el.addClass("xfade").removeClass("xunread");
    } else {
      this.$el.addClass("xunread").removeClass("xfade");
    }
  },
  setSelected: function(selected) {
    if (this.$("input[type=checkbox]:checked").length > 0 !== selected) {
      this.$("input[type=checkbox]").prop("checked", selected);
      this.model.prop("select", selected);
    }
  },
  showDetail: function(view) {
    if (this.detail == view)
      return;
    this.listenTo(view, "remove", function() {
      if (this.detail == view) {
        delete this.detail;
        this.removeDetail();
      }
    }, this);
    this.elDetail.children[0].appendChild(view.el);
    this.detail = view;
    this.$el.addClass("active");
    this.$el.after(this.elDetail);
    view.listenTo(view, "remove", () => {
      this.model.markRead();
    });
    this.setSelected(true);
  }
});
const LogMenu = View$1.ContextMenu.extend({
  name: "LogMenu",
  actions: {
    "log menu close": { fn: "hide" },
    "clear-error": { fn: "clear_error" }
  },
  clear_error: function() {
    const model = this.collection.get(this.id);
    model.save("err", null, {
      error: function() {
        Msg.error("e_err");
      }
    });
  },
  onSync: function() {
    this.show();
  },
  postInit: function(options) {
    this.collection = this.options.collection;
  },
  renderMenu: function() {
    const model = this.collection.get(this.id);
    const works = new Model$2.Works(null, { sieve: model });
    this.$el.empty().append(LI(BUTTON({
      "class": "btn xbtn-light pull-right",
      "data-action": "log menu close"
    }, I({ "class": "fa fa-times" })), SPAN({ style: "margin-left: 18px;" }, I(T("l_changed_on")))), LI({ "class": "xview" }, SPAN(formatTime(model.get("ts_data"))), I(T("l_check_log")), SPAN(new Works$1({
      parent: this,
      collection: works
    }).render().el)), LI({ "class": model.get("err") ? "xview" : "hide" }, A({
      "data-action": "clear-error"
    }, T("a_clear_error"))));
    this.listenTo(works, "sync", this.onSync);
  }
});
const ScheduleMenu = View$1.ContextMenu.extend({
  name: "ScheduleMenu",
  actions: {
    "schedule menu close": { fn: "hide" }
  },
  postInit: function(options) {
    this.collection = this.options.collection;
  },
  onScheduleChange: function(schedule) {
    const model = this.collection.get(this.id);
    Msg.start("save", "l_loading");
    model.set("schedule", schedule, { silent: true });
    model.save(null, {
      patch: true,
      silent: true,
      data: {
        schedule: JSON.stringify(schedule)
      },
      error: function() {
        Msg.stop("save", { error: "e_req" });
      },
      success: function() {
        Msg.stop("save", { info: "m_saved_schedule" });
      }
    });
  },
  renderMenu: function() {
    const model = this.collection.get(this.id).clone();
    if (!model) {
      this.$el.text("Model not found:" + this.id);
      return this;
    }
    this.editedModel = model;
    const scheduleEditor = new SieveScheduleEditor({
      model,
      parent: this
    });
    this.$el.empty().append(LI(BUTTON({
      "class": "btn xbtn-light pull-right",
      "data-action": "schedule menu close"
    }, I({ "class": "fa fa-times" })), SPAN({ style: "margin-left: 18px;" }, I(T("l_schedule")))), LI({ "class": "xview" }, scheduleEditor.render().el));
    this.off();
    this.listenTo(model, "change:schedule", this.onScheduleChange);
    setTimeout(() => scheduleEditor.focus(), 10);
  }
});
const SieveClientMenu = View$1.ContextMenu.extend({
  name: "SieveClientMenu",
  actions: {
    "menu client change": {
      fn: "action_client_change"
    },
    "menu client settings": {
      fn: "action_client_settings"
    }
  },
  action_client_change: function(id2) {
    const model = this.collection.get(this.id);
    Msg.start("save", "l_loading");
    model.save("client_id", id2, {
      wait: true,
      error: function() {
        Msg.stop("save", { error: "e_req" });
      },
      success: () => {
        Msg.stop("save");
        this.hide();
      }
    });
  },
  action_client_settings: function() {
    const modal = new View$1.Modal({
      parent: this.getRoot(),
      title: "l_devices",
      view: new ViewClients.ClientManager({
        parent: this.getRoot(),
        collection: App.clients
      })
    });
    modal.show();
  },
  postInit: function(options) {
    this.collection = this.options.collection;
  },
  renderMenu: function() {
    const model = this.collection.get(this.id);
    let availableClients = model.getAccessibleClients(App.clients);
    this.$el.empty();
    this.$el.append(LI({ "class": "xview" }, SPAN(T("a_select_device"))), LI({ "class": "divider" })).append(availableClients.map(function(client) {
      return LI(client.id == model.get("client_id") ? A({ "style": "font-weight:bold;" }, I({ "class": "fa fa-check" }), " ", client.getInfo()) : A({
        "data-action": "menu client change",
        "data-action-param": client.id
      }, I({ "class": client.getIcon() }), " ", client.getInfo()));
    })).append(LI({ "class": "divider" }), LI(A({
      "data-action": "menu client settings"
    }, I({ "class": "fa fa-edit" }), " ", T("a_edit"))));
  }
});
const SieveContextMenu = View$1.ContextMenu.extend({
  name: "SieveContextMenu",
  actions: {
    "menu check changes": {
      fn: "action_check_for_changes"
    },
    "menu del": {
      fn: "action_del"
    },
    "menu del permanent": {
      fn: "action_del_permanent"
    },
    "menu duplicate": {
      fn: "action_duplicate"
    },
    "menu edit": {
      fn: "action_edit"
    },
    "menu_create_tpl": {
      fn: "action_create_tpl"
    }
  },
  action_check_for_changes: async function() {
    const model = this.collection.get(this.id);
    const ids = [this.id];
    let cId = model.get("client_id");
    if (cId !== C.CLIENT_WEB) {
      serviceProxy.service.checkNow(ids);
    } else {
      Msg.info("m_check_local_only");
    }
    this.hide();
    if (!await serviceProxy.isActive()) {
      Msg.error("m_checks_paused");
    }
  },
  action_create_tpl: function() {
    let team2 = get_store_value(params).team;
    push$1(`/w/${team2}/tpls/add-from/${this.id}.id`);
    this.hide();
  },
  action_del: function() {
    const model = this.collection.get(this.id);
    Msg.start("discard", "l_loading");
    model.save("state", C.STATE_DISCARD, {
      patch: true,
      error: function() {
        Msg.stop("discard", { error: "e_req" });
      },
      success: () => {
        model.collection.remove(model);
        Msg.stop("discard");
        this.hide();
      }
    });
  },
  action_duplicate: function() {
    let team2 = get_store_value(params).team;
    push$1(`/w/${team2}/sieve/dup/${this.id}.id`);
    this.hide();
  },
  action_del_permanent: function() {
    const model = this.collection.get(this.id);
    Msg.start("destroy", "l_loading");
    model.destroy({
      error: () => {
        Msg.stop("destroy", { error: "e_req" });
      },
      success: () => {
        Msg.stop("destroy");
        this.hide();
      }
    });
  },
  action_edit: function() {
    let team2 = get_store_value(params).team;
    push$1(`/w/${team2}/sieve/edit/${this.id}.id`);
    this.hide();
  },
  onActionAdd: function(model) {
    if (model.id)
      return;
    Msg.start("save", "m_saving");
    model.save(null, {
      error: () => {
        Msg.stop("save", { error: "e_req" });
      },
      success: () => {
        Msg.stop("save", { info: "m_saved_action" });
      }
    });
  },
  onActionChange: function(model) {
    if (!model.id) {
      const data = model.changed;
      model.once("sync", () => {
        model.set(data);
      }, this);
    } else {
      Msg.start("save", "m_saving");
      model.save(null, {
        silent: true,
        error: () => {
          Msg.stop("save", { error: "e_req" });
        },
        success: () => {
          Msg.stop("save", { info: "m_saved_action" });
        }
      });
    }
  },
  onActionRemove: function(model) {
    if (!model.id)
      return;
    Msg.start("save", "m_saving");
    model.destroy({
      error: () => {
        Msg.stop("save", { error: "e_req" });
      },
      success: () => {
        Msg.stop("save", { info: "m_deleted_action" });
      }
    });
  },
  postInit: function(options) {
    this.collection = this.options.collection;
  },
  renderMenu: function() {
    const model = this.collection.get(this.id);
    const actions = new Model$2.SieveActions(null, { parent: model });
    if (!model) {
      this.$el.text("Model not found:" + this.id);
      return this;
    }
    actions.fetch({ data: { state: 0 } });
    this.actionEditor = new SieveActionsEditor({
      actions,
      sieve: model,
      parent: this
    });
    this.$el.empty();
    if (Supports.agents.local) {
      this.$el.append(LI(A({ "data-action": "menu check changes" }, T("a_check_changes"))));
    }
    this.$el.append(LI(A({ "data-action": "menu edit" }, T("a_edit_options"))), LI(A({ "data-action": "menu duplicate" }, T("a_duplicate"))), LI(A({ "data-action": "menu_create_tpl" }, SPRINTF("a_action_object", "a_create", "l_tpl"))), LI({ "class": "divider" }), LI({ "class": "xview" }, this.actionEditor.render().el), LI({ "class": "divider" }), LI(A({ "data-action": "menu del" }, T("a_move_to_trash"))), LI(A({ "data-action": "menu del permanent" }, T("a_del_permanent"))));
    this.listenTo(this.actionEditor.models, "add", this.onActionAdd);
    this.listenTo(this.actionEditor.models, "change", this.onActionChange);
    this.listenTo(this.actionEditor.models, "remove", this.onActionRemove);
  }
});
const SievesListMenu = View$1.ContextMenu.extend({
  name: "SievesListMenu",
  renderMenu: function() {
    this.$el.empty().append(LI({ "class": "xview" }, DIV(LABEL(T("l_sort_by"), ": "), this.selSort = SELECT({ "class": "pull-right" }, OPTION({ value: "-ts_data" }, T("l_time_changed_on")), OPTION({ value: "name" }, T("l_name")), OPTION({ value: "client_id" }, T("l_device"))))), LI({ "class": "xview" }, DIV(LABEL(T("l_page_size"), ": "), this.selPageSize = SELECT({ "class": "pull-right" }, OPTION({ value: 5 }, 5), OPTION({ value: 20 }, 20), OPTION({ value: 50 }, 50), OPTION({ value: 100 }, 100), OPTION({ value: 200 }, "200!!"), OPTION({ value: 500 }, "500!!!")))), LI({ "class": "xview" }, DIV(LABEL(T("l_device_filter"), ": "), this.selClientFilter = SELECT({ "class": "pull-right" }, OPTION({ value: 1 }, T("l_devices_all")), OPTION({ value: 2 }, T("l_device_this"))))));
    this.selSort.value = App.store.get("ui.list.sortby") || "-ts_data";
    this.selPageSize.value = App.store.get("ui.list.pagesize") || "50";
    this.selClientFilter.value = App.store.get("ui.list.clientfilter") || "1";
    $$3(this.selSort).change(() => {
      App.store.set("ui.list.sortby", this.selSort.value);
      this.parent.reload();
    });
    $$3(this.selPageSize).change(() => {
      const size = parseInt(this.selPageSize.value);
      App.store.set("ui.list.pagesize", size);
      this.parent.reload(true);
    });
    $$3(this.selClientFilter).change(() => {
      App.store.set("ui.list.clientfilter", this.selClientFilter.value);
      this.parent.reload(true);
    });
  }
});
const SievesPageMenu = View$1.ContextMenu.extend({
  name: "SievesPageMenu",
  actions: {
    "menu topage": { fn: "action_topage" }
  },
  action_topage: function(n) {
    this.parent.navToPage(parseInt(n));
    this.hide();
  },
  renderMenu: function() {
    const { limit, nPages, total_count } = this.parent.collection.info();
    this.$el.empty().append(_$2.map(_$2.range(0, nPages), function(n) {
      return LI(A({
        "data-action": "menu topage",
        "data-action-param": n
      }, n * limit + 1 + " - " + Math.min((n + 1) * limit, total_count)));
    })).css({
      maxHeight: 600,
      overflowY: "auto",
      fontSize: ".8em"
    });
  }
});
var Sieves = View$1.Entities.extend({
  name: "Sieves",
  actions: {
    "action_be_action_add": { fn: "action_be_action_add" },
    "action_be_action_remove": { fn: "action_be_action_remove" },
    "action_be_config": { fn: "action_be_config" },
    "action_be_device": { fn: "action_be_device" },
    "action_be_schedule": { fn: "action_be_schedule" },
    "action_be_switch_on": { fn: "action_be_switch_on" },
    "action_be_switch_off": { fn: "action_be_switch_off" },
    "action_global_actions": { fn: "action_global_actions" },
    "action_global_rules": { fn: "action_global_rules" },
    "sieve c4c": { fn: "action_check_for_changes" },
    "sieve client menu": { fn: "action_client_menu" },
    "sieve context menu": { fn: "action_context_menu" },
    "sieve del": { fn: "action_del" },
    "sieve del permanent": { fn: "action_del_permanent" },
    "sieve label apply": { fn: "action_apply_label" },
    "sieve list menu": { fn: "action_list_menu" },
    "sieve log menu": { fn: "action_log_menu" },
    "sieve mark_read": { fn: "action_mark_read" },
    "sieve mark_unread": { fn: "action_mark_unread" },
    "sieve nav next": { fn: "action_next" },
    "sieve nav prev": { fn: "action_prev" },
    "sieve nav topage menu": { fn: "action_topage_menu" },
    "sieve restore": { fn: "action_restore" },
    "sieve schedule menu": { fn: "action_schedule_menu" },
    "sieve select all": { fn: "action_select_all" },
    "sieve select none": { fn: "action_select_none" },
    "sieve select read": { fn: "action_select_read" },
    "sieve select unread": { fn: "action_select_unread" },
    "sieve switch": { fn: "action_switch_on_off" },
    "sieve sync": { fn: "action_sync" },
    "sieve view": { fn: "action_view", doc: "View sieve details" }
  },
  reloadImmediately: true,
  syncState: {
    syncing: false
  },
  events: {
    "click .xselect-all": "event_check"
  },
  ViewClass: SieveDetail,
  action_apply_label: function(id2, target) {
    const models = this.getSelectedModels();
    Msg.info("l_loading");
    async$2.eachSeries(models, function(model, callback) {
      let tags = model.get("tags");
      if (tags) {
        if (tags.indexOf(id2) >= 0) {
          return callback();
        }
        tags += "," + id2;
      } else {
        tags = id2;
      }
      model.save("tags", tags, {
        patch: true,
        error: function() {
          callback("e_req");
        },
        success: function() {
          callback();
        }
      });
    }, function(err) {
      if (err) {
        Msg.error("e_req");
      } else {
        Msg.reset();
      }
    });
  },
  action_be_action_add: function() {
    const sieve = new Backbone$3.Model();
    const actions = new Model$2.SieveActions(null, { parent: sieve });
    const actionEditor = new SieveActionsEditor({
      actions,
      sieve,
      parent: this
    }).render();
    const modal = new View$1.SaveDiscardModal({
      name: "BatchEdit$ActionAddModal",
      parent: this,
      title: "Add Actions - Batch Editor",
      view: actionEditor
    });
    modal.on("save", async () => {
      const ids = this.getSelectedIds();
      const actions2 = actionEditor.getPosts();
      try {
        for (let i2 = 0; i2 < actions2.length; i2 += 1) {
          const doc = actions2[i2].toJSON();
          await Api.api("/batch/sieves/actions", "POST", { ...doc, ids });
        }
        modal.remove();
      } catch (e) {
        console.error(e);
        Msg.error(`Please try again later - error in batch action ${e.message || e.msg}`);
      }
    });
    modal.on("discard", function() {
      modal.remove();
    });
    modal.show();
    setTimeout(() => actionEditor.$(".dropdown-toggle").click(), 10);
  },
  action_be_action_remove: function() {
    const modal = new View$1.PromptModal({
      name: "BatchEdit$ActionRemoveModal",
      parent: this.getRoot(),
      title: "Remove Actions - Batch Edit",
      a_save: "Remove",
      msg: "This action will remove all actions for selected monitors. Remove all actions?"
    });
    modal.on("save", async () => {
      const ids = this.getSelectedIds();
      try {
        await Api.api("/batch/sieves/actions", "PUT", { ids, state: C.STATE_DEL });
        modal.remove();
      } catch (e) {
        console.error(e);
        Msg.error(`Please try again later - error in batch action ${e.message || e.msg}`);
      }
    });
    modal.show();
  },
  action_be_config: function() {
    const selectedModels = this.getSelectedModels();
    const model = new Model$2.Sieve({
      content_type: C.TYPE_HTML,
      config: selectedModels[0].get("config").clone(),
      uri: selectedModels[0].get("uri")
    });
    openConfigEditor(model, "Config - Batch Edit", async (modal) => {
      Msg.info("l_loading");
      modal.remove();
      const ids = this.getSelectedIds();
      const config = model.toJSON().config;
      try {
        await Api.api("/batch/sieves", "PUT", { ids, config });
        Msg.reset();
      } catch (e) {
        console.error(e);
        Msg.error(`Please try again later - error in batch action ${e.message || e.msg}`);
      }
    });
  },
  action_be_device: function() {
    const selectedModels = this.getSelectedModels();
    if (selectedModels.length == 0) {
      return;
    }
    const modelOne = selectedModels[0];
    const model = new Model$2.Sieve({
      content_type: C.TYPE_HTML,
      client_id: modelOne.get("client_id")
    });
    const clientSelector = new ViewClients.ClientSelector({ model });
    const view = new View$1.Base({
      el: DIV({ style: "margin: 5px;" }, clientSelector.el)
    });
    const modal = new View$1.SaveDiscardModal({
      name: "BatchEdit$Device",
      parent: this,
      title: "Device - Batch Editor",
      view
    });
    modal.on("save", async () => {
      try {
        const ids = this.getSelectedIds();
        const client_id = model.get("client_id");
        const proxy_id = model.get("proxy_id");
        const session_id = model.get("session_id");
        await Api.api("/batch/sieves", "PUT", { ids, client_id, proxy_id, session_id });
        modal.remove();
      } catch (e) {
        console.error(e);
        Msg.error(`Please try again later - error in batch action ${e.message || e.msg}`);
      }
    });
    modal.on("discard", function() {
      modal.remove();
    });
    modal.show();
  },
  action_be_schedule: function() {
    const model = new Backbone$3.Model({ schedule: new Model$2.Schedule() });
    const scheduleEditor = new SieveScheduleEditor({
      model,
      parent: this
    }).render();
    const modal = new View$1.SaveDiscardModal({
      name: "BatchEdit$ActionAddModal",
      parent: this,
      title: "Schedule - Batch Editor",
      view: scheduleEditor
    });
    modal.on("save", async () => {
      const ids = this.getSelectedIds();
      const schedule = model.toJSON().schedule;
      try {
        await Api.api("/batch/sieves", "PUT", { ids, schedule });
        modal.remove();
      } catch (e) {
        console.error(e);
        Msg.error(`Please try again later - error in batch action ${e.message || e.msg}`);
      }
    });
    modal.on("discard", function() {
      modal.remove();
    });
    modal.show();
  },
  action_be_switch_on: function() {
    const ids = this.getSelectedIds();
    const modal = new View$1.PromptModal({
      name: "BatchEdit$ActionRemoveModal",
      parent: this.getRoot(),
      title: "Switch On Monitors - Batch Edit",
      a_save: "Switch ON",
      msg: `${ids.length} monitors will be switched ON.`
    });
    modal.on("save", async () => {
      try {
        await Api.api("/batch/sieves", "PUT", { ids, state: C.STATE_READY });
        modal.remove();
      } catch (e) {
        console.error(e);
        Msg.error(`Please try again later - error in batch action ${e.message || e.msg}`);
      }
    });
    modal.show();
  },
  action_be_switch_off: function() {
    const ids = this.getSelectedIds();
    const modal = new View$1.PromptModal({
      name: "BatchEdit$ActionRemoveModal",
      parent: this.getRoot(),
      title: "Switch Off Monitors - Batch Edit",
      a_save: "Switch OFF",
      msg: `${ids.length} monitors will be switched OFF.`
    });
    modal.on("save", async () => {
      try {
        await Api.api("/batch/sieves", "PUT", { ids, state: C.STATE_PAUSED });
        modal.remove();
      } catch (e) {
        console.error(e);
        Msg.error(`Please try again later - error in batch action ${e.message || e.msg}`);
      }
    });
    modal.show();
  },
  action_global_actions: function() {
    showGlobalActionEditor();
  },
  action_global_rules: function() {
    showGlobalRuleEditor();
  },
  action_run_cloud_sieves: async function(models) {
    Msg.info("l_loading");
    const cloudIds = _$2.pluck(_$2.filter(models, function(model) {
      return model.get("client_id") === C.CLIENT_WEB;
    }), "id");
    if (cloudIds.length > 0) {
      try {
        await Api.utils("/sieve/run", "POST", { ids: cloudIds });
        Msg.info("m_started_check_for_changes");
      } catch (err) {
        console.error("Could not check for changes", err);
        Msg.error("m_check_for_changes_failed");
      }
    }
  },
  action_check_for_changes: async function(target) {
    const models = this.getSelectedModels();
    if (!Supports.agents.local) {
      this.action_run_cloud_sieves(models);
      return;
    }
    const ids = _$2.pluck(_$2.filter(models, function(model) {
      return model.get("client_id") !== C.CLIENT_WEB;
    }), "id");
    serviceProxy.service.checkNow(ids);
    if (models.length > ids.length) {
      Msg.info("m_check_local_only");
    }
    if (!await serviceProxy.isActive()) {
      Msg.error("m_checks_paused");
    }
  },
  action_client_menu: function(id2, target) {
    this.clientMenu || (this.clientMenu = new SieveClientMenu({
      parent: this,
      collection: this.collection
    }));
    this.clientMenu.toggle(id2, target.nodeName == "I" ? target.parentNode : target);
  },
  action_context_menu: function(id2, target) {
    this.contextMenu || (this.contextMenu = new SieveContextMenu({
      parent: this,
      collection: this.collection
    }));
    this.contextMenu.toggle(id2, target.nodeName == "I" ? target.parentNode : target);
  },
  action_del: function() {
    const models = this.getSelectedModels();
    async$2.map(models, (model, callback) => {
      model.save("state", C.STATE_DISCARD, {
        patch: true,
        error: function() {
          callback(new Error("sieve:del:err"));
        },
        success: function() {
          model.collection.remove(model);
          callback();
        }
      });
    }, (err) => {
      if (err) {
        Msg.error("sieve:del:err");
      } else {
        const value = models.length;
        const msg = i18n.translate("m_del_item").ifPlural(value, T("m_del_items")).fetch(value);
        Msg.info(msg);
      }
    });
    return true;
  },
  action_del_permanent: function() {
    const models = this.getSelectedModels();
    async$2.eachLimit(models, 5, function(model, callback) {
      model.destroy({
        error: function() {
          callback(new Error("sieve:del:err"));
        },
        success: function() {
          callback();
        }
      });
    }, (err) => {
      if (err) {
        Msg.error("sieve:del:err");
      } else {
        Msg.info("Permanently deleted selected items.");
      }
    });
  },
  action_list_menu: function(param, target) {
    this.listMenu || (this.listMenu = new SievesListMenu({
      parent: this
    }));
    this.listMenu.toggle("list", $$3(target).parent(".btn-group")[0]);
  },
  action_log_menu: function(id2, target) {
    this.logMenu || (this.logMenu = new LogMenu({
      parent: this,
      collection: this.collection
    }));
    this.logMenu.toggle(id2, target ? target : this.getRow(id2).$el.find(".xsieve-ts-data")[0]);
  },
  action_mark_read: function() {
    const models = this.getSelectedModels();
    async$2.map(models, function(model, callback) {
      model.save({
        ts_view: dateToDBFormat(Date.now())
      }, {
        patch: true,
        error: function() {
          callback(new Error("sieve:update:err"));
        },
        success: function() {
          callback();
        }
      });
    }, function(err) {
      if (err) {
        Msg.error("sieve:update:err");
      }
    });
  },
  action_mark_unread: async function() {
    const models = this.getSelectedModels();
    for (let i2 = 0; i2 < models.length; i2 += 1) {
      let model = models[i2], ts_view = dateToDBFormat(0);
      await Api.api(`/sieves/${model.id}`, "PATCH", { ts_view });
      model.set({ ts_view });
    }
  },
  action_next: function() {
    let { currentPage, nPages } = this.collection.info();
    if (currentPage >= nPages - 1)
      return;
    this.navToPage(currentPage + 1);
  },
  action_prev: function() {
    let { currentPage } = this.collection.info();
    if (currentPage == 0)
      return;
    this.navToPage(currentPage - 1);
  },
  action_topage_menu: function(param, target) {
    this.pageMenu || (this.pageMenu = new SievesPageMenu({
      parent: this
    }));
    this.pageMenu.toggle("list", target);
  },
  action_restore: async function() {
    const models = this.getSelectedModels();
    let sieveConstraint = {};
    try {
      sieveConstraint = await checkSieveConstraint(models.length);
    } catch (e) {
      console.error(e);
      sieveConstraint = {
        isOverLimit: false
      };
    }
    if (sieveConstraint.isOverLimit) {
      Msg.error("m_monitor_limit");
      return;
    }
    async$2.map(models, function(model, callback) {
      model.save("state", C.STATE_READY, {
        patch: true,
        error: function() {
          callback(new Error("sieve:restore:err"));
        },
        success: function() {
          model.collection.remove(model);
          callback();
        }
      });
    }, (err) => {
      if (err) {
        Msg.error("sieve:restore:err");
      } else {
        Msg.info("m_restored_from_trash");
      }
    });
  },
  action_schedule_menu: function(id2, target) {
    this.scheduleMenu || (this.scheduleMenu = new ScheduleMenu({
      parent: this,
      collection: this.collection
    }));
    this.scheduleMenu.toggle(id2, target);
  },
  action_select_all: function() {
    this._select(_$2.identity, true);
  },
  action_select_none: function() {
    this._select(_$2.identity, false);
  },
  action_select_read: function() {
    this.action_select_none();
    this._select(function(view) {
      return view.model.isRead();
    }, true);
  },
  action_select_unread: function() {
    this.action_select_none();
    this._select(function(view) {
      return !view.model.isRead();
    }, true);
  },
  action_switch_on_off: function(id2) {
    const model = this.collection.get(id2);
    const state = model.get("state");
    const toggledState = state == C.STATE_READY ? C.STATE_PAUSED : C.STATE_READY;
    Msg.start("sieve:save", { info: "l_saving" });
    model.save(null, {
      data: { state: toggledState },
      patch: true,
      err: function(err, res2) {
        Msg.stop("sieve:save", { error: "e_req" });
      },
      success: function() {
        Msg.stop("sieve:save");
        model.set("state", toggledState);
      }
    });
  },
  action_sync: async function() {
    if (!Supports.agents.local)
      return;
    Msg.info("l_syncing");
    let complete = false;
    try {
      await serviceProxy.SyncMan.sync(true);
      complete = true;
      Msg.reset();
    } catch (err) {
      console.error(JSON.stringify(err));
      try {
        complete = true;
        await serviceProxy.service.initSync();
      } catch (err2) {
        console.error(JSON.stringify(err2));
        Msg.error(err2.msg || err2.message || JSON.stringify(err2));
      }
    }
    setTimeout(function() {
      if (!complete) {
        Msg.info("l_syncing_wait");
      }
    }, 5e3);
  },
  action_view: function(id2) {
    let base2 = this._getBasePath();
    let path = base2;
    if (!this.modelView || this.modelView.model.id != id2) {
      path += `${id2}.id`;
    }
    let queryStr = lib.stringify(this.route.query);
    if (queryStr.length > 0) {
      path += `?${queryStr}`;
    }
    push$1(path);
  },
  event_check: function(e) {
    this._select(_$2.identity, e.target.checked);
  },
  _getBasePath() {
    let { module, team: team2, prefix, data } = this.route;
    let base2 = `/w/${team2}/${module}/${prefix}/`;
    if (data) {
      base2 = base2 + `${data}.d/`;
    }
    return base2;
  },
  _select: function(selector2, selected) {
    _$2.each(this.views, function(view) {
      if (selector2(view)) {
        view.setSelected(selected);
      }
    });
  },
  addOne: function(model, top) {
    if (!this.$list)
      return;
    const view = new SieveRow({ model, parent: this });
    const modelIndex = this.collection.indexOf(model);
    this.$list[top === true || modelIndex == 0 ? "prepend" : "append"](view.render().el);
    return view;
  },
  close_edit: function() {
    this.optsPanel.remove();
    this.opts = null;
  },
  recentFetchAndShow: function(id2) {
    const tsModMax = this.collection.length > 0 ? this.collection.max((model) => new Date(model.get("ts_mod")).valueOf()).get("ts_mod") : new Date(0).toISOString();
    const tCollection = new Model$2.Sieves();
    Msg.start("fetch", { info: "l_loading" });
    tCollection.fetch({
      data: _$2.extend({
        "ts_mod.gt": tsModMax,
        "_opt": {}
      }, getQuery(this.route)),
      success: () => {
        Msg.stop("fetch");
        this.collection.add(tCollection["models"], { merge: true, at: 0 });
      }
    });
  },
  async fetchAndShow(route2, force = false) {
    const limit = App.store.get("ui.list.pagesize") || 50;
    let oldRoute = this.route;
    let routeKeys = ["team", "prefix", "data", "query"];
    let reloadList = force || !oldRoute || routeKeys.filter((key) => !_$2.isEqual(route2[key], oldRoute[key])).length > 0;
    this.route = { ...route2 };
    if (reloadList) {
      Msg.start("fetch", { info: "l_loading" });
      this.collection.limit = limit;
      let currentPage = parseInt(route2.query.page || "1") - 1;
      await this.collection.goto(currentPage, {
        sort: false,
        data: _$2.extend({
          _opt: {
            order: [this.getSortField()],
            limit,
            "a": "a"
          }
        }, getQuery(this.route)),
        success: (collection, resp, options) => {
          _$2.each(options.previousModels, function(model) {
            model.trigger("remove");
          });
        }
      });
      Msg.stop("fetch");
      this.onSelectionChange();
      if (this.collection.length == 0) {
        this.renderEmpty();
      } else {
        this.removeEmpty();
      }
      this.el.scrollIntoView();
    }
    if (route2.id) {
      this.show(route2.id);
    } else {
      this.removeModelView();
    }
  },
  reload(resetCurrentPage) {
    if (resetCurrentPage && this.route.query.page > 1) {
      push$1(this._getBasePath());
    } else {
      this.fetchAndShow(this.route, true);
    }
  },
  getRow: function(id2) {
    return _$2.find(this.views, function(view) {
      return view.model.id == id2;
    });
  },
  getSelectedIds: function() {
    return _$2.chain(this.children).select(function(child) {
      return child.isSelected && child.isSelected();
    }).map(function(child) {
      return child.model.id;
    }).value();
  },
  getSelectedModels: function() {
    return _$2.chain(this.children).select((child) => {
      return child.isSelected && child.isSelected();
    }).map((child) => {
      return this.collection.get(child.model.id);
    }).value();
  },
  getSortField: function() {
    const field = App.store.get("ui.list.sortby") || "-ts_data";
    this.collection.sortField = field;
    if (field == "name" && Supports.agents.local) {
      return "name nocase";
    }
    return field;
  },
  navToPage: function(n) {
    let base2 = this._getBasePath();
    if (n == 0 || !n) {
      let query = { ...this.route.query };
      delete query.page;
      let queryStr = lib.stringify(query);
      push$1(`${base2}?${queryStr}`);
    } else {
      let query = lib.stringify({ ...this.route.query, page: n + 1 });
      push$1(`${base2}?${query}`);
    }
  },
  labelAddOne: function(model) {
    this.$labelList.append(LI(A({
      "href": "#",
      "data-action": "sieve label apply",
      "data-action-param": model.id
    }, model.get("name"))));
  },
  labelRemoveOne: function(model) {
  },
  labelReset: function() {
    this.$labelList.empty();
    this.labels.each(this.labelAddOne);
  },
  onUserStateChange: function(data) {
    const oldError = this.errorUnreadModel.get("error");
    const oldUnread = this.errorUnreadModel.get("unread");
    const { error, unread, sync } = data;
    this.errorUnreadModel.set(data);
    let { currentPage } = this.collection.info();
    if (oldError < error && this.route.prefix == "error" && currentPage == 0) {
      this.recentFetchAndShow();
    }
    if (oldUnread < unread && this.route.prefix == "unread" && currentPage == 0) {
      this.recentFetchAndShow();
    }
    sync && this.onSyncStateUpdate(sync);
  },
  onSyncStateUpdate(sync) {
    this.syncState = sync;
    setTimeout(() => {
      const cl = this.elRefreshButton.children[0].classList;
      if (this.syncState.syncing && !cl.contains("fa-spin")) {
        cl.add("fa-spin");
      } else {
        cl.remove("fa-spin");
      }
    }, 200);
  },
  onSelectionChange: function() {
    const n = this.getSelectedModels().length;
    if (n > 0) {
      $$3(this.elTbar).addClass("xselected");
    } else {
      $$3(this.elTbar).removeClass("xselected");
    }
  },
  onSieveInsertDebounced: _$2.debounce(function() {
    this.reload();
    this.reloadImmediately = true;
  }, 2 * 1e3),
  onSieveInsert(e) {
    if (this.reloadImmediately) {
      this.reload();
      this.reloadImmediately = false;
    } else {
      this.onSieveInsertDebounced();
    }
  },
  onSieveUpdate: function(e) {
    if (e.op == "I") {
      if (!this.collection.get(e.id)) {
        this.onSieveInsert();
      }
    }
  },
  onSort: function() {
    const newKeys = this.collection.pluck("id");
    const oldKeys = _$2.keys(this.views);
    if (!_$2.isEqual(newKeys, oldKeys)) {
      this.collection.each(function(model) {
        const view = this.views[model.id];
        view.reattach();
      }, this);
    }
  },
  postInit: function(options) {
    this.listenTo(this.collection, "sort", this.onSort);
    this.listenTo(this.collection, "sync", this.updatePageInfo);
    this.listenTo(this.collection, "prop:select", this.onSelectionChange);
    this.route = {};
    this.clients = options.clients;
    this.labels = options.labels;
    this.labels.on("add", this.labelAddOne);
    this.labels.on("remove", this.labelRemoveOne);
    this.labels.on("reset", this.labelReset);
    this.listenTo(instance$1Q, "sieves", this.onSieveUpdate);
    this.errorUnreadModel = new Backbone$3.Model();
    this.listenTo(instance$1Q, "user_states", this.onUserStateChange);
  },
  removeOne: function(model) {
    View$1.Entities.prototype.removeOne.call(this, model);
    if (this.model && this.model.id == model.id) {
      this.removeModelView();
    }
    model.trigger("remove");
  },
  renderBase: function() {
    params.subscribe(this.renderTBar);
    let list;
    let empty2;
    this.$el.append(this.renderTBar(), TABLE({ "class": "xlist", "cellpadding": 0, style: "box-shadow: 3px 3px 3px #ccc" }, COLGROUP(COL({ style: "width:28px" }), COL({ style: "width:28px" }), COL({ style: "width:304px; padding: 0 10px;" }), COL({ style: "" }), COL({ style: "width:72px; padding: 0 10px;" }), COL({ style: "width:72px" }), COL({ style: "width:42px" }), COL({ style: "width:40px" })), list = TBODY()), empty2 = DIV());
    this.$empty = $$3(empty2);
    this.$list = $$3(list);
  },
  renderTBar() {
    let $params = get_store_value(params) || {};
    let team2 = $params.team;
    let elExport;
    const labelList = UL({
      "class": "dropdown-menu",
      "style": "overflow-y:auto;max-height:" + ($$3(window).height() - 120) + "px"
    });
    let route2 = this.route;
    let isLocal = Supports.agents.local;
    let elTbar = DIV({
      "class": "xtbar xvbar-margin xalt" + (isLocal ? " xlocal" : ""),
      context: (route2 && route2.prefix) + (isLocal ? " local" : " cloud")
    }, DIV({ "class": "btn-group" }, INPUT({
      "class": "xselect-all",
      "type": "checkbox",
      "style": "margin: 0 6px 0 0;"
    }), BUTTON({
      "type": "button",
      "class": "dropdown-toggle xbtn-light",
      "data-toggle": "dropdown"
    }, SPAN({ "class": "caret" }), SPAN({ "class": "sr-only" }, "Dropdown Toggle")), UL({ "class": "dropdown-menu", "role": "menu" }, LI(A({ "href": "#", "data-action": "sieve select all" }, T("l_all"))), LI(A({ "href": "#", "data-action": "sieve select none" }, T("l_none"))), LI(A({ "href": "#", "data-action": "sieve select read" }, T("l_read"))), LI(A({ "href": "#", "data-action": "sieve select unread" }, T("l_unread"))))), BUTTON({
      "data-action": "sieve c4c",
      "class": "btn btn-default",
      "context": "selected local notrash",
      "title": T("a_check_changes")
    }, I({ "class": "im-run" })), BUTTON({
      "data-action": "sieve restore",
      "class": "btn btn-default",
      "context": "trash"
    }, T("a_restore")), USER.account_id ? DIV({
      "class": "btn-group",
      context: "selected all notrash"
    }, A({
      "data-action": "sieve mark_read",
      "class": "btn btn-default",
      "context": "selected all notrash",
      "title": T("a_mark_read")
    }, I({ "class": "fa fa-check" })), BUTTON({
      "class": "btn btn-default dropdown-toggle",
      "data-toggle": "dropdown",
      style: "min-width: 20px"
    }, I({ "class": "caret" })), UL({ "class": "dropdown-menu", "role": "menu" }, LI(A({
      tabindex: -1,
      href: "#",
      "data-action": "sieve mark_unread"
    }, T("Mark as unread"))))) : BUTTON({
      "data-action": "sieve mark_read",
      "class": "btn btn-default",
      "context": "selected all notrash",
      "title": T("a_mark_read")
    }, I({ "class": "fa fa-check" })), BUTTON({
      "data-action": "sieve del",
      "class": "btn btn-default",
      "context": "selected all notrash",
      "title": T("a_move_to_trash")
    }, I({ "class": "im-trash" })), BUTTON({
      "data-action": "sieve del permanent",
      "class": "btn btn-default",
      "context": "trash"
    }, T("a_del_permanent")), DIV({
      "class": "btn-group",
      "context": "selected all notrash",
      "title": T("l_label")
    }, BUTTON({ "class": "btn btn-default dropdown-toggle", "data-toggle": "dropdown" }, I({ "class": "fa fa-tags" }), " ", SPAN({ "class": "caret" })), labelList), this.elRefreshButton = BUTTON({
      "class": "btn btn-default",
      "context": "all nocloud",
      "data-action": "sieve sync",
      "title": T("l_sync")
    }, I({ "class": "fa fa-refresh }" })), DIV({
      "class": "btn-group",
      "context": "all"
    }, BUTTON({ "class": "btn btn-default dropdown-toggle", "data-toggle": "dropdown" }, I({ "class": "fa fa-bars" }), " ", SPAN({ "class": "caret" })), UL({ "class": "dropdown-menu", "role": "menu" }, LI({ "class": "dropdown-submenu" }, A({ href: "javascript:void(0);" }, T("a_export")), elExport = UL({ "class": "dropdown-menu", "role": "menu" }, LI(A({ href: "#/w/export/json/", "data-type": "json" }, "JSON")), LI(A({ href: "#/w/export/csv/", "data-type": "csv" }, "CSV")))), LI({ "class": "dropdown-submenu" }, A({ href: "javascript:void(0);" }, T("a_import")), UL({ "class": "dropdown-menu", "role": "menu" }, LI(A({ href: `#/w/${team2}/import/json/` }, "JSON")), LI(A({ href: `#/w/${team2}/import/csv/` }, "CSV")))), LI(A({ href: `#/w/${team2}/macros/` }, T("Macros"))), LI(A({ href: `#/w/${team2}/profiles/` }, T("Profiles"))), LI(A({ href: `#/w/${team2}/proxies/` }, T("Proxies"))), LI(A({ href: `#/w/${team2}/tpls/all/` }, T("l_sieve_tpl_list"))), LI({ "class": "divider" }), LI(A({ "href": "javascript:void(0);", "data-action": "action_global_actions" }, T("Global Actions"))), LI(A({ "href": "javascript:void(0);", "data-action": "action_global_rules" }, T("Global Conditions"))), "")), DIV({
      "class": "btn-group mr0",
      "context": "selected all"
    }, BUTTON({ "class": "btn btn-default dropdown-toggle", "data-toggle": "dropdown" }, `${T("a_bulk_edit")} `, SPAN({ "class": "caret" })), !USER.id ? UL({ "class": "dropdown-menu", "role": "menu" }, LI(A({ "href": "/ui/settings.html#general" }, T("Sign in")))) : UL({ "class": "dropdown-menu", "role": "menu" }, LI({ "class": "dropdown-submenu" }, A({ href: "#" }, "Actions"), UL({ "class": "dropdown-menu", "role": "menu" }, LI(A({ "href": "#", "data-action": "action_be_action_add" }, "Add")), LI({ "class": "divider" }), LI(A({ "href": "#", "data-action": "action_be_action_remove", "style": "color: red" }, "Remove All")))), LI(A({ "href": "#", "data-action": "action_be_config" }, T("Config"))), LI(A({ "href": "#", "data-action": "action_be_device" }, T("l_device"))), LI(A({ "href": "#", "data-action": "action_be_schedule" }, T("l_schedule"))), LI(A({ "href": "#", "data-action": "action_be_switch_on" }, T("Switch ON"))), LI(A({ "href": "#", "data-action": "action_be_switch_off" }, T("Switch OFF"))), "")), DIV({ "class": "btn-group right xoptional" }, BUTTON({
      "class": "btn btn-default",
      "data-action": "sieve list menu"
    }, I({ "class": "fa fa-cog" }), " ", SPAN({ "class": "caret" }))), UL({ "class": "pagination pagination-sm right", "style": "margin: 0 5px 0 0" }, LI(A({ "href": "", "data-action": "sieve nav topage menu" }, this.pageInfo = SPAN(T("l_loading")), " ", I({ "class": "fa fa-caret-down" }))), this.pagePrev = LI(A({ "href": "", "data-action": "sieve nav prev" }, I({ "class": "fa fa-chevron-left" }))), this.pageNext = LI(A({ "href": "", "data-action": "sieve nav next" }, I({ "class": "fa fa-chevron-right" })))));
    this.$labelList = $$3(labelList);
    elExport.onclick = (e) => {
      e.preventDefault();
      let path = location.hash.slice(1);
      if (path.startsWith(`/w/${team2}/export/`)) {
        return;
      }
      let { prefix, data, id: id2, query } = this.route;
      let exportQueryData = { prefix, data, id: id2, query };
      push$1(`/w/${team2}/export/${e.target.dataset.type}/${lib.stringify(exportQueryData)}.d/`);
    };
    if (this.elTbar) {
      elTbar.className = this.elTbar.className;
      this.elTbar.replaceWith(elTbar);
    }
    this.elTbar = elTbar;
    this.updatePageInfo();
    this.labelReset();
    return this.elTbar;
  },
  removeEmpty: function() {
    this.$empty.empty();
  },
  renderEmpty: function() {
    App.sieves.reset();
    const isInbox = this.route.prefix == "all";
    this.$empty.empty().append(isInbox && !Supports.agents.local ? DIV({ "class": "pt-4" }, P({ style: "font-size: 1em" }, "This is webapp's Watchlist. It contains list of all monitors. ", "Start monitoring web by adding a monitor using the Add button. ", "Install Distill's browser extension to get the fastest web monitoring experience: ", A({ href: "https://distill.io/apps/web-monitor" }, "download extension."), BR(), A({ "class": "mt3", href: "https://distill.io/help/watchlist" }, "Learn More"))) : H4("No monitor found."));
  },
  renderModelView: function(model, view) {
    const row = this.getRow(model.id);
    row && row.showDetail(view.render());
  },
  show: function(id2) {
    if (this.model) {
      if (this.model.id == id2) {
        return;
      }
      this.removeModelView();
    }
    this.model = this.collection.get(id2);
    if (this.model) {
      return this.showModelView(this.model);
    } else {
      return this.show404();
    }
  },
  show404: function() {
    Msg.error("Monitor not found");
    return false;
  },
  showDefault: function() {
    this.removeModelView();
  },
  showModelView: function(model) {
    model.markRead();
    return Sieves.__super__.showModelView.call(this, model);
  },
  updatePageInfo: function() {
    const coll = this.collection;
    const { currentPage, offset, nPages, total_count } = coll.info();
    const { length } = coll;
    this.pageInfo.textContent = SPRINTF("m_start_end_of_total", offset + (length > 0 ? 1 : 0), offset + length, total_count);
    $$3(this.pagePrev)[currentPage <= 0 ? "addClass" : "removeClass"]("disabled");
    $$3(this.pageNext)[currentPage + 1 >= nPages ? "addClass" : "removeClass"]("disabled");
  }
});
var ViewSieve = {
  SieveActionsEditor,
  Sieves,
  SieveOptions,
  SieveScheduleEditor,
  TagsEditor
};
function dateToDBFormat(date) {
  return moment$2(date).format();
}
const STAGE_PICK_FILE = 1;
const STAGE_MARK_DATA = 2;
const STAGE_OPTIONS = 3;
const STAGE_IMPORT = 4;
const KNOWN_COLUMNS = [
  "name",
  "url",
  "labels",
  "content_type",
  "datasource_id"
];
class CSVMarker extends Base$3 {
  init() {
    this.state.loading = true;
    setTimeout(() => {
      const { result } = this.state;
      const fields = result.meta.fields;
      const normalizedFields = fields.map((field) => field.toLowerCase());
      const rows = result.data;
      result.data;
      const index2 = {};
      for (let i2 = 1; i2 < fields.length; i2 += 1) {
        const field = fields[i2];
        if (field in KNOWN_COLUMNS) {
          index2[field] = i2;
        }
      }
      setTimeout(() => {
        this.setState({
          index: index2,
          fields,
          normalizedFields,
          rows,
          loading: false
        });
      }, 200);
    }, 50);
    this.inputFields = {};
  }
  getInputFields() {
    const inputFields = {};
    const selects = this.el.querySelectorAll("select");
    for (let i2 = 0; i2 < selects.length; i2 += 1) {
      const val = selects[i2].value;
      if (val && val.length > 0) {
        inputFields[val] = this.state.fields[i2];
      }
    }
    return inputFields;
  }
  getRows() {
    const fields = this.getInputFields();
    const rows = this.state.result.data;
    return rows.map((row) => {
      const newRow = {};
      for (const name in fields) {
        newRow[name] = row[fields[name]];
      }
      return newRow;
    });
  }
  onSelectHeader(e, index2) {
  }
  createTpl({ loading: loading2, index: index2, fields, normalizedFields, rows }) {
    return loading2 ? html`Loading...` : html`
      <div class='page-header'>
        <h3>
          Data
          <small>
            Column headers show identified column attributes. You can edit them to manually specify or correct them.
          </small>
        </h3>
      </div>
      <div style='max-height: 200px; overflow-y: scroll;'>
        <table>
        <thead style=''>
          <tr style='border-top: solid 1px #ccc;'>
            ${normalizedFields.map((field, index3) => html`
            <th style='max-width: 150px; padding: 5px; border: solid 1px #ccc;'>
              <div><select @change=${(e) => this.onSelectHeader(e, index3)}>
                <option></option>
                ${KNOWN_COLUMNS.map((col) => html`<option value='${col}' ?selected=${field == col}>${col}</option>`)}
              </select></div>
            </th>`)}
          </tr>
        </thead>
        <tbody>
          ${rows.map((row) => html`
            <tr style='border-bottom: solid 1px #ccc; white-space: nowrap;'>
              ${fields.map((field) => html`<td style='max-width: 200px; overflow: hidden; padding: 5px; border: solid 1px #ccc; overflow-x: scroll' title=${row[field]}>${row[field]}</td>`)}
            </tr>
          `)}
        </tbody>
      </table>
    </div>

    `;
  }
}
class CommonOptions extends Base$3 {
  init() {
    this.model = new Model$2.Sieve();
    this.actions = new Model$2.SieveActions(null, {});
    this.actionEditor = new ViewSieve.SieveActionsEditor({
      actions: this.actions
    }).render();
    this.clientSelector = new ViewClients.ClientSelector({
      model: this.model
    });
    this.scheduleEditor = new ViewSieve.SieveScheduleEditor({
      model: this.model
    }).render();
    this.tagsEditor = new ViewSieve.TagsEditor({
      model: this.model
    }).render();
  }
  getOptions() {
    return { ...this.model.toJSON(), actions: this.actions.toJSON() };
  }
  createTpl({ inputFields }) {
    return html`
      <div class='page-header'>
        <h3>
          Options
        </h3>
      </div>

      <div class='form-horizontal'>

        <div class='form-group'>
          <label class='control-label col-md-2'>Device</label>
          <div class='col-md-10'>
            ${this.clientSelector.el}
          </div>
        </div>

        <div class='form-group'>
          <label class='control-label col-md-2'>Schedule</label>
          <div class='col-md-10'>
            ${this.scheduleEditor.el}
          </div>
        </div>

        <div class='form-group'>
          <label class='control-label col-md-2'>Actions</label>
          <div class='col-md-10'>
            ${this.actionEditor.el}
          </div>
        </div>

        <div class='form-group'>
          <label class='control-label col-md-2'>Labels</label>
          <div class='col-md-10'>
            ${this.tagsEditor.el}
          </div>
        </div>
      </div>`;
  }
}
class CSVImporter extends Base$3 {
  init() {
    this.reset();
  }
  reset() {
    this.setState({
      progress: { index: 0, total: 0, msg: "" },
      result: null,
      stage: STAGE_PICK_FILE,
      errorImport: null
    });
  }
  async onImport() {
    this.state.stage = STAGE_IMPORT;
    try {
      const rows = this.csvMarker.getRows();
      const options = this.commonOptions.getOptions();
      let constraint;
      try {
        constraint = await checkSieveConstraint(rows.length);
      } catch (e) {
        console.error(e);
        constraint = { isOverLimit: false };
      }
      if (constraint.isOverLimit) {
        this.state.errorImport = { msg: `Monitor limit exceeded` };
        return;
      }
      this.importAll(rows, options);
    } catch (e) {
      console.error(e);
      this.state.errorImport = { msg: `Import failed: ${e.message || e.msg}` };
    }
  }
  async importAll(sieves, options) {
    const state = this.state;
    state.progress = { index: 0, total: sieves.length, msg: "Importing labels..." };
    for (let i2 = 0; i2 < sieves.length; i2 += 1) {
      const sieve = sieves[i2];
      state.progress = { ...state.progress, msg: `Importing ${sieve.url}` };
      await this.importOne(sieve, options);
    }
    state.progress = { ...state.progress, msg: `Imported ${sieves.length}` };
  }
  async importOne(sieve, { tags, actions, ...sieveOptions }) {
    if (sieve.rule) {
      const rule = await Api.api("/rules", "POST", { config: sieve.rule });
      sieve.rule_id = rule.id;
    }
    const labels = [], labelsStr = sieve.labels || "";
    delete sieve.label;
    if (labelsStr.length > 0) {
      let rowLevelLabels = await App.labels.getOrCreateLabels(labelsStr);
      labels.push(...rowLevelLabels);
    }
    if (tags && tags.length > 0) {
      tags = tags.split(",");
      for (let i2 = 0; i2 < tags.length; i2 += 1) {
        labels.push(App.labels.get(tags[i2]));
      }
    }
    sieve.tags = labels.map((l) => l.id).join(",");
    sieve.uri = sieve.url;
    delete sieve.url;
    let doc = _.extend({
      client_id: App.clients.defaultId,
      content_type: 2,
      config: JSON.stringify({
        "includeStyle": true,
        "ignoreEmptyText": true,
        "dataAttr": "text",
        "selections": [
          {
            "frames": [
              {
                "index": 0,
                "excludes": [],
                "includes": [
                  {
                    "type": "css",
                    "expr": "body"
                  }
                ]
              }
            ],
            "dynamic": true,
            "delay": 2
          }
        ]
      })
    }, sieve, sieveOptions);
    doc = this.sanitizeCSVFields(doc);
    let savedSieve = await Api.api("/sieves", "POST", doc);
    for (let i2 = 0; i2 < actions.length; i2 += 1) {
      await Api.api(`/sieves/${savedSieve.id}/actions`, "POST", _.extend({
        sieve_id: savedSieve.id
      }, actions[i2]));
    }
    this.state.progress = { ...this.state.progress, index: this.state.progress.index + 1 };
  }
  sanitizeCSVFields(sieveRequest) {
    if (sieveRequest.datasource_id === "") {
      sieveRequest.datasource_id = null;
    }
    return sieveRequest;
  }
  onBack() {
    this.state.stage -= 1;
  }
  onFileChange(e) {
    const file = e.target.files[0];
    const reader = new FileReader();
    reader.readAsText(file, "utf-8");
    reader.onload = (e2) => this.onFileRead(e2.target.result);
    reader.onerror = (e2) => this.onFileReadError(e2);
    this.state.filename = file.name;
  }
  onFileRead(text2) {
    Papa.parse(text2, {
      header: true,
      skipEmptyLines: true,
      complete: (result) => {
        this.showData(result);
      }
    });
  }
  onFileReadError(e) {
    console.error("error reading file", e);
    this.state.errorFile = e.message;
  }
  onFileSelect(e) {
    this.el.querySelector("[type=file]").click();
  }
  onNextToOptions() {
    let errorMap;
    const inputFields = this.csvMarker.getInputFields();
    if (!inputFields.name == null) {
      errorMap = { key: "name", msg: "Missing name" };
    } else if (!inputFields.url) {
      errorMap = { key: "url", msg: "Missing URL" };
    } else {
      const [row1, row2] = this.state.resultOrig.data;
      const urlColumnName = inputFields.url;
      const url1 = row1[urlColumnName];
      const url2 = row2[urlColumnName];
      try {
        new URL(url1);
        new URL(url2);
      } catch (e) {
        console.error(urlColumnName, row1, e);
        errorMap = { key: "url", msg: "malformed url" };
      }
    }
    if (errorMap) {
      this.setState({ errorMap });
      return;
    }
    this.commonOptions = new CommonOptions({
      inputFields
    });
    this.state.stage = STAGE_OPTIONS;
  }
  showData(result) {
    this.state.resultOrig = result;
    this.state.stage = STAGE_MARK_DATA;
    this.csvMarker = new CSVMarker({ result });
  }
  createTpl({ csvText, progress, stage, errorMap, errorImport }) {
    const importing = progress.index < progress.total - 1;
    return html`
      <style> .actions { margin: 20px 0; }</style>
      <div class='xpage-header'>
        <h2>
          CSV 
          ${T("a_import")}
        </h2>
      </div>
      <div class='' style='padding: 10px; background-color: #fff; border-radius: 2px;'>
        ${stage == STAGE_PICK_FILE ? html`
          <div class='row'>
            <div class='col-md-4'>
              <input class='btn btn-default btn-lg' type='file' accept='.csv' style='display:none' @change=${(e) => this.onFileChange(e)}></input>
              <button class='btn btn-primary btn-lg' @click=${(e) => this.onFileSelect(e)}>
                Select CSV file to import monitors
              </button>
              ${stage > STAGE_PICK_FILE ? html`<span>File: ${this.state.filename}</span>` : ""}
            </div>
            <div class='col-md-8'>
              Please note that the file should have columns with following headers:
              <ul>
                <li>Name</li>
                <li>URL</li>
                <li class='hide'>Config (Optional)</li>
                <li>Labels (Optional)</li>
                <li>Datasource ID (Optional)</li>
              </ul>
            </div>
          </div>` : ""}

        ${stage == STAGE_MARK_DATA ? html`
        <div>
          ${this.csvMarker.el}
          <div class='actions'>
            <button class='btn btn-default' @click=${(e) => this.onBack()}>Back</button>
            <button class='btn btn-primary' @click=${(e) => this.onNextToOptions()}>
              Next - configure options and actions
            </button>
          </div>
          ${errorMap ? html`<div class='error'>${errorMap.msg}</div>` : ""}
        </div>` : ""}

        ${stage == STAGE_OPTIONS ? html`
        <div>
          ${this.commonOptions.el}
          <div class='actions'>
            <button class='btn btn-default' @click=${(e) => this.onBack()}>Back</button>
            <button class='btn btn-primary' @click=${(e) => this.onImport()}>${T("a_import")}</button>
          </div>
        </div>` : ""}

      ${stage == STAGE_IMPORT && importing ? html`
        <div> <span>${progress.index}</span> of <span>${progress.total}</span> </div>
        <div>${progress.msg || ""}</div>
        ` : ""}

      ${stage == STAGE_IMPORT && !importing ? html`
        <div>${progress.msg || ""}
          <button class='btn btn-default' @click=${(e) => this.reset()}>Start Over</button>
        </div>` : ""}
      ${errorImport ? html`<div class='error'>${errorImport.msg}</div>` : ""}

    </div>`;
  }
  setActive(active) {
  }
}
const $$2 = window.jQuery;
const Importer = View$1.ActionProvider.extend({
  name: "importer",
  events: {
    "click .btn-primary": "event_click"
  },
  event_click: function() {
    this.doImport();
  },
  doImport: async function() {
    try {
      const text2 = this.input.value;
      const data = JSON.parse(text2);
      const actions = this.actions.toJSON();
      let sieveConstraint = {};
      try {
        sieveConstraint = await checkSieveConstraint(data.data.length);
      } catch (e) {
        console.error(e);
        sieveConstraint = {
          isOverLimit: false
        };
      }
      if (sieveConstraint.isOverLimit) {
        Msg.error("Monitor limit exceeded!");
        return;
      }
      await this.importAll(data, actions);
    } catch (e) {
      console.error(e);
      Msg.error("Failed to parse data. Invalid JSON.");
    }
  },
  fromJSON: function() {
    this.progress = 0;
    this.totalCount = 0;
    this.input.value = "";
    this.updateStatus();
  },
  importAll: async function(data, actions) {
    this.$(".btn-primary").button("loading");
    Msg.info("Importing labels...");
    try {
      const names = _.uniq(_.flatten(_.pluck(data.data, "tags")));
      const labels = await App.labels.getOrCreateLabels(names);
      const labelsMap = _.object(_.pluck(labels, "name"), _.pluck(labels, "id"));
      this.progress = 0;
      this.totalCount = data.data.length;
      this.updateStatus();
      let sieves = data.data;
      for (let i2 = 0; i2 < sieves.length; i2 += 1) {
        const sieve = sieves[i2];
        await this.importOne(sieve, actions, labelsMap);
      }
      Msg.info("Import completed");
      this.$(".btn-primary").button("reset");
    } catch (e) {
      console.error("failed to import data:", e);
      Msg.error("Error importing data: " + e);
    }
  },
  importOne: async function(sieve, actions, labelsMap) {
    if (sieve.rule) {
      let rule = await Api.api("/rules", "POST", {
        config: sieve.rule
      });
      sieve.rule_id = rule.id;
    }
    if (sieve.tags) {
      sieve.tags = _.map(sieve.tags, function(name) {
        return labelsMap[name];
      }).join(",");
    }
    let res2 = await Api.api("/sieves", "POST", {
      ...sieve,
      client_id: App.clients.defaultId
    });
    let sieve_id = res2.id;
    for (let i2 = 0; i2 < actions.length; i2 += 1) {
      let action = actions[i2];
      await Api.api(`/sieves/${sieve_id}/actions`, "POST", { ...action, sieve_id });
    }
    this.progress += 1;
    this.updateStatus();
  },
  updateStatus: function() {
    $$2(this.counter).text(this.progress);
    $$2(this.total).text(this.totalCount);
    if (this.totalCount > 0 && this.progress == this.totalCount) {
      $$2(this.msgStatus).text(" - Complete!");
    } else {
      $$2(this.msgStatus).text("");
    }
  },
  postInit: function() {
    this.actions = new Model$2.SieveActions(null, {});
    this.actionEditor = new ViewSieve.SieveActionsEditor({
      actions: this.actions,
      parent: this
    });
  },
  render: function() {
    this.$el.append(DIV({ "class": "xtbar  xvbar-margin" }, BUTTON({
      "class": "btn btn-default",
      "data-action": "go_back"
    }, I({
      "class": "fa fa-chevron-left"
    }), " Back")), H2({ "class": "xpage-header pb2 mb2" }, H2(this.title = SPAN(""), SPAN(T("a_import")))), DIV({ "class": "row" }, DIV({ "class": "col-md-5" }, H4({ "class": "pb2" }, "Actions for imported monitors"), this.actionEditor.render().el), DIV({ "class": "col-md-7" }, this.input = TEXTAREA({
      "class": "form-control",
      "style": "width:100%;min-height:300px",
      "placeholder": "Paste JSON data to import and click Import."
    }))), DIV({ "style": "margin-top: 20px;" }, BUTTON({ "class": "btn btn-primary" }, T("a_import")), " Imported: ", this.counter = SPAN("0"), " of ", this.total = SPAN("0"), this.msgStatus = SPAN()), DIV());
    return this;
  }
});
function create_if_block$r(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "error";
      attr(div, "class", "error");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$T(ctx) {
  let t;
  let div;
  let if_block = ctx[1] && create_if_block$r();
  return {
    c() {
      if (if_block)
        if_block.c();
      t = space();
      div = element("div");
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t, anchor);
      insert(target, div, anchor);
      ctx[3](div);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t);
      if (detaching)
        detach(div);
      ctx[3](null);
    }
  };
}
function instance$S($$self, $$props, $$invalidate) {
  let { route: route2 } = $$props;
  getContext$1("watchlist:stores");
  let parent2 = getContext$1("view:root");
  let el;
  let view;
  let error;
  onMount(async () => {
    view = route2.prefix == "csv" ? new CSVImporter({}, { el }) : new Importer({ el, parent: parent2 });
    if (view.render) {
      view.render();
    }
    return () => view.remove();
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(0, el);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("route" in $$props2)
      $$invalidate(2, route2 = $$props2.route);
  };
  return [el, error, route2, div_binding];
}
class Import extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$S, create_fragment$T, safe_not_equal, { route: 2 });
  }
}
function create_if_block$q(ctx) {
  let savemodal;
  let current;
  savemodal = new SaveModal({
    props: {
      onSave: ctx[7],
      title: T("Rename Label"),
      $$slots: { default: [create_default_slot$f] },
      $$scope: { ctx }
    }
  });
  savemodal.$on("close", ctx[11]);
  return {
    c() {
      create_component(savemodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(savemodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const savemodal_changes = {};
      if (dirty & 4100) {
        savemodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      savemodal.$set(savemodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(savemodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(savemodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(savemodal, detaching);
    }
  };
}
function create_default_slot$f(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "class", "form-control");
      attr(input, "type", "text");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(input, ctx[2]);
      if (!mounted) {
        dispose = listen(input, "input", ctx[10]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 4 && input.value !== ctx2[2]) {
        set_input_value(input, ctx2[2]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$S(ctx) {
  let li2;
  let a0;
  let t0_value = ctx[4].name + "";
  let t0;
  let a0_href_value;
  let t1;
  let div;
  let button;
  let t2;
  let ul;
  let li0;
  let a1;
  let i1;
  let t3;
  let t4_value = T("a_rename") + "";
  let t4;
  let t5;
  let li1;
  let a2;
  let i2;
  let t6;
  let t7_value = T("a_del") + "";
  let t7;
  let t8;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[1] && create_if_block$q(ctx);
  return {
    c() {
      li2 = element("li");
      a0 = element("a");
      t0 = text(t0_value);
      t1 = space();
      div = element("div");
      button = element("button");
      button.innerHTML = `<i class="fa fa-caret-down"></i>`;
      t2 = space();
      ul = element("ul");
      li0 = element("li");
      a1 = element("a");
      i1 = element("i");
      t3 = space();
      t4 = text(t4_value);
      t5 = space();
      li1 = element("li");
      a2 = element("a");
      i2 = element("i");
      t6 = space();
      t7 = text(t7_value);
      t8 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(a0, "href", a0_href_value = "#/w/" + ctx[3].team + "/list/label/" + ctx[8]() + ".d/");
      attr(button, "class", "btn btn-mini xbtn-light dropdown-toggle");
      attr(button, "data-toggle", "dropdown");
      attr(i1, "class", "fa fa-pencil");
      attr(i1, "aria-hidden", "true");
      attr(a1, "href", "#");
      attr(i2, "class", "fa fa-trash-o");
      attr(i2, "aria-hidden", "true");
      attr(a2, "href", "#");
      attr(ul, "class", "dropdown-menu dropdown-menu-right");
      attr(div, "class", "dropdown");
      set_style(div, "position", "absolute");
      set_style(div, "top", "2px");
      set_style(div, "right", "0");
      toggle_class(li2, "active", ctx[3].prefix == "label" && ctx[9]());
    },
    m(target, anchor) {
      insert(target, li2, anchor);
      append(li2, a0);
      append(a0, t0);
      append(li2, t1);
      append(li2, div);
      append(div, button);
      append(div, t2);
      append(div, ul);
      append(ul, li0);
      append(li0, a1);
      append(a1, i1);
      append(a1, t3);
      append(a1, t4);
      append(ul, t5);
      append(ul, li1);
      append(li1, a2);
      append(a2, i2);
      append(a2, t6);
      append(a2, t7);
      insert(target, t8, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(a1, "click", ctx[6]),
          listen(a2, "click", ctx[5])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & 16) && t0_value !== (t0_value = ctx2[4].name + ""))
        set_data(t0, t0_value);
      if (!current || dirty & 8 && a0_href_value !== (a0_href_value = "#/w/" + ctx2[3].team + "/list/label/" + ctx2[8]() + ".d/")) {
        attr(a0, "href", a0_href_value);
      }
      if (dirty & 520) {
        toggle_class(li2, "active", ctx2[3].prefix == "label" && ctx2[9]());
      }
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$q(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(li2);
      if (detaching)
        detach(t8);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$R($$self, $$props, $$invalidate) {
  let $route;
  let $label, $$unsubscribe_label = noop, $$subscribe_label = () => ($$unsubscribe_label(), $$unsubscribe_label = subscribe(label, ($$value) => $$invalidate(4, $label = $$value)), label);
  component_subscribe($$self, route, ($$value) => $$invalidate(3, $route = $$value));
  $$self.$$.on_destroy.push(() => $$unsubscribe_label());
  let { label } = $$props;
  $$subscribe_label();
  let renameModal = false;
  let newLabelName = $label.name;
  async function onDel(e) {
    e.preventDefault();
    await label.destroy();
  }
  async function onRename(e) {
    e.preventDefault();
    $$invalidate(1, renameModal = true);
  }
  async function onSaveName() {
    let name = newLabelName;
    await label.save({ name }, { patch: true, wait: true });
    $$invalidate(1, renameModal = false);
  }
  function getPath() {
    return $label.id;
  }
  function isActive() {
    return $label.id == $route.data;
  }
  function input_input_handler() {
    newLabelName = this.value;
    $$invalidate(2, newLabelName);
  }
  const close_handler = (e) => $$invalidate(1, renameModal = false);
  $$self.$$set = ($$props2) => {
    if ("label" in $$props2)
      $$subscribe_label($$invalidate(0, label = $$props2.label));
  };
  return [
    label,
    renameModal,
    newLabelName,
    $route,
    $label,
    onDel,
    onRename,
    onSaveName,
    getPath,
    isActive,
    input_input_handler,
    close_handler
  ];
}
class Label extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$R, create_fragment$S, safe_not_equal, { label: 0 });
  }
}
function get_each_context$h(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list[i2];
  return child_ctx;
}
function create_if_block_2$7(ctx) {
  let span;
  let t;
  return {
    c() {
      span = element("span");
      t = text(ctx[2]);
      attr(span, "class", "badge xbadge-unread");
      set_style(span, "float", "right");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 4)
        set_data(t, ctx2[2]);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block_1$f(ctx) {
  let span;
  let t;
  return {
    c() {
      span = element("span");
      t = text(ctx[1]);
      attr(span, "class", "badge xbadge-error fr");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 2)
        set_data(t, ctx2[1]);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_each_block$h(key_1, ctx) {
  let first;
  let label;
  let current;
  label = new Label({ props: { label: ctx[14] } });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(label.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(label, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const label_changes = {};
      if (dirty & 64)
        label_changes.label = ctx[14];
      label.$set(label_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(label.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(label.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      destroy_component(label, detaching);
    }
  };
}
function create_if_block$p(ctx) {
  let savemodal;
  let current;
  savemodal = new SaveModal({
    props: {
      title: "Add Label",
      onSave: ctx[9],
      $$slots: { default: [create_default_slot$e] },
      $$scope: { ctx }
    }
  });
  savemodal.$on("close", ctx[11]);
  return {
    c() {
      create_component(savemodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(savemodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const savemodal_changes = {};
      if (dirty & 131088) {
        savemodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      savemodal.$set(savemodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(savemodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(savemodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(savemodal, detaching);
    }
  };
}
function create_default_slot$e(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "text");
      attr(input, "class", "form-control");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(input, ctx[4]);
      if (!mounted) {
        dispose = listen(input, "input", ctx[10]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 16 && input.value !== ctx2[4]) {
        set_input_value(input, ctx2[4]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$R(ctx) {
  let div1;
  let div0;
  let a0;
  let t0_value = T("a_add") + "";
  let t0;
  let t1;
  let t2_value = T("l_webpage") + "";
  let t2;
  let a0_href_value;
  let t3;
  let button0;
  let t4;
  let ul0;
  let li0;
  let a1;
  let t5_value = T("l_webpage") + "";
  let t5;
  let a1_href_value;
  let t6;
  let li1;
  let a2;
  let t7_value = T("l_feed") + "";
  let t7;
  let a2_href_value;
  let t8;
  let li2;
  let a3;
  let t9_value = T("l_json") + "";
  let t9;
  let a3_href_value;
  let t10;
  let li3;
  let a4;
  let t11_value = T("l_pdf") + "";
  let t11;
  let a4_href_value;
  let t12;
  let li4;
  let a5;
  let t13_value = T("l_uptime") + "";
  let t13;
  let a5_href_value;
  let t14;
  let li5;
  let a6;
  let t15_value = T("l_doc") + "";
  let t15;
  let a6_href_value;
  let t16;
  let li6;
  let a7;
  let t17_value = T("l_xml") + "";
  let t17;
  let a7_href_value;
  let t18;
  let ul1;
  let li7;
  let a8;
  let t19_value = T("l_all") + "";
  let t19;
  let a8_href_value;
  let t20;
  let li8;
  let a9;
  let t21;
  let t22_value = T("l_unread") + "";
  let t22;
  let a9_href_value;
  let t23;
  let li9;
  let a10;
  let t24;
  let t25_value = T("l_error") + "";
  let t25;
  let a10_href_value;
  let t26;
  let li10;
  let a11;
  let t27_value = T("l_trash") + "";
  let t27;
  let a11_href_value;
  let t28;
  let li11;
  let t29;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t30;
  let li12;
  let t31;
  let li13;
  let button1;
  let t33;
  let if_block2_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[2] > 0 && create_if_block_2$7(ctx);
  let if_block1 = ctx[1] > 0 && create_if_block_1$f(ctx);
  let each_value = ctx[6].models;
  const get_key = (ctx2) => ctx2[14].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$h(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$h(key, child_ctx));
  }
  let if_block2 = ctx[3] && create_if_block$p(ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      a0 = element("a");
      t0 = text(t0_value);
      t1 = space();
      t2 = text(t2_value);
      t3 = space();
      button0 = element("button");
      button0.innerHTML = `<i class="caret"></i>`;
      t4 = space();
      ul0 = element("ul");
      li0 = element("li");
      a1 = element("a");
      t5 = text(t5_value);
      t6 = space();
      li1 = element("li");
      a2 = element("a");
      t7 = text(t7_value);
      t8 = space();
      li2 = element("li");
      a3 = element("a");
      t9 = text(t9_value);
      t10 = space();
      li3 = element("li");
      a4 = element("a");
      t11 = text(t11_value);
      t12 = space();
      li4 = element("li");
      a5 = element("a");
      t13 = text(t13_value);
      t14 = space();
      li5 = element("li");
      a6 = element("a");
      t15 = text(t15_value);
      t16 = space();
      li6 = element("li");
      a7 = element("a");
      t17 = text(t17_value);
      t18 = space();
      ul1 = element("ul");
      li7 = element("li");
      a8 = element("a");
      t19 = text(t19_value);
      t20 = space();
      li8 = element("li");
      a9 = element("a");
      if (if_block0)
        if_block0.c();
      t21 = space();
      t22 = text(t22_value);
      t23 = space();
      li9 = element("li");
      a10 = element("a");
      if (if_block1)
        if_block1.c();
      t24 = space();
      t25 = text(t25_value);
      t26 = space();
      li10 = element("li");
      a11 = element("a");
      t27 = text(t27_value);
      t28 = space();
      li11 = element("li");
      t29 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t30 = space();
      li12 = element("li");
      t31 = space();
      li13 = element("li");
      button1 = element("button");
      button1.textContent = `${T("a_add_label")}`;
      t33 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
      attr(a0, "class", "btn btn-success text-left pl-3");
      attr(a0, "href", a0_href_value = "#/w/" + ctx[5] + "/sieve/add/page.d");
      attr(button0, "class", "btn btn-success dropdown-toggle");
      attr(button0, "data-toggle", "dropdown");
      attr(a1, "href", a1_href_value = "#/w/" + ctx[5] + "/sieve/add/page.d");
      attr(a2, "href", a2_href_value = "#/w/" + ctx[5] + "/sieve/add/feed.d");
      attr(a3, "href", a3_href_value = "#/w/" + ctx[5] + "/sieve/add/json.d?type=" + C.DS_TYPE_JSON);
      attr(a4, "href", a4_href_value = "#/w/" + ctx[5] + "/sieve/add/pdf.d");
      attr(a5, "href", a5_href_value = "#/w/" + ctx[5] + "/sieve/add/json.d?type=" + C.DS_TYPE_UPTIME);
      attr(a6, "href", a6_href_value = "#/w/" + ctx[5] + "/sieve/add/doc.d");
      attr(a7, "href", a7_href_value = "#/w/" + ctx[5] + "/sieve/add/xml.d");
      attr(ul0, "class", "dropdown-menu");
      attr(ul0, "role", "menu");
      attr(div0, "class", "btn-group btn-block mb3 w-100");
      attr(a8, "href", a8_href_value = "#/w/" + ctx[5] + "/list/all/");
      toggle_class(li7, "active", ctx[0].prefix == "all");
      attr(a9, "href", a9_href_value = "#/w/" + ctx[5] + "/list/unread/");
      toggle_class(li8, "active", ctx[0].prefix == "unread");
      attr(a10, "href", a10_href_value = "#/w/" + ctx[5] + "/list/error/");
      toggle_class(li9, "active", ctx[0].prefix == "error");
      attr(a11, "href", a11_href_value = "#/w/" + ctx[5] + "/list/trash/");
      toggle_class(li10, "active", ctx[0].prefix == "trash");
      attr(li11, "class", "divider bb b--light-blue");
      attr(li12, "class", "divider");
      attr(button1, "class", "btn btn-default btn-block py-0");
      attr(ul1, "class", "nav nav-pills nav-stacked mb4");
      attr(ul1, "viewclass", "LabelNavList");
      attr(div1, "class", "xsidebar");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, a0);
      append(a0, t0);
      append(a0, t1);
      append(a0, t2);
      append(div0, t3);
      append(div0, button0);
      append(div0, t4);
      append(div0, ul0);
      append(ul0, li0);
      append(li0, a1);
      append(a1, t5);
      append(ul0, t6);
      append(ul0, li1);
      append(li1, a2);
      append(a2, t7);
      append(ul0, t8);
      append(ul0, li2);
      append(li2, a3);
      append(a3, t9);
      append(ul0, t10);
      append(ul0, li3);
      append(li3, a4);
      append(a4, t11);
      append(ul0, t12);
      append(ul0, li4);
      append(li4, a5);
      append(a5, t13);
      append(ul0, t14);
      append(ul0, li5);
      append(li5, a6);
      append(a6, t15);
      append(ul0, t16);
      append(ul0, li6);
      append(li6, a7);
      append(a7, t17);
      append(div1, t18);
      append(div1, ul1);
      append(ul1, li7);
      append(li7, a8);
      append(a8, t19);
      append(ul1, t20);
      append(ul1, li8);
      append(li8, a9);
      if (if_block0)
        if_block0.m(a9, null);
      append(a9, t21);
      append(a9, t22);
      append(ul1, t23);
      append(ul1, li9);
      append(li9, a10);
      if (if_block1)
        if_block1.m(a10, null);
      append(a10, t24);
      append(a10, t25);
      append(ul1, t26);
      append(ul1, li10);
      append(li10, a11);
      append(a11, t27);
      append(ul1, t28);
      append(ul1, li11);
      append(ul1, t29);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(ul1, null);
      }
      append(ul1, t30);
      append(ul1, li12);
      append(ul1, t31);
      append(ul1, li13);
      append(li13, button1);
      insert(target, t33, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert(target, if_block2_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(button1, "click", ctx[8]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & 32 && a0_href_value !== (a0_href_value = "#/w/" + ctx2[5] + "/sieve/add/page.d")) {
        attr(a0, "href", a0_href_value);
      }
      if (!current || dirty & 32 && a1_href_value !== (a1_href_value = "#/w/" + ctx2[5] + "/sieve/add/page.d")) {
        attr(a1, "href", a1_href_value);
      }
      if (!current || dirty & 32 && a2_href_value !== (a2_href_value = "#/w/" + ctx2[5] + "/sieve/add/feed.d")) {
        attr(a2, "href", a2_href_value);
      }
      if (!current || dirty & 32 && a3_href_value !== (a3_href_value = "#/w/" + ctx2[5] + "/sieve/add/json.d?type=" + C.DS_TYPE_JSON)) {
        attr(a3, "href", a3_href_value);
      }
      if (!current || dirty & 32 && a4_href_value !== (a4_href_value = "#/w/" + ctx2[5] + "/sieve/add/pdf.d")) {
        attr(a4, "href", a4_href_value);
      }
      if (!current || dirty & 32 && a5_href_value !== (a5_href_value = "#/w/" + ctx2[5] + "/sieve/add/json.d?type=" + C.DS_TYPE_UPTIME)) {
        attr(a5, "href", a5_href_value);
      }
      if (!current || dirty & 32 && a6_href_value !== (a6_href_value = "#/w/" + ctx2[5] + "/sieve/add/doc.d")) {
        attr(a6, "href", a6_href_value);
      }
      if (!current || dirty & 32 && a7_href_value !== (a7_href_value = "#/w/" + ctx2[5] + "/sieve/add/xml.d")) {
        attr(a7, "href", a7_href_value);
      }
      if (!current || dirty & 32 && a8_href_value !== (a8_href_value = "#/w/" + ctx2[5] + "/list/all/")) {
        attr(a8, "href", a8_href_value);
      }
      if (dirty & 1) {
        toggle_class(li7, "active", ctx2[0].prefix == "all");
      }
      if (ctx2[2] > 0) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_2$7(ctx2);
          if_block0.c();
          if_block0.m(a9, t21);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (!current || dirty & 32 && a9_href_value !== (a9_href_value = "#/w/" + ctx2[5] + "/list/unread/")) {
        attr(a9, "href", a9_href_value);
      }
      if (dirty & 1) {
        toggle_class(li8, "active", ctx2[0].prefix == "unread");
      }
      if (ctx2[1] > 0) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_1$f(ctx2);
          if_block1.c();
          if_block1.m(a10, t24);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (!current || dirty & 32 && a10_href_value !== (a10_href_value = "#/w/" + ctx2[5] + "/list/error/")) {
        attr(a10, "href", a10_href_value);
      }
      if (dirty & 1) {
        toggle_class(li9, "active", ctx2[0].prefix == "error");
      }
      if (!current || dirty & 32 && a11_href_value !== (a11_href_value = "#/w/" + ctx2[5] + "/list/trash/")) {
        attr(a11, "href", a11_href_value);
      }
      if (dirty & 1) {
        toggle_class(li10, "active", ctx2[0].prefix == "trash");
      }
      if (dirty & 64) {
        each_value = ctx2[6].models;
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, ul1, outro_and_destroy_block, create_each_block$h, t30, get_each_context$h);
        check_outros();
      }
      if (ctx2[3]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block$p(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      if (detaching)
        detach(t33);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach(if_block2_anchor);
      mounted = false;
      dispose();
    }
  };
}
function instance$Q($$self, $$props, $$invalidate) {
  let $route;
  let $labels;
  component_subscribe($$self, route, ($$value) => $$invalidate(0, $route = $$value));
  let labels = getContext$1("labels");
  component_subscribe($$self, labels, (value) => $$invalidate(6, $labels = value));
  getContext$1("user");
  let nError = 0;
  let nUnread = 0;
  let addLabel = false;
  let newLabelName = "";
  let team2 = 0;
  onMount(() => {
    instance$1Q.on("user_states", onChangeUnreadError);
  });
  onDestroy(() => {
    instance$1Q.off("user_states", onChangeUnreadError);
  });
  async function onAddLabel() {
    $$invalidate(3, addLabel = true);
  }
  async function onAddLabelSave() {
    if (_.isEmpty(newLabelName)) {
      throw new Error("e_value_incorrect_check");
    } else {
      await labels.create({ name: newLabelName }, { wait: true });
      $$invalidate(3, addLabel = false);
    }
  }
  function onChangeUnreadError({ error, unread }) {
    $$invalidate(1, nError = error);
    $$invalidate(2, nUnread = unread);
  }
  function input_input_handler() {
    newLabelName = this.value;
    $$invalidate(4, newLabelName);
  }
  const close_handler = (e) => $$invalidate(3, addLabel = false);
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      {
        $$invalidate(5, team2 = $route.team);
      }
    }
  };
  return [
    $route,
    nError,
    nUnread,
    addLabel,
    newLabelName,
    team2,
    $labels,
    labels,
    onAddLabel,
    onAddLabelSave,
    input_input_handler,
    close_handler
  ];
}
class Sidebar$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$Q, create_fragment$R, safe_not_equal, {});
  }
}
function create_fragment$Q(ctx) {
  let form_1;
  return {
    c() {
      form_1 = element("form");
      form_1.innerHTML = `<i class="fa fa-search p-4"></i> 
  <input name="q" class="flex-grow p-4 border-0 border-l border-solid border-gray-300" type="text" autocomplete="off" placeholder="Search..."/>`;
      attr(form_1, "class", "xsearchbar flex -mb-1 border border-solid border-gray-300");
    },
    m(target, anchor) {
      insert(target, form_1, anchor);
      ctx[3](form_1);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(form_1);
      ctx[3](null);
    }
  };
}
function instance$P($$self, $$props, $$invalidate) {
  let $params;
  component_subscribe($$self, params, ($$value) => $$invalidate(2, $params = $$value));
  let form;
  let labels = getContext$1("labels");
  let parent2 = getContext$1("view:root");
  let view;
  onMount(() => {
    $$invalidate(1, view = new SearchForm({ el: form, parent: parent2, labels }));
    return () => view.remove();
  });
  function form_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      form = $$value;
      $$invalidate(0, form);
    });
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 6) {
      view && view.setRouteParams($params);
    }
  };
  return [form, view, $params, form_1_binding];
}
class Search extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$P, create_fragment$Q, safe_not_equal, {});
  }
}
function create_fragment$P(ctx) {
  let div2;
  let aside;
  let div0;
  let t;
  let div1;
  let div1_class_value;
  let aside_class_value;
  let current;
  const default_slot_template = ctx[7].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[6], null);
  return {
    c() {
      div2 = element("div");
      aside = element("aside");
      div0 = element("div");
      t = space();
      div1 = element("div");
      if (default_slot)
        default_slot.c();
      attr(div0, "class", "overlay fixed h-full w-full top-0 left-0 opacity-0");
      attr(div1, "class", div1_class_value = "panel fixed h-full w-full " + ctx[1] + " overflow-auto " + ctx[1] + "-0 }");
      toggle_class(div1, "size", ctx[2]);
      attr(aside, "class", aside_class_value = "drawer " + (ctx[4].class ? ctx[4].class : "") + " fixed h-full w-full top-0 left-0");
      attr(aside, "style", ctx[3]);
      toggle_class(aside, "open", ctx[0]);
      attr(div2, "id", "side-drawer");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, aside);
      append(aside, div0);
      append(aside, t);
      append(aside, div1);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 64)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[6], !current ? get_all_dirty_from_scope(ctx2[6]) : get_slot_changes(default_slot_template, ctx2[6], dirty, null), null);
        }
      }
      if (!current || dirty & 2 && div1_class_value !== (div1_class_value = "panel fixed h-full w-full " + ctx2[1] + " overflow-auto " + ctx2[1] + "-0 }")) {
        attr(div1, "class", div1_class_value);
      }
      if (dirty & 6) {
        toggle_class(div1, "size", ctx2[2]);
      }
      if (!current || dirty & 16 && aside_class_value !== (aside_class_value = "drawer " + (ctx2[4].class ? ctx2[4].class : "") + " fixed h-full w-full top-0 left-0")) {
        attr(aside, "class", aside_class_value);
      }
      if (!current || dirty & 8) {
        attr(aside, "style", ctx2[3]);
      }
      if (dirty & 17) {
        toggle_class(aside, "open", ctx2[0]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$O($$self, $$props, $$invalidate) {
  let style;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { open = false } = $$props;
  let { duration = 0.2 } = $$props;
  let { placement = "left" } = $$props;
  let { size = null } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(4, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("open" in $$new_props)
      $$invalidate(0, open = $$new_props.open);
    if ("duration" in $$new_props)
      $$invalidate(5, duration = $$new_props.duration);
    if ("placement" in $$new_props)
      $$invalidate(1, placement = $$new_props.placement);
    if ("size" in $$new_props)
      $$invalidate(2, size = $$new_props.size);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 36) {
      $$invalidate(3, style = `--duration: ${duration}s; --size: ${size};`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [open, placement, size, style, $$props, duration, $$scope, slots];
}
class Drawer extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$O, create_fragment$P, safe_not_equal, {
      open: 0,
      duration: 5,
      placement: 1,
      size: 2
    });
  }
}
const get_footer_slot_changes = (dirty) => ({});
const get_footer_slot_context = (ctx) => ({});
const get_header_slot_changes$1 = (dirty) => ({});
const get_header_slot_context$1 = (ctx) => ({});
function create_if_block$o(ctx) {
  let div;
  let t0;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      t0 = space();
      button = element("button");
      button.textContent = "\xD7";
      attr(div, "class", "flex-1");
      attr(button, "class", "close");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      insert(target, t0, anchor);
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", ctx[4]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$O(ctx) {
  let div3;
  let div0;
  let t0;
  let t1;
  let div1;
  let t2;
  let div2;
  let current;
  const header_slot_template = ctx[3].header;
  const header_slot = create_slot(header_slot_template, ctx, ctx[2], get_header_slot_context$1);
  let if_block = ctx[0] && create_if_block$o(ctx);
  const default_slot_template = ctx[3].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[2], null);
  const footer_slot_template = ctx[3].footer;
  const footer_slot = create_slot(footer_slot_template, ctx, ctx[2], get_footer_slot_context);
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      if (header_slot)
        header_slot.c();
      t0 = space();
      if (if_block)
        if_block.c();
      t1 = space();
      div1 = element("div");
      if (default_slot)
        default_slot.c();
      t2 = space();
      div2 = element("div");
      if (footer_slot)
        footer_slot.c();
      attr(div0, "class", "panel-heading flex");
      attr(div1, "class", "panel-body flex flex-row");
      attr(div2, "class", "panel-footer bg-white");
      attr(div3, "class", "panel panel-default");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div0);
      if (header_slot) {
        header_slot.m(div0, null);
      }
      append(div0, t0);
      if (if_block)
        if_block.m(div0, null);
      append(div3, t1);
      append(div3, div1);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      append(div3, t2);
      append(div3, div2);
      if (footer_slot) {
        footer_slot.m(div2, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (header_slot) {
        if (header_slot.p && (!current || dirty & 4)) {
          update_slot_base(header_slot, header_slot_template, ctx2, ctx2[2], !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(header_slot_template, ctx2[2], dirty, get_header_slot_changes$1), get_header_slot_context$1);
        }
      }
      if (ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$o(ctx2);
          if_block.c();
          if_block.m(div0, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[2], !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(default_slot_template, ctx2[2], dirty, null), null);
        }
      }
      if (footer_slot) {
        if (footer_slot.p && (!current || dirty & 4)) {
          update_slot_base(footer_slot, footer_slot_template, ctx2, ctx2[2], !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(footer_slot_template, ctx2[2], dirty, get_footer_slot_changes), get_footer_slot_context);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(header_slot, local);
      transition_in(default_slot, local);
      transition_in(footer_slot, local);
      current = true;
    },
    o(local) {
      transition_out(header_slot, local);
      transition_out(default_slot, local);
      transition_out(footer_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      if (header_slot)
        header_slot.d(detaching);
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
      if (footer_slot)
        footer_slot.d(detaching);
    }
  };
}
function instance$N($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { closable = true } = $$props;
  let dispatch = createEventDispatcher();
  const click_handler2 = (e) => dispatch("close");
  $$self.$$set = ($$props2) => {
    if ("closable" in $$props2)
      $$invalidate(0, closable = $$props2.closable);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  return [closable, dispatch, $$scope, slots, click_handler2];
}
class Card extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$N, create_fragment$O, safe_not_equal, { closable: 0 });
  }
}
function get_each_context$g(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i2];
  return child_ctx;
}
function create_default_slot$d(ctx) {
  let t_value = ctx[1].body + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t_value !== (t_value = ctx2[1].body + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_header_slot$3(ctx) {
  let div;
  let t0_value = ctx[1].title + "";
  let t0;
  let t1;
  let small;
  let t2_value = formatTime(ctx[1].ts, true) + "";
  let t2;
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      small = element("small");
      t2 = text(t2_value);
      attr(small, "class", "pl-4 text-gray-400");
      attr(div, "slot", "header");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      append(div, small);
      append(small, t2);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t0_value !== (t0_value = ctx2[1].title + ""))
        set_data(t0, t0_value);
      if (dirty & 2 && t2_value !== (t2_value = formatTime(ctx2[1].ts, true) + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_each_block$g(ctx) {
  let a;
  let t0_value = ctx[3].label + "";
  let t0;
  let t1;
  let a_href_value;
  return {
    c() {
      a = element("a");
      t0 = text(t0_value);
      t1 = space();
      attr(a, "href", a_href_value = ctx[3].link);
      attr(a, "target", "_blank");
      attr(a, "class", "text-center btn btn-default btn-xs capitalize");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, t0);
      append(a, t1);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t0_value !== (t0_value = ctx2[3].label + ""))
        set_data(t0, t0_value);
      if (dirty & 2 && a_href_value !== (a_href_value = ctx2[3].link)) {
        attr(a, "href", a_href_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(a);
    }
  };
}
function create_footer_slot(ctx) {
  let div;
  let each_value = ctx[1].actions;
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$g(get_each_context$g(ctx, each_value, i2));
  }
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "slot", "footer");
      attr(div, "class", "flex space-x-2");
      toggle_class(div, "hide", ctx[1].actions.length == 0);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(div, null);
      }
    },
    p(ctx2, dirty) {
      if (dirty & 2) {
        each_value = ctx2[1].actions;
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$g(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$g(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(div, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & 2) {
        toggle_class(div, "hide", ctx2[1].actions.length == 0);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_fragment$N(ctx) {
  let card;
  let current;
  card = new Card({
    props: {
      $$slots: {
        footer: [create_footer_slot],
        header: [create_header_slot$3],
        default: [create_default_slot$d]
      },
      $$scope: { ctx }
    }
  });
  card.$on("close", ctx[2]);
  return {
    c() {
      create_component(card.$$.fragment);
    },
    m(target, anchor) {
      mount_component(card, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const card_changes = {};
      if (dirty & 66) {
        card_changes.$$scope = { dirty, ctx: ctx2 };
      }
      card.$set(card_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(card.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(card.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(card, detaching);
    }
  };
}
function instance$M($$self, $$props, $$invalidate) {
  let $message, $$unsubscribe_message = noop, $$subscribe_message = () => ($$unsubscribe_message(), $$unsubscribe_message = subscribe(message, ($$value) => $$invalidate(1, $message = $$value)), message);
  $$self.$$.on_destroy.push(() => $$unsubscribe_message());
  let { message } = $$props;
  $$subscribe_message();
  const close_handler = (e) => message.destroy();
  $$self.$$set = ($$props2) => {
    if ("message" in $$props2)
      $$subscribe_message($$invalidate(0, message = $$props2.message));
  };
  return [message, $message, close_handler];
}
class MessageCard extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$M, create_fragment$N, safe_not_equal, { message: 0 });
  }
}
function get_each_context$f(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[1] = list[i2];
  return child_ctx;
}
function create_catch_block$4(ctx) {
  return { c: noop, m: noop, d: noop };
}
function create_then_block$4(ctx) {
  return { c: noop, m: noop, d: noop };
}
function create_pending_block$4(ctx) {
  let t;
  return {
    c() {
      t = text("Loading...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_else_block$j(ctx) {
  let p;
  return {
    c() {
      p = element("p");
      p.textContent = "No more message to show.";
      attr(p, "class", "text-2xl text-center");
    },
    m(target, anchor) {
      insert(target, p, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
function create_each_block$f(key_1, ctx) {
  let first;
  let card;
  let current;
  card = new MessageCard({ props: { message: ctx[1] } });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(card.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(card, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const card_changes = {};
      if (dirty & 1)
        card_changes.message = ctx[1];
      card.$set(card_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(card.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(card.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      destroy_component(card, detaching);
    }
  };
}
function create_fragment$M(ctx) {
  let div;
  let promise;
  let t;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$4,
    then: create_then_block$4,
    catch: create_catch_block$4
  };
  handle_promise(promise = ctx[0].fetchPromise, info);
  let each_value = ctx[0].models;
  const get_key = (ctx2) => ctx2[1].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$f(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$f(key, child_ctx));
  }
  let each_1_else = null;
  if (!each_value.length) {
    each_1_else = create_else_block$j();
  }
  return {
    c() {
      div = element("div");
      info.block.c();
      t = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      if (each_1_else) {
        each_1_else.c();
      }
      attr(div, "id", "user-messages");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      info.block.m(div, info.anchor = null);
      info.mount = () => div;
      info.anchor = t;
      append(div, t);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(div, null);
      }
      if (each_1_else) {
        each_1_else.m(div, null);
      }
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      info.ctx = ctx;
      dirty & 1 && promise !== (promise = ctx[0].fetchPromise) && handle_promise(promise, info);
      if (dirty & 1) {
        each_value = ctx[0].models;
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block$f, null, get_each_context$f);
        check_outros();
        if (!each_value.length && each_1_else) {
          each_1_else.p(ctx, dirty);
        } else if (!each_value.length) {
          each_1_else = create_else_block$j();
          each_1_else.c();
          each_1_else.m(div, null);
        } else if (each_1_else) {
          each_1_else.d(1);
          each_1_else = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      info.block.d();
      info.token = null;
      info = null;
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      if (each_1_else)
        each_1_else.d();
    }
  };
}
function instance$L($$self, $$props, $$invalidate) {
  let $userMsgs;
  component_subscribe($$self, userMsgs, ($$value) => $$invalidate(0, $userMsgs = $$value));
  return [$userMsgs];
}
class UserMessages extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$L, create_fragment$M, safe_not_equal, {});
  }
}
function get_each_context$e(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[1] = list[i2];
  return child_ctx;
}
function create_each_block$e(key_1, ctx) {
  let first;
  let card;
  let current;
  card = new MessageCard({ props: { message: ctx[1] } });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(card.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(card, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const card_changes = {};
      if (dirty & 1)
        card_changes.message = ctx[1];
      card.$set(card_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(card.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(card.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      destroy_component(card, detaching);
    }
  };
}
function create_fragment$L(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ctx[0].models;
  const get_key = (ctx2) => ctx2[1].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$e(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$e(key, child_ctx));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        each_value = ctx2[0].models;
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$e, each_1_anchor, get_each_context$e);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function instance$K($$self, $$props, $$invalidate) {
  let $clientMsgs;
  component_subscribe($$self, clientMsgs, ($$value) => $$invalidate(0, $clientMsgs = $$value));
  return [$clientMsgs];
}
class ClientMessages extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$K, create_fragment$L, safe_not_equal, {});
  }
}
function create_if_block_1$e(ctx) {
  let clientmessages;
  let current;
  clientmessages = new ClientMessages({});
  return {
    c() {
      create_component(clientmessages.$$.fragment);
    },
    m(target, anchor) {
      mount_component(clientmessages, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(clientmessages.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(clientmessages.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(clientmessages, detaching);
    }
  };
}
function create_if_block$n(ctx) {
  let usermessages;
  let current;
  usermessages = new UserMessages({});
  return {
    c() {
      create_component(usermessages.$$.fragment);
    },
    m(target, anchor) {
      mount_component(usermessages, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(usermessages.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(usermessages.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(usermessages, detaching);
    }
  };
}
function create_default_slot$c(ctx) {
  let div;
  let header;
  let h4;
  let t1;
  let button;
  let t2;
  let main;
  let t3;
  let show_if = ctx[0].isLoggedIn();
  let current;
  let mounted;
  let dispose;
  let if_block0 = Supports.agents.local && create_if_block_1$e();
  let if_block1 = show_if && create_if_block$n();
  return {
    c() {
      div = element("div");
      header = element("header");
      h4 = element("h4");
      h4.textContent = "Messages";
      t1 = space();
      button = element("button");
      button.innerHTML = `<i class="fa fa-times"></i>`;
      t2 = space();
      main = element("main");
      if (if_block0)
        if_block0.c();
      t3 = space();
      if (if_block1)
        if_block1.c();
      attr(h4, "class", "flex-grow");
      attr(button, "class", "close");
      attr(header, "class", "bg-blue-500 text-white flex flex-row p-4");
      attr(main, "class", "flex-1 overflow-y-auto p-4");
      attr(div, "class", "message-drawer flex flex-col h-screen");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, header);
      append(header, h4);
      append(header, t1);
      append(header, button);
      append(div, t2);
      append(div, main);
      if (if_block0)
        if_block0.m(main, null);
      append(main, t3);
      if (if_block1)
        if_block1.m(main, null);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[1]);
        mounted = true;
      }
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$K(ctx) {
  let drawer;
  let current;
  drawer = new Drawer({
    props: {
      open: true,
      placement: "right",
      size: "600px",
      class: "right-drawer",
      $$slots: { default: [create_default_slot$c] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(drawer.$$.fragment);
    },
    m(target, anchor) {
      mount_component(drawer, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const drawer_changes = {};
      if (dirty & 8) {
        drawer_changes.$$scope = { dirty, ctx: ctx2 };
      }
      drawer.$set(drawer_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(drawer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(drawer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(drawer, detaching);
    }
  };
}
function instance$J($$self, $$props, $$invalidate) {
  const user = getContext$1("user");
  let { isDrawerOpen = false } = $$props;
  function closeRightDrawer() {
    $$invalidate(2, isDrawerOpen = false);
  }
  $$self.$$set = ($$props2) => {
    if ("isDrawerOpen" in $$props2)
      $$invalidate(2, isDrawerOpen = $$props2.isDrawerOpen);
  };
  return [user, closeRightDrawer, isDrawerOpen];
}
class Messages extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$J, create_fragment$K, safe_not_equal, { isDrawerOpen: 2 });
  }
}
function get_each_context$d(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i2];
  return child_ctx;
}
function create_if_block$m(ctx) {
  let div4;
  let div2;
  let div0;
  let t0_value = formatTime(ctx[1].ts, true) + "";
  let t0;
  let t1;
  let div1;
  let t2_value = ctx[1].body + "";
  let t2;
  let t3;
  let div3;
  let t4;
  let button;
  let mounted;
  let dispose;
  let each_value = ctx[1].actions;
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$d(get_each_context$d(ctx, each_value, i2));
  }
  return {
    c() {
      div4 = element("div");
      div2 = element("div");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      div1 = element("div");
      t2 = text(t2_value);
      t3 = space();
      div3 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t4 = space();
      button = element("button");
      button.innerHTML = `<span aria-hidden="true">Dismiss</span>`;
      attr(div0, "class", "text-base");
      attr(div2, "class", "flex flex-column");
      attr(button, "class", "btn btn-default btn-xs");
      attr(button, "aria-label", "Close");
      attr(div3, "class", "flex self-center gap-4");
      attr(div4, "class", "alert alert-dismissible mb-0 alert-" + ctx[2]() + " flex justify-between p-2");
      set_style(div4, "margin-left", "var(--vbar-margin)");
      attr(div4, "role", "alert");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div2);
      append(div2, div0);
      append(div0, t0);
      append(div2, t1);
      append(div2, div1);
      append(div1, t2);
      append(div4, t3);
      append(div4, div3);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(div3, null);
      }
      append(div3, t4);
      append(div3, button);
      if (!mounted) {
        dispose = listen(button, "click", ctx[4]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t0_value !== (t0_value = formatTime(ctx2[1].ts, true) + ""))
        set_data(t0, t0_value);
      if (dirty & 2 && t2_value !== (t2_value = ctx2[1].body + ""))
        set_data(t2, t2_value);
      if (dirty & 2) {
        each_value = ctx2[1].actions;
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$d(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$d(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(div3, t4);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div4);
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block$d(ctx) {
  let a;
  let t_value = ctx[5].label + "";
  let t;
  let a_href_value;
  return {
    c() {
      a = element("a");
      t = text(t_value);
      attr(a, "class", "text-lg");
      attr(a, "href", a_href_value = ctx[5].link);
      attr(a, "target", "_blank");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, t);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t_value !== (t_value = ctx2[5].label + ""))
        set_data(t, t_value);
      if (dirty & 2 && a_href_value !== (a_href_value = ctx2[5].link)) {
        attr(a, "href", a_href_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(a);
    }
  };
}
function create_fragment$J(ctx) {
  let if_block_anchor;
  let if_block = ctx[0] && create_if_block$m(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$m(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$I($$self, $$props, $$invalidate) {
  let $message, $$unsubscribe_message = noop, $$subscribe_message = () => ($$unsubscribe_message(), $$unsubscribe_message = subscribe(message, ($$value) => $$invalidate(1, $message = $$value)), message);
  let $flash;
  component_subscribe($$self, flash, ($$value) => $$invalidate(3, $flash = $$value));
  $$self.$$.on_destroy.push(() => $$unsubscribe_message());
  let message;
  function getAlertClass() {
    let level = $message.level;
    return level == "error" ? "danger" : level == "warn" ? "warning" : "info";
  }
  const click_handler2 = (e) => message.destroy();
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 8) {
      $$subscribe_message($$invalidate(0, message = $flash));
    }
  };
  return [message, $message, getAlertClass, $flash, click_handler2];
}
class Notification extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$I, create_fragment$J, safe_not_equal, {});
  }
}
function create_if_block$l(ctx) {
  let messages;
  let updating_isDrawerOpen;
  let current;
  function messages_isDrawerOpen_binding(value) {
    ctx[8](value);
  }
  let messages_props = {};
  if (ctx[1] !== void 0) {
    messages_props.isDrawerOpen = ctx[1];
  }
  messages = new Messages({ props: messages_props });
  binding_callbacks.push(() => bind$2(messages, "isDrawerOpen", messages_isDrawerOpen_binding));
  return {
    c() {
      create_component(messages.$$.fragment);
    },
    m(target, anchor) {
      mount_component(messages, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const messages_changes = {};
      if (!updating_isDrawerOpen && dirty & 2) {
        updating_isDrawerOpen = true;
        messages_changes.isDrawerOpen = ctx2[1];
        add_flush_callback(() => updating_isDrawerOpen = false);
      }
      messages.$set(messages_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(messages.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(messages.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(messages, detaching);
    }
  };
}
function create_fragment$I(ctx) {
  let notification;
  let t0;
  let div5;
  let div2;
  let div0;
  let t2;
  let div1;
  let t3_value = (ctx[2] ? ctx[2].info || ctx[2].name : "") + "";
  let t3;
  let t4;
  let div4;
  let search;
  let t5;
  let div3;
  let t6;
  let a;
  let i2;
  let t7;
  let span;
  let t8;
  let t9;
  let t10;
  let t11;
  let selector2;
  let t12;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  notification = new Notification({});
  search = new Search({});
  selector2 = new Selector$4({
    props: {
      menuAlign: "right",
      team: ctx[4].team
    }
  });
  let if_block = ctx[1] && create_if_block$l(ctx);
  return {
    c() {
      create_component(notification.$$.fragment);
      t0 = space();
      div5 = element("div");
      div2 = element("div");
      div0 = element("div");
      div0.textContent = "Watchlist";
      t2 = space();
      div1 = element("div");
      t3 = text(t3_value);
      t4 = space();
      div4 = element("div");
      create_component(search.$$.fragment);
      t5 = space();
      div3 = element("div");
      t6 = space();
      a = element("a");
      i2 = element("i");
      t7 = space();
      span = element("span");
      t8 = text("(");
      t9 = text(ctx[3]);
      t10 = text(")");
      t11 = space();
      create_component(selector2.$$.fragment);
      t12 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(div0, "class", "inline-block fw4 f2");
      attr(div1, "class", "absolute f5 -mx-4 px-4");
      attr(div2, "class", "relative title-header ttu pl4");
      attr(div3, "class", "flex-grow");
      attr(i2, "class", "fa fa-envelope");
      attr(span, "class", "px-1 text-md font-bold");
      toggle_class(span, "hide", !ctx[3]);
      attr(a, "class", "xnav-a pr-4");
      attr(a, "href", "#");
      attr(div4, "class", "flex-grow flex items-center border-b border-gray-300");
      set_style(div4, "border-bottom-style", "solid");
      attr(div5, "id", "topbar");
      attr(div5, "class", "flex items-center");
    },
    m(target, anchor) {
      mount_component(notification, target, anchor);
      insert(target, t0, anchor);
      insert(target, div5, anchor);
      append(div5, div2);
      append(div2, div0);
      append(div2, t2);
      append(div2, div1);
      append(div1, t3);
      append(div5, t4);
      append(div5, div4);
      mount_component(search, div4, null);
      append(div4, t5);
      append(div4, div3);
      append(div4, t6);
      append(div4, a);
      append(a, i2);
      append(a, t7);
      append(a, span);
      append(span, t8);
      append(span, t9);
      append(span, t10);
      append(div4, t11);
      mount_component(selector2, div4, null);
      insert(target, t12, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(a, "click", prevent_default(ctx[6]));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & 4) && t3_value !== (t3_value = (ctx2[2] ? ctx2[2].info || ctx2[2].name : "") + ""))
        set_data(t3, t3_value);
      if (!current || dirty & 8)
        set_data(t9, ctx2[3]);
      if (dirty & 8) {
        toggle_class(span, "hide", !ctx2[3]);
      }
      const selector_changes = {};
      if (dirty & 16)
        selector_changes.team = ctx2[4].team;
      selector2.$set(selector_changes);
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$l(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(notification.$$.fragment, local);
      transition_in(search.$$.fragment, local);
      transition_in(selector2.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(notification.$$.fragment, local);
      transition_out(search.$$.fragment, local);
      transition_out(selector2.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      destroy_component(notification, detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div5);
      destroy_component(search);
      destroy_component(selector2);
      if (detaching)
        detach(t12);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
      mounted = false;
      dispose();
    }
  };
}
function instance$H($$self, $$props, $$invalidate) {
  let $clients;
  let $client, $$unsubscribe_client = noop, $$subscribe_client = () => ($$unsubscribe_client(), $$unsubscribe_client = subscribe(client, ($$value) => $$invalidate(2, $client = $$value)), client);
  let $count;
  let $route;
  component_subscribe($$self, count, ($$value) => $$invalidate(3, $count = $$value));
  component_subscribe($$self, route, ($$value) => $$invalidate(4, $route = $$value));
  $$self.$$.on_destroy.push(() => $$unsubscribe_client());
  let clients = getContext$1("clients");
  component_subscribe($$self, clients, (value) => $$invalidate(7, $clients = value));
  let client, isDrawerOpen = false;
  function openRightDrawer() {
    $$invalidate(1, isDrawerOpen = true);
  }
  function messages_isDrawerOpen_binding(value) {
    isDrawerOpen = value;
    $$invalidate(1, isDrawerOpen);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 128) {
      {
        $$subscribe_client($$invalidate(0, client = $clients && clients.get(clients.defaultId)));
      }
    }
  };
  return [
    client,
    isDrawerOpen,
    $client,
    $count,
    $route,
    clients,
    openRightDrawer,
    $clients,
    messages_isDrawerOpen_binding
  ];
}
class Topbar extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$H, create_fragment$I, safe_not_equal, {});
  }
}
function create_if_block$k(ctx) {
  let div2;
  return {
    c() {
      div2 = element("div");
      div2.innerHTML = `<div class="xtbar xvbar-margin" style="display: flex;"><button class="btn btn-default" data-action="go_back"><i class="fa fa-chevron-left"></i> Back</button> 
        <div class="centered" style="flex: 1; margin: 0; padding: 0;"></div></div>`;
      attr(div2, "viewclass", "");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(div2);
    }
  };
}
function create_default_slot$b(ctx) {
  let sidebar;
  let t0;
  let div;
  let t1;
  let current;
  sidebar = new Sidebar$1({});
  let if_block = ctx[0] && create_if_block$k();
  const default_slot_template = ctx[3].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  return {
    c() {
      create_component(sidebar.$$.fragment);
      t0 = space();
      div = element("div");
      if (if_block)
        if_block.c();
      t1 = space();
      if (default_slot)
        default_slot.c();
      attr(div, "class", "xcontainer");
    },
    m(target, anchor) {
      mount_component(sidebar, target, anchor);
      insert(target, t0, anchor);
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      append(div, t1);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[0]) {
        if (if_block)
          ;
        else {
          if_block = create_if_block$k();
          if_block.c();
          if_block.m(div, t1);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[5], !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(sidebar.$$.fragment, local);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(sidebar.$$.fragment, local);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sidebar, detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_extra_slot$1(ctx) {
  let topbar;
  let current;
  topbar = new Topbar({});
  return {
    c() {
      create_component(topbar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(topbar, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(topbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(topbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(topbar, detaching);
    }
  };
}
function create_fragment$H(ctx) {
  let layout;
  let current;
  layout = new Layout({
    props: {
      contentScrollTop: ctx[1],
      contentClass: "watchlist",
      $$slots: {
        extra: [create_extra_slot$1],
        default: [create_default_slot$b]
      },
      $$scope: { ctx }
    }
  });
  layout.$on("scroll", ctx[4]);
  return {
    c() {
      create_component(layout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(layout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const layout_changes = {};
      if (dirty & 2)
        layout_changes.contentScrollTop = ctx2[1];
      if (dirty & 33) {
        layout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layout.$set(layout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(layout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(layout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(layout, detaching);
    }
  };
}
function instance$G($$self, $$props, $$invalidate) {
  let $flash;
  component_subscribe($$self, flash, ($$value) => $$invalidate(2, $flash = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  let { renderDefaultToolbar = true } = $$props;
  let { contentScrollTop = 0 } = $$props;
  const r = document.querySelector(":root");
  function scroll_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("renderDefaultToolbar" in $$props2)
      $$invalidate(0, renderDefaultToolbar = $$props2.renderDefaultToolbar);
    if ("contentScrollTop" in $$props2)
      $$invalidate(1, contentScrollTop = $$props2.contentScrollTop);
    if ("$$scope" in $$props2)
      $$invalidate(5, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4) {
      r.style.setProperty("--flashbar-height", $flash ? "40px" : "0px");
    }
  };
  return [renderDefaultToolbar, contentScrollTop, $flash, slots, scroll_handler, $$scope];
}
class WatchListLayout extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$G, create_fragment$H, safe_not_equal, {
      renderDefaultToolbar: 0,
      contentScrollTop: 1
    });
  }
}
function create_fragment$G(ctx) {
  let div1;
  let div0;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      attr(div0, "id", "list");
      toggle_class(div1, "hide", ctx[1]);
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      ctx[3](div0);
    },
    p(ctx2, [dirty]) {
      if (dirty & 2) {
        toggle_class(div1, "hide", ctx2[1]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div1);
      ctx[3](null);
    }
  };
}
function instance$F($$self, $$props, $$invalidate) {
  let $route, $$unsubscribe_route = noop, $$subscribe_route = () => ($$unsubscribe_route(), $$unsubscribe_route = subscribe(route2, ($$value) => $$invalidate(6, $route = $$value)), route2);
  $$self.$$.on_destroy.push(() => $$unsubscribe_route());
  let { route: route2 } = $$props;
  $$subscribe_route();
  let { hidden = false } = $$props;
  let el;
  getContext$1("user");
  let labels = getContext$1("labels");
  let { clients, sieves } = getContext$1("watchlist:stores");
  let parent2 = getContext$1("view:root");
  let view;
  let unsubscribe;
  async function show() {
    view && $route.module == "list" && await view.fetchAndShow($route);
  }
  onMount(async () => {
    view = new ViewSieve.Sieves({
      el,
      clients,
      collection: sieves,
      labels,
      parent: parent2
    }).render();
    unsubscribe = route2.subscribe(show);
  });
  onDestroy(() => {
    unsubscribe();
    view.remove();
  });
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(2, el);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("route" in $$props2)
      $$subscribe_route($$invalidate(0, route2 = $$props2.route));
    if ("hidden" in $$props2)
      $$invalidate(1, hidden = $$props2.hidden);
  };
  return [route2, hidden, el, div0_binding];
}
class List$5 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$F, create_fragment$G, safe_not_equal, { route: 0, hidden: 1 });
  }
}
function get_each_context$c(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i2];
  child_ctx[13] = i2;
  return child_ctx;
}
function create_each_block$c(ctx) {
  let li;
  let a;
  let t0_value = ctx[4](ctx[13]) + "";
  let t0;
  let t1;
  let mounted;
  let dispose;
  function click_handler2(...args) {
    return ctx[7](ctx[13], ...args);
  }
  return {
    c() {
      li = element("li");
      a = element("a");
      t0 = text(t0_value);
      t1 = space();
      attr(a, "href", href$2);
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, a);
      append(a, t0);
      append(li, t1);
      if (!mounted) {
        dispose = listen(a, "click", prevent_default(click_handler2));
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$F(ctx) {
  let ul1;
  let li0;
  let a0;
  let t0;
  let t1;
  let i0;
  let t2;
  let ul0;
  let t3;
  let li1;
  let a1;
  let i1;
  let t4;
  let li2;
  let a2;
  let i2;
  let mounted;
  let dispose;
  let each_value = ctx[2];
  let each_blocks = [];
  for (let i3 = 0; i3 < each_value.length; i3 += 1) {
    each_blocks[i3] = create_each_block$c(get_each_context$c(ctx, each_value, i3));
  }
  return {
    c() {
      ul1 = element("ul");
      li0 = element("li");
      a0 = element("a");
      t0 = text(ctx[3]);
      t1 = space();
      i0 = element("i");
      t2 = space();
      ul0 = element("ul");
      for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
        each_blocks[i3].c();
      }
      t3 = space();
      li1 = element("li");
      a1 = element("a");
      i1 = element("i");
      t4 = space();
      li2 = element("li");
      a2 = element("a");
      i2 = element("i");
      attr(i0, "class", "fa fa-caret-down");
      attr(a0, "href", href$2);
      attr(a0, "class", "dropdown-toggle");
      attr(a0, "data-toggle", "dropdown");
      attr(ul0, "class", "dropdown-menu dropdown-menu-right");
      attr(i1, "class", "fa fa-chevron-left");
      attr(a1, "href", href$2);
      toggle_class(li1, "disabled", !ctx[1].hasPrev());
      attr(i2, "class", "fa fa-chevron-right");
      attr(a2, "href", href$2);
      toggle_class(li2, "disabled", !ctx[1].hasNext());
      attr(ul1, "class", "pagination pagination-sm dropdown");
      set_style(ul1, "margin", "0 5px 0 0");
    },
    m(target, anchor) {
      insert(target, ul1, anchor);
      append(ul1, li0);
      append(li0, a0);
      append(a0, t0);
      append(a0, t1);
      append(a0, i0);
      append(li0, t2);
      append(li0, ul0);
      for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
        each_blocks[i3].m(ul0, null);
      }
      append(ul1, t3);
      append(ul1, li1);
      append(li1, a1);
      append(a1, i1);
      append(ul1, t4);
      append(ul1, li2);
      append(li2, a2);
      append(a2, i2);
      if (!mounted) {
        dispose = [
          listen(a1, "click", prevent_default(ctx[8])),
          listen(a2, "click", prevent_default(ctx[9]))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 8)
        set_data(t0, ctx2[3]);
      if (dirty & 21) {
        each_value = ctx2[2];
        let i3;
        for (i3 = 0; i3 < each_value.length; i3 += 1) {
          const child_ctx = get_each_context$c(ctx2, each_value, i3);
          if (each_blocks[i3]) {
            each_blocks[i3].p(child_ctx, dirty);
          } else {
            each_blocks[i3] = create_each_block$c(child_ctx);
            each_blocks[i3].c();
            each_blocks[i3].m(ul0, null);
          }
        }
        for (; i3 < each_blocks.length; i3 += 1) {
          each_blocks[i3].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & 2) {
        toggle_class(li1, "disabled", !ctx2[1].hasPrev());
      }
      if (dirty & 2) {
        toggle_class(li2, "disabled", !ctx2[1].hasNext());
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(ul1);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const href$2 = "";
function instance$E($$self, $$props, $$invalidate) {
  let $store, $$unsubscribe_store = noop, $$subscribe_store = () => ($$unsubscribe_store(), $$unsubscribe_store = subscribe(store2, ($$value) => $$invalidate(1, $store = $$value)), store2);
  $$self.$$.on_destroy.push(() => $$unsubscribe_store());
  let { name = "list-nav" } = $$props;
  let { store: store2 } = $$props;
  $$subscribe_store();
  let info = {};
  let pages = [];
  let currentRange = "0-0";
  function setCurrentRange() {
    let { count: count2, offset } = info;
    $$invalidate(3, currentRange = `${offset + (count2 > 0 ? 1 : 0)} - ${offset + count2}`);
  }
  function getRange(index2) {
    let { limit, offset, total_count } = info;
    offset += limit * index2;
    return `${offset + 1} - ${Math.min(offset + limit, total_count)}`;
  }
  const click_handler2 = (i2, e) => store2.goto(i2);
  const click_handler_1 = (e) => store2.onPrev();
  const click_handler_2 = (e) => store2.onNext();
  $$self.$$set = ($$props2) => {
    if ("name" in $$props2)
      $$invalidate(5, name = $$props2.name);
    if ("store" in $$props2)
      $$subscribe_store($$invalidate(0, store2 = $$props2.store));
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 66) {
      {
        $$invalidate(6, info = $store.info());
        $$invalidate(2, pages = Array(info.nPages));
        setCurrentRange();
      }
    }
  };
  return [
    store2,
    $store,
    pages,
    currentRange,
    getRange,
    name,
    info,
    click_handler2,
    click_handler_1,
    click_handler_2
  ];
}
class ListPager extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$E, create_fragment$F, safe_not_equal, { name: 5, store: 0 });
  }
}
function get_each_context$b(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i2];
  return child_ctx;
}
function create_each_block$b(ctx) {
  let li;
  let a;
  let t0_value = ctx[4].label + "";
  let t0;
  let t1;
  let mounted;
  let dispose;
  function click_handler2(...args) {
    return ctx[3](ctx[4], ...args);
  }
  return {
    c() {
      li = element("li");
      a = element("a");
      t0 = text(t0_value);
      t1 = space();
      attr(a, "href", href$1);
      toggle_class(li, "active", ctx[4].value == ctx[2]);
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, a);
      append(a, t0);
      append(a, t1);
      if (!mounted) {
        dispose = listen(a, "click", prevent_default(click_handler2));
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 2 && t0_value !== (t0_value = ctx[4].label + ""))
        set_data(t0, t0_value);
      if (dirty & 6) {
        toggle_class(li, "active", ctx[4].value == ctx[2]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(li);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$E(ctx) {
  let ul1;
  let li;
  let a;
  let i2;
  let i_class_value;
  let t0;
  let span;
  let t1;
  let ul0;
  let each_value = ctx[1];
  let each_blocks = [];
  for (let i3 = 0; i3 < each_value.length; i3 += 1) {
    each_blocks[i3] = create_each_block$b(get_each_context$b(ctx, each_value, i3));
  }
  return {
    c() {
      ul1 = element("ul");
      li = element("li");
      a = element("a");
      i2 = element("i");
      t0 = space();
      span = element("span");
      t1 = space();
      ul0 = element("ul");
      for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
        each_blocks[i3].c();
      }
      attr(i2, "class", i_class_value = "fa fa-sort-amount-" + (ctx[2][0] == "-" ? "desc" : "asc"));
      attr(span, "class", "caret");
      attr(a, "href", href$1);
      attr(a, "class", "dropdown-toggle");
      attr(a, "data-toggle", "dropdown");
      attr(ul0, "class", "dropdown-menu dropdown-menu-right");
      attr(ul1, "class", "pagination pagination-sm dropdown");
      set_style(ul1, "margin", "0 5px 0 0");
    },
    m(target, anchor) {
      insert(target, ul1, anchor);
      append(ul1, li);
      append(li, a);
      append(a, i2);
      append(a, t0);
      append(a, span);
      append(li, t1);
      append(li, ul0);
      for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
        each_blocks[i3].m(ul0, null);
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 4 && i_class_value !== (i_class_value = "fa fa-sort-amount-" + (ctx2[2][0] == "-" ? "desc" : "asc"))) {
        attr(i2, "class", i_class_value);
      }
      if (dirty & 7) {
        each_value = ctx2[1];
        let i3;
        for (i3 = 0; i3 < each_value.length; i3 += 1) {
          const child_ctx = get_each_context$b(ctx2, each_value, i3);
          if (each_blocks[i3]) {
            each_blocks[i3].p(child_ctx, dirty);
          } else {
            each_blocks[i3] = create_each_block$b(child_ctx);
            each_blocks[i3].c();
            each_blocks[i3].m(ul0, null);
          }
        }
        for (; i3 < each_blocks.length; i3 += 1) {
          each_blocks[i3].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(ul1);
      destroy_each(each_blocks, detaching);
    }
  };
}
let href$1 = "";
function instance$D($$self, $$props, $$invalidate) {
  let { onSort } = $$props;
  let { sortingFields } = $$props;
  let { currentFieldName } = $$props;
  const click_handler2 = (field, e) => onSort(field.value);
  $$self.$$set = ($$props2) => {
    if ("onSort" in $$props2)
      $$invalidate(0, onSort = $$props2.onSort);
    if ("sortingFields" in $$props2)
      $$invalidate(1, sortingFields = $$props2.sortingFields);
    if ("currentFieldName" in $$props2)
      $$invalidate(2, currentFieldName = $$props2.currentFieldName);
  };
  return [onSort, sortingFields, currentFieldName, click_handler2];
}
class SortBy extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$D, create_fragment$E, safe_not_equal, {
      onSort: 0,
      sortingFields: 1,
      currentFieldName: 2
    });
  }
}
function create_fragment$D(ctx) {
  let div;
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      input = element("input");
      input.value = ctx[0].value;
      attr(div, "class", "bbx-margin-y");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input);
      if (!mounted) {
        dispose = listen(input, "input", ctx[1]);
        mounted = true;
      }
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function instance$C($$self, $$props, $$invalidate) {
  let { propertyName } = $$props;
  let { value } = $$props;
  let { setProperty } = $$props;
  let selector2 = value;
  function handleInput(e) {
    let selector3 = new CSSSelector(e.target.value);
    setProperty(propertyName, selector3);
  }
  $$self.$$set = ($$props2) => {
    if ("propertyName" in $$props2)
      $$invalidate(2, propertyName = $$props2.propertyName);
    if ("value" in $$props2)
      $$invalidate(3, value = $$props2.value);
    if ("setProperty" in $$props2)
      $$invalidate(4, setProperty = $$props2.setProperty);
  };
  return [selector2, handleInput, propertyName, value, setProperty];
}
class Selector extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$C, create_fragment$D, safe_not_equal, {
      propertyName: 2,
      value: 3,
      setProperty: 4
    });
  }
}
function create_fragment$C(ctx) {
  let div;
  let span0;
  let label0;
  let t1;
  let input0;
  let t2;
  let span1;
  let label1;
  let t4;
  let input1;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      span0 = element("span");
      label0 = element("label");
      label0.textContent = "X:";
      t1 = space();
      input0 = element("input");
      t2 = space();
      span1 = element("span");
      label1 = element("label");
      label1.textContent = "Y:";
      t4 = space();
      input1 = element("input");
      input0.value = ctx[0];
      attr(input0, "type", "number");
      attr(input0, "min", "0");
      attr(input0, "max", "99999");
      input1.value = ctx[1];
      attr(input1, "type", "number");
      attr(input1, "min", "0");
      attr(input1, "max", "99999");
      attr(div, "class", "bbx-margin-y");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span0);
      append(span0, label0);
      append(span0, t1);
      append(span0, input0);
      append(div, t2);
      append(div, span1);
      append(span1, label1);
      append(span1, t4);
      append(span1, input1);
      if (!mounted) {
        dispose = [
          listen(input0, "input", ctx[2]),
          listen(input1, "input", ctx[3])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 1 && input0.value !== ctx2[0]) {
        input0.value = ctx2[0];
      }
      if (dirty & 2 && input1.value !== ctx2[1]) {
        input1.value = ctx2[1];
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$B($$self, $$props, $$invalidate) {
  let { propertyName } = $$props;
  let { value } = $$props;
  let { setProperty } = $$props;
  if (!value) {
    value = { x: 0, y: 0 };
  }
  let x = value.x;
  let y = value.y;
  function handleInputX(e) {
    $$invalidate(0, x = e.target.value);
    setProperty(propertyName, { x: parseInt(x), y: parseInt(y) });
  }
  function handleInputY(e) {
    $$invalidate(1, y = e.target.value);
    setProperty(propertyName, { x: parseInt(x), y: parseInt(y) });
  }
  $$self.$$set = ($$props2) => {
    if ("propertyName" in $$props2)
      $$invalidate(5, propertyName = $$props2.propertyName);
    if ("value" in $$props2)
      $$invalidate(4, value = $$props2.value);
    if ("setProperty" in $$props2)
      $$invalidate(6, setProperty = $$props2.setProperty);
  };
  return [x, y, handleInputX, handleInputY, value, propertyName, setProperty];
}
class Position extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$B, create_fragment$C, safe_not_equal, {
      propertyName: 5,
      value: 4,
      setProperty: 6
    });
  }
}
function create_fragment$B(ctx) {
  let div;
  let selector_1;
  let t;
  let position;
  let current;
  selector_1 = new Selector({
    props: {
      propertyName: ctx[0],
      value: ctx[1],
      setProperty: ctx[3]
    }
  });
  position = new Position({
    props: {
      propertyName: ctx[0],
      value: ctx[2],
      setProperty: ctx[4]
    }
  });
  return {
    c() {
      div = element("div");
      create_component(selector_1.$$.fragment);
      t = space();
      create_component(position.$$.fragment);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(selector_1, div, null);
      append(div, t);
      mount_component(position, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const selector_1_changes = {};
      if (dirty & 1)
        selector_1_changes.propertyName = ctx2[0];
      if (dirty & 2)
        selector_1_changes.value = ctx2[1];
      selector_1.$set(selector_1_changes);
      const position_changes = {};
      if (dirty & 1)
        position_changes.propertyName = ctx2[0];
      if (dirty & 4)
        position_changes.value = ctx2[2];
      position.$set(position_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(selector_1.$$.fragment, local);
      transition_in(position.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selector_1.$$.fragment, local);
      transition_out(position.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(selector_1);
      destroy_component(position);
    }
  };
}
function instance$A($$self, $$props, $$invalidate) {
  let { propertyName } = $$props;
  let { value } = $$props;
  let { setProperty } = $$props;
  let target = value;
  let selector2;
  let pos;
  if (target) {
    selector2 = target.selector;
    pos = target.pos;
  } else {
    selector2 = new CSSSelector("body");
    pos = { x: 0, y: 0 };
  }
  if (!pos) {
    pos = { x: 0, y: 0 };
  }
  function setPropertySelector(propertyName2, newSelector) {
    setProperty(propertyName2, { selector: newSelector, pos });
  }
  function setPropertyPos(propertyName2, newPos) {
    setProperty(propertyName2, { selector: selector2, pos: newPos });
  }
  $$self.$$set = ($$props2) => {
    if ("propertyName" in $$props2)
      $$invalidate(0, propertyName = $$props2.propertyName);
    if ("value" in $$props2)
      $$invalidate(5, value = $$props2.value);
    if ("setProperty" in $$props2)
      $$invalidate(6, setProperty = $$props2.setProperty);
  };
  return [
    propertyName,
    selector2,
    pos,
    setPropertySelector,
    setPropertyPos,
    value,
    setProperty
  ];
}
class Target extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$A, create_fragment$B, safe_not_equal, {
      propertyName: 0,
      value: 5,
      setProperty: 6
    });
  }
}
function create_fragment$A(ctx) {
  let div;
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      input = element("input");
      input.value = ctx[0];
      attr(input, "type", "number");
      attr(input, "min", "0");
      attr(input, "max", "999");
      attr(div, "class", "bbx-margin-y");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input);
      if (!mounted) {
        dispose = listen(input, "input", ctx[1]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 1 && input.value !== ctx2[0]) {
        input.value = ctx2[0];
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function instance$z($$self, $$props, $$invalidate) {
  let { propertyName } = $$props;
  let { value } = $$props;
  let { setProperty } = $$props;
  function handleInput(e) {
    let num = parseInt(e.target.value);
    setProperty(propertyName, num);
  }
  $$self.$$set = ($$props2) => {
    if ("propertyName" in $$props2)
      $$invalidate(2, propertyName = $$props2.propertyName);
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("setProperty" in $$props2)
      $$invalidate(3, setProperty = $$props2.setProperty);
  };
  return [value, handleInput, propertyName, setProperty];
}
class Number$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$z, create_fragment$A, safe_not_equal, {
      propertyName: 2,
      value: 0,
      setProperty: 3
    });
  }
}
function get_each_context$a(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i2];
  return child_ctx;
}
function create_else_block$i(ctx) {
  let span;
  let t0;
  let t1_value = ctx[1].type + "";
  let t1;
  let t2;
  return {
    c() {
      span = element("span");
      t0 = text("propertyType: ");
      t1 = text(t1_value);
      t2 = text(" is not handled");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t1_value !== (t1_value = ctx2[1].type + ""))
        set_data(t1, t1_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block_5$3(ctx) {
  let select;
  let select_value_value;
  let mounted;
  let dispose;
  let each_value = ctx[1].options;
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$a(get_each_context$a(ctx, each_value, i2));
  }
  return {
    c() {
      select = element("select");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
    },
    m(target, anchor) {
      insert(target, select, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(select, null);
      }
      select_option(select, ctx[1].value);
      if (!mounted) {
        dispose = listen(select, "input", ctx[3]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 2) {
        each_value = ctx2[1].options;
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$a(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$a(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(select, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & 2 && select_value_value !== (select_value_value = ctx2[1].value)) {
        select_option(select, ctx2[1].value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(select);
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_4$4(ctx) {
  let target;
  let current;
  target = new Target({
    props: {
      propertyName: ctx[0],
      value: ctx[1].value,
      setProperty: ctx[2]
    }
  });
  return {
    c() {
      create_component(target.$$.fragment);
    },
    m(target$1, anchor) {
      mount_component(target, target$1, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const target_changes = {};
      if (dirty & 1)
        target_changes.propertyName = ctx2[0];
      if (dirty & 2)
        target_changes.value = ctx2[1].value;
      if (dirty & 4)
        target_changes.setProperty = ctx2[2];
      target.$set(target_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(target.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(target.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(target, detaching);
    }
  };
}
function create_if_block_3$5(ctx) {
  let position;
  let current;
  position = new Position({
    props: {
      propertyName: ctx[0],
      value: ctx[1].value,
      setProperty: ctx[2]
    }
  });
  return {
    c() {
      create_component(position.$$.fragment);
    },
    m(target, anchor) {
      mount_component(position, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const position_changes = {};
      if (dirty & 1)
        position_changes.propertyName = ctx2[0];
      if (dirty & 2)
        position_changes.value = ctx2[1].value;
      if (dirty & 4)
        position_changes.setProperty = ctx2[2];
      position.$set(position_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(position.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(position.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(position, detaching);
    }
  };
}
function create_if_block_2$6(ctx) {
  let selector2;
  let current;
  selector2 = new Selector({
    props: {
      propertyName: ctx[0],
      value: ctx[1].value,
      setProperty: ctx[2]
    }
  });
  return {
    c() {
      create_component(selector2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selector2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selector_changes = {};
      if (dirty & 1)
        selector_changes.propertyName = ctx2[0];
      if (dirty & 2)
        selector_changes.value = ctx2[1].value;
      if (dirty & 4)
        selector_changes.setProperty = ctx2[2];
      selector2.$set(selector_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(selector2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selector2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selector2, detaching);
    }
  };
}
function create_if_block_1$d(ctx) {
  let numberinput;
  let current;
  numberinput = new Number$1({
    props: {
      propertyName: ctx[0],
      value: ctx[1].value,
      setProperty: ctx[2]
    }
  });
  return {
    c() {
      create_component(numberinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(numberinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const numberinput_changes = {};
      if (dirty & 1)
        numberinput_changes.propertyName = ctx2[0];
      if (dirty & 2)
        numberinput_changes.value = ctx2[1].value;
      if (dirty & 4)
        numberinput_changes.setProperty = ctx2[2];
      numberinput.$set(numberinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(numberinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(numberinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(numberinput, detaching);
    }
  };
}
function create_if_block$j(ctx) {
  let input;
  let input_value_value;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      input.value = input_value_value = ctx[1].value;
    },
    m(target, anchor) {
      insert(target, input, anchor);
      if (!mounted) {
        dispose = listen(input, "input", ctx[3]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 2 && input_value_value !== (input_value_value = ctx2[1].value) && input.value !== input_value_value) {
        input.value = input_value_value;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block$a(ctx) {
  let option;
  let t0_value = ctx[4] + "";
  let t0;
  let t1;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t0 = text(t0_value);
      t1 = space();
      option.__value = option_value_value = ctx[4];
      option.value = option.__value;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t0);
      append(option, t1);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t0_value !== (t0_value = ctx2[4] + ""))
        set_data(t0, t0_value);
      if (dirty & 2 && option_value_value !== (option_value_value = ctx2[4])) {
        option.__value = option_value_value;
        option.value = option.__value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_fragment$z(ctx) {
  let div;
  let show_if;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [
    create_if_block$j,
    create_if_block_1$d,
    create_if_block_2$6,
    create_if_block_3$5,
    create_if_block_4$4,
    create_if_block_5$3,
    create_else_block$i
  ];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (dirty & 2)
      show_if = null;
    if (ctx2[1].type === "STRING")
      return 0;
    if (ctx2[1].type === "NUMBER")
      return 1;
    if (ctx2[1].type === "SELECTOR")
      return 2;
    if (ctx2[1].type === "POSITION")
      return 3;
    if (ctx2[1].type === "TARGET")
      return 4;
    if (show_if == null)
      show_if = !!ctx2[1].type.endsWith("OPTION");
    if (show_if)
      return 5;
    return 6;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance$y($$self, $$props, $$invalidate) {
  let { propertyName } = $$props;
  let { property } = $$props;
  let { setProperty } = $$props;
  function handleInput(e) {
    setProperty(propertyName, e.target.value);
  }
  $$self.$$set = ($$props2) => {
    if ("propertyName" in $$props2)
      $$invalidate(0, propertyName = $$props2.propertyName);
    if ("property" in $$props2)
      $$invalidate(1, property = $$props2.property);
    if ("setProperty" in $$props2)
      $$invalidate(2, setProperty = $$props2.setProperty);
  };
  return [propertyName, property, setProperty, handleInput];
}
class Input extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$y, create_fragment$z, safe_not_equal, {
      propertyName: 0,
      property: 1,
      setProperty: 2
    });
  }
}
function keypressEscape(node2) {
  const handleKey = (event) => {
    if (event.key == "Escape") {
      node2.dispatchEvent(new CustomEvent("escape"));
    }
  };
  document.body.addEventListener("keydown", handleKey, true);
  return {
    destroy() {
      document.body.removeEventListener("keydown", handleKey, true);
    }
  };
}
function clickOutside(node2) {
  const handleClick = (event) => {
    if (!node2.contains(event.target)) {
      node2.dispatchEvent(new CustomEvent("outclick"));
    }
  };
  document.addEventListener("click", handleClick, true);
  return {
    destroy() {
      document.removeEventListener("click", handleClick, true);
    }
  };
}
function get_each_context$9(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[9] = list[i2];
  return child_ctx;
}
function get_each_context_1(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[1] = list[i2];
  return child_ctx;
}
function create_each_block_1(ctx) {
  let option;
  let t0_value = ctx[1] + "";
  let t0;
  let t1;
  return {
    c() {
      option = element("option");
      t0 = text(t0_value);
      t1 = space();
      option.__value = ctx[1];
      option.value = option.__value;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t0);
      append(option, t1);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_each_block$9(ctx) {
  let div;
  let em;
  let t0_value = ctx[9] + "";
  let t0;
  let t1;
  let input;
  let t2;
  let current;
  input = new Input({
    props: {
      propertyName: ctx[9],
      property: ctx[0].get(ctx[9]),
      setProperty: ctx[4]
    }
  });
  return {
    c() {
      div = element("div");
      em = element("em");
      t0 = text(t0_value);
      t1 = space();
      create_component(input.$$.fragment);
      t2 = space();
      attr(div, "class", "bbx-pad-y");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, em);
      append(em, t0);
      append(div, t1);
      mount_component(input, div, null);
      append(div, t2);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty & 1) && t0_value !== (t0_value = ctx2[9] + ""))
        set_data(t0, t0_value);
      const input_changes = {};
      if (dirty & 1)
        input_changes.propertyName = ctx2[9];
      if (dirty & 1)
        input_changes.property = ctx2[0].get(ctx2[9]);
      input.$set(input_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(input.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(input.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(input);
    }
  };
}
function create_fragment$y(ctx) {
  let div3;
  let div0;
  let t0;
  let br0;
  let t1;
  let select;
  let t2;
  let br1;
  let t3;
  let div1;
  let t4;
  let br2;
  let t5;
  let div2;
  let button;
  let t7;
  let a;
  let current;
  let mounted;
  let dispose;
  let each_value_1 = ctx[2];
  let each_blocks_1 = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks_1[i2] = create_each_block_1(get_each_context_1(ctx, each_value_1, i2));
  }
  let each_value = Object.keys(ctx[0].data);
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$9(get_each_context$9(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      t0 = text("Type:\n    ");
      br0 = element("br");
      t1 = space();
      select = element("select");
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        each_blocks_1[i2].c();
      }
      t2 = space();
      br1 = element("br");
      t3 = space();
      div1 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t4 = space();
      br2 = element("br");
      t5 = space();
      div2 = element("div");
      button = element("button");
      button.textContent = "Save";
      t7 = space();
      a = element("a");
      a.textContent = "Cancel";
      attr(div0, "class", "bbx-step__header bbx-flex-1");
      attr(div1, "class", "bbx-step__detail");
      attr(button, "class", "bbx-flex-1");
      attr(a, "class", "bbx-flex-1");
      attr(a, "href", "#");
      attr(div2, "class", "bbx-flex");
      attr(div3, "class", "bbx-step bbx-pad-2x bbx-border");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div0);
      append(div0, t0);
      append(div0, br0);
      append(div0, t1);
      append(div0, select);
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        each_blocks_1[i2].m(select, null);
      }
      select_option(select, ctx[1]);
      append(div3, t2);
      append(div3, br1);
      append(div3, t3);
      append(div3, div1);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(div1, null);
      }
      append(div3, t4);
      append(div3, br2);
      append(div3, t5);
      append(div3, div2);
      append(div2, button);
      append(div2, t7);
      append(div2, a);
      current = true;
      if (!mounted) {
        dispose = [
          listen(select, "input", ctx[3]),
          listen(button, "click", ctx[5]),
          listen(a, "click", prevent_default(ctx[6])),
          action_destroyer(keypressEscape.call(null, div3)),
          listen(div3, "escape", ctx[6]),
          action_destroyer(clickOutside.call(null, div3)),
          listen(div3, "outclick", ctx[6])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 4) {
        each_value_1 = ctx2[2];
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i2);
          if (each_blocks_1[i2]) {
            each_blocks_1[i2].p(child_ctx, dirty);
          } else {
            each_blocks_1[i2] = create_each_block_1(child_ctx);
            each_blocks_1[i2].c();
            each_blocks_1[i2].m(select, null);
          }
        }
        for (; i2 < each_blocks_1.length; i2 += 1) {
          each_blocks_1[i2].d(1);
        }
        each_blocks_1.length = each_value_1.length;
      }
      if (!current || dirty & 6) {
        select_option(select, ctx2[1]);
      }
      if (dirty & 17) {
        each_value = Object.keys(ctx2[0].data);
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$9(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$9(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div1, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$x($$self, $$props, $$invalidate) {
  let { stepTypes: stepTypes2, stepTypeDict: stepTypeDict2 } = Recorder$1;
  const dispatch = createEventDispatcher();
  let { step = new WaitForDuration(0, Date.now(), true) } = $$props;
  let stepType = step.type;
  function updateStepType(e) {
    $$invalidate(1, stepType = e.target.value);
    $$invalidate(0, step = stepTypeDict2[stepType].createDefault());
  }
  function setProperty(propertyName, value) {
    step.set(propertyName, value);
  }
  function submitHandler() {
    dispatch("save", { step });
  }
  function cancelHandler() {
    dispatch("cancel");
  }
  $$self.$$set = ($$props2) => {
    if ("step" in $$props2)
      $$invalidate(0, step = $$props2.step);
  };
  return [
    step,
    stepType,
    stepTypes2,
    updateStepType,
    setProperty,
    submitHandler,
    cancelHandler
  ];
}
class EditStep extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$x, create_fragment$y, safe_not_equal, { step: 0 });
  }
}
function create_fragment$x(ctx) {
  let div1;
  let div0;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[2].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[1], null);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      attr(div0, "role", "none");
      attr(div1, "class", "bbx-menu");
      attr(div1, "role", "menu");
      attr(div1, "aria-orientation", "vertical");
      attr(div1, "aria-labelledby", "menu-button");
      attr(div1, "tabindex", "-1");
      toggle_class(div1, "open", ctx[0]);
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(div1, "click", ctx[3]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[1], !current ? get_all_dirty_from_scope(ctx2[1]) : get_slot_changes(default_slot_template, ctx2[1], dirty, null), null);
        }
      }
      if (dirty & 1) {
        toggle_class(div1, "open", ctx2[0]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance$w($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { open = false } = $$props;
  function click_handler2(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("open" in $$props2)
      $$invalidate(0, open = $$props2.open);
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  return [open, $$scope, slots, click_handler2];
}
class Menu extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$w, create_fragment$x, safe_not_equal, { open: 0 });
  }
}
const get_items_slot_changes = (dirty) => ({});
const get_items_slot_context = (ctx) => ({});
function create_default_slot$a(ctx) {
  let current;
  const items_slot_template = ctx[3].items;
  const items_slot = create_slot(items_slot_template, ctx, ctx[5], get_items_slot_context);
  return {
    c() {
      if (items_slot)
        items_slot.c();
    },
    m(target, anchor) {
      if (items_slot) {
        items_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (items_slot) {
        if (items_slot.p && (!current || dirty & 32)) {
          update_slot_base(items_slot, items_slot_template, ctx2, ctx2[5], !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(items_slot_template, ctx2[5], dirty, get_items_slot_changes), get_items_slot_context);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(items_slot, local);
      current = true;
    },
    o(local) {
      transition_out(items_slot, local);
      current = false;
    },
    d(detaching) {
      if (items_slot)
        items_slot.d(detaching);
    }
  };
}
function create_fragment$w(ctx) {
  let div;
  let button;
  let t;
  let menu;
  let div_class_value;
  let current;
  let mounted;
  let dispose;
  menu = new Menu({
    props: {
      open: ctx[0],
      $$slots: { default: [create_default_slot$a] },
      $$scope: { ctx }
    }
  });
  menu.$on("click", ctx[2]);
  return {
    c() {
      div = element("div");
      button = element("button");
      t = space();
      create_component(menu.$$.fragment);
      attr(button, "class", "bbx-btn-x bbx-bg-overflow");
      attr(div, "class", div_class_value = "bbx-menu-ct " + ctx[1]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      append(div, t);
      mount_component(menu, div, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button, "click", ctx[4]),
          action_destroyer(keypressEscape.call(null, div)),
          listen(div, "escape", ctx[2]),
          action_destroyer(clickOutside.call(null, div)),
          listen(div, "outclick", ctx[2])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const menu_changes = {};
      if (dirty & 1)
        menu_changes.open = ctx2[0];
      if (dirty & 32) {
        menu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menu.$set(menu_changes);
      if (!current || dirty & 2 && div_class_value !== (div_class_value = "bbx-menu-ct " + ctx2[1])) {
        attr(div, "class", div_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(menu);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$v($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { open = false } = $$props;
  let { class: clazz = "" } = $$props;
  function close() {
    $$invalidate(0, open = false);
  }
  const click_handler2 = (e) => $$invalidate(0, open = !open);
  $$self.$$set = ($$props2) => {
    if ("open" in $$props2)
      $$invalidate(0, open = $$props2.open);
    if ("class" in $$props2)
      $$invalidate(1, clazz = $$props2.class);
    if ("$$scope" in $$props2)
      $$invalidate(5, $$scope = $$props2.$$scope);
  };
  return [open, clazz, close, slots, click_handler2, $$scope];
}
class MenuBtn extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$v, create_fragment$w, safe_not_equal, { open: 0, class: 1 });
  }
}
function create_fragment$v(ctx) {
  let a;
  let a_href_value;
  let a_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[3].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[2], null);
  let a_levels = [
    { href: a_href_value = "#" },
    {
      class: a_class_value = "bbx-menu-item bbx-pad px-4 py-2 text-sm " + ctx[0]
    },
    { role: "menuitem" },
    { tabindex: "-1" },
    ctx[1]
  ];
  let a_data = {};
  for (let i2 = 0; i2 < a_levels.length; i2 += 1) {
    a_data = assign$1(a_data, a_levels[i2]);
  }
  return {
    c() {
      a = element("a");
      if (default_slot)
        default_slot.c();
      set_attributes(a, a_data);
    },
    m(target, anchor) {
      insert(target, a, anchor);
      if (default_slot) {
        default_slot.m(a, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(a, "click", prevent_default(ctx[4]));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[2], !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(default_slot_template, ctx2[2], dirty, null), null);
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        { href: a_href_value },
        (!current || dirty & 1 && a_class_value !== (a_class_value = "bbx-menu-item bbx-pad px-4 py-2 text-sm " + ctx2[0])) && { class: a_class_value },
        { role: "menuitem" },
        { tabindex: "-1" },
        dirty & 2 && ctx2[1]
      ]));
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(a);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance$u($$self, $$props, $$invalidate) {
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  let { class: clazz = "" } = $$props;
  function click_handler2(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(0, clazz = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  return [clazz, $$restProps, $$scope, slots, click_handler2];
}
class MenuItem extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$u, create_fragment$v, safe_not_equal, { class: 0 });
  }
}
function create_fragment$u(ctx) {
  let div1;
  let div0;
  let div1_class_value;
  let div1_levels = [
    {
      class: div1_class_value = "bbx-progress " + ctx[0]
    },
    ctx[1]
  ];
  let div1_data = {};
  for (let i2 = 0; i2 < div1_levels.length; i2 += 1) {
    div1_data = assign$1(div1_data, div1_levels[i2]);
  }
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      attr(div0, "class", "bbx-indeterminate");
      set_attributes(div1, div1_data);
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
    },
    p(ctx2, [dirty]) {
      set_attributes(div1, div1_data = get_spread_update(div1_levels, [
        dirty & 1 && div1_class_value !== (div1_class_value = "bbx-progress " + ctx2[0]) && { class: div1_class_value },
        dirty & 2 && ctx2[1]
      ]));
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div1);
    }
  };
}
function instance$t($$self, $$props, $$invalidate) {
  const omit_props_names = ["classes"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { classes: classes2 = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("classes" in $$new_props)
      $$invalidate(0, classes2 = $$new_props.classes);
  };
  return [classes2, $$restProps];
}
class Progress extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$t, create_fragment$u, safe_not_equal, { classes: 0 });
  }
}
function create_else_block$h(ctx) {
  let div;
  let editstep;
  let current;
  let mounted;
  let dispose;
  editstep = new EditStep({ props: { step: ctx[0].clone() } });
  editstep.$on("cancel", ctx[6]);
  editstep.$on("save", ctx[8]);
  return {
    c() {
      div = element("div");
      create_component(editstep.$$.fragment);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(editstep, div, null);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(keypressEscape.call(null, div)),
          listen(div, "escape", ctx[6]),
          action_destroyer(clickOutside.call(null, div)),
          listen(div, "outclick", ctx[6])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const editstep_changes = {};
      if (dirty & 1)
        editstep_changes.step = ctx2[0].clone();
      editstep.$set(editstep_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(editstep.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(editstep.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(editstep);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$i(ctx) {
  let t0;
  let div4;
  let div2;
  let div0;
  let t1_value = ctx[0].name + "";
  let t1;
  let t2;
  let div1;
  let menubtn;
  let t3;
  let div3;
  let t4;
  let current;
  let if_block0 = ctx[4].active && create_if_block_3$4();
  menubtn = new MenuBtn({
    props: {
      open: menuOpen,
      $$slots: { items: [create_items_slot$1] },
      $$scope: { ctx }
    }
  });
  let if_block1 = ctx[4].detail && create_if_block_2$5(ctx);
  let if_block2 = ctx[4].err && create_if_block_1$c(ctx);
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      div4 = element("div");
      div2 = element("div");
      div0 = element("div");
      t1 = text(t1_value);
      t2 = space();
      div1 = element("div");
      create_component(menubtn.$$.fragment);
      t3 = space();
      div3 = element("div");
      if (if_block1)
        if_block1.c();
      t4 = space();
      if (if_block2)
        if_block2.c();
      attr(div0, "class", "bbx-step__header bbx-flex-1");
      attr(div2, "class", "bbx-flex");
      attr(div3, "class", "bbx-step__detail");
      attr(div4, "class", "bbx-step bbx-pad-2x bbx-border");
      toggle_class(div4, "active", ctx[4].active);
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t0, anchor);
      insert(target, div4, anchor);
      append(div4, div2);
      append(div2, div0);
      append(div0, t1);
      append(div2, t2);
      append(div2, div1);
      mount_component(menubtn, div1, null);
      append(div4, t3);
      append(div4, div3);
      if (if_block1)
        if_block1.m(div3, null);
      append(div4, t4);
      if (if_block2)
        if_block2.m(div4, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[4].active) {
        if (if_block0) {
          if (dirty & 16) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_3$4();
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if ((!current || dirty & 1) && t1_value !== (t1_value = ctx2[0].name + ""))
        set_data(t1, t1_value);
      const menubtn_changes = {};
      if (dirty & 131079) {
        menubtn_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menubtn.$set(menubtn_changes);
      if (ctx2[4].detail) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_2$5(ctx2);
          if_block1.c();
          if_block1.m(div3, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (ctx2[4].err) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_1$c(ctx2);
          if_block2.c();
          if_block2.m(div4, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (dirty & 16) {
        toggle_class(div4, "active", ctx2[4].active);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(menubtn.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(menubtn.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div4);
      destroy_component(menubtn);
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
    }
  };
}
function create_if_block_3$4(ctx) {
  let progress;
  let current;
  progress = new Progress({ props: { style: "margin-top: -2px;" } });
  return {
    c() {
      create_component(progress.$$.fragment);
    },
    m(target, anchor) {
      mount_component(progress, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(progress.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(progress.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(progress, detaching);
    }
  };
}
function create_default_slot_3(ctx) {
  let t;
  return {
    c() {
      t = text("Edit Step");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_2$2(ctx) {
  let t;
  return {
    c() {
      t = text("Insert Step Before");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_1$5(ctx) {
  let t;
  return {
    c() {
      t = text("Insert Step After");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$9(ctx) {
  let t;
  return {
    c() {
      t = text("Delete");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_items_slot$1(ctx) {
  let menuitem0;
  let t0;
  let menuitem1;
  let t1;
  let menuitem2;
  let t2;
  let menuitem3;
  let current;
  menuitem0 = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    }
  });
  menuitem0.$on("click", ctx[7]);
  menuitem1 = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot_2$2] },
      $$scope: { ctx }
    }
  });
  menuitem1.$on("click", ctx[13]);
  menuitem2 = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot_1$5] },
      $$scope: { ctx }
    }
  });
  menuitem2.$on("click", ctx[14]);
  menuitem3 = new MenuItem({
    props: {
      class: "bbx-danger",
      $$slots: { default: [create_default_slot$9] },
      $$scope: { ctx }
    }
  });
  menuitem3.$on("click", ctx[15]);
  return {
    c() {
      create_component(menuitem0.$$.fragment);
      t0 = space();
      create_component(menuitem1.$$.fragment);
      t1 = space();
      create_component(menuitem2.$$.fragment);
      t2 = space();
      create_component(menuitem3.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitem0, target, anchor);
      insert(target, t0, anchor);
      mount_component(menuitem1, target, anchor);
      insert(target, t1, anchor);
      mount_component(menuitem2, target, anchor);
      insert(target, t2, anchor);
      mount_component(menuitem3, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitem0_changes = {};
      if (dirty & 131072) {
        menuitem0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem0.$set(menuitem0_changes);
      const menuitem1_changes = {};
      if (dirty & 131072) {
        menuitem1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem1.$set(menuitem1_changes);
      const menuitem2_changes = {};
      if (dirty & 131072) {
        menuitem2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem2.$set(menuitem2_changes);
      const menuitem3_changes = {};
      if (dirty & 131072) {
        menuitem3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem3.$set(menuitem3_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem0.$$.fragment, local);
      transition_in(menuitem1.$$.fragment, local);
      transition_in(menuitem2.$$.fragment, local);
      transition_in(menuitem3.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem0.$$.fragment, local);
      transition_out(menuitem1.$$.fragment, local);
      transition_out(menuitem2.$$.fragment, local);
      transition_out(menuitem3.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem0, detaching);
      if (detaching)
        detach(t0);
      destroy_component(menuitem1, detaching);
      if (detaching)
        detach(t1);
      destroy_component(menuitem2, detaching);
      if (detaching)
        detach(t2);
      destroy_component(menuitem3, detaching);
    }
  };
}
function create_if_block_2$5(ctx) {
  let t_value = ctx[4].detail + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 16 && t_value !== (t_value = ctx2[4].detail + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_1$c(ctx) {
  let div;
  let t_value = ctx[4].err + "";
  let t;
  return {
    c() {
      div = element("div");
      t = text(t_value);
      attr(div, "class", "bbx-error bbx-margin-y");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & 16 && t_value !== (t_value = ctx2[4].err + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$t(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block$i, create_else_block$h];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!ctx2[3])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_blocks[current_block_type_index].d();
    }
  };
}
let menuOpen = false;
function getStepDetail(step) {
  let selector2 = "";
  try {
    selector2 = step.get("selector").value.value;
  } catch (e) {
  }
  if (step.is("TYPE")) {
    return `${selector2} - ${step.value}`;
  } else if (step.is("KEYPRESS")) {
    return step.repr;
  } else if (step.is("SCROLL")) {
    return `(${step.left}, ${step.top})`;
  } else if (step.is("WAIT_FOR_DURATION")) {
    return `duration: ${step.get("duration").value}s`;
  }
  return selector2 || "";
}
function instance$s($$self, $$props, $$invalidate) {
  let { step } = $$props;
  let { playingStatus = {} } = $$props;
  let { pos } = $$props;
  let { updateInsertPosition } = $$props;
  let { replaceStep } = $$props;
  let { stopRecording } = $$props;
  const dispatch = createEventDispatcher();
  const STATUS = {
    ACTIVE: "ACTIVE",
    ERR: "ERR",
    DONE: "DONE",
    PENDING: "PENDING"
  };
  let editMode = false;
  function closeEditMode() {
    $$invalidate(3, editMode = false);
  }
  function openEditMode() {
    $$invalidate(3, editMode = true);
    stopRecording();
  }
  function handleSave(e) {
    replaceStep(e.detail.step, pos);
  }
  let curStep;
  let meta = {};
  const click_handler2 = () => updateInsertPosition(pos);
  const click_handler_1 = () => updateInsertPosition(pos + 1);
  const click_handler_2 = (e) => (e.preventDefault(), dispatch("delete", step));
  $$self.$$set = ($$props2) => {
    if ("step" in $$props2)
      $$invalidate(0, step = $$props2.step);
    if ("playingStatus" in $$props2)
      $$invalidate(9, playingStatus = $$props2.playingStatus);
    if ("pos" in $$props2)
      $$invalidate(1, pos = $$props2.pos);
    if ("updateInsertPosition" in $$props2)
      $$invalidate(2, updateInsertPosition = $$props2.updateInsertPosition);
    if ("replaceStep" in $$props2)
      $$invalidate(10, replaceStep = $$props2.replaceStep);
    if ("stopRecording" in $$props2)
      $$invalidate(11, stopRecording = $$props2.stopRecording);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 512) {
      $$invalidate(12, curStep = playingStatus.step);
    }
    if ($$self.$$.dirty & 4609) {
      $$invalidate(4, meta = {
        name: step.name,
        detail: getStepDetail(step),
        active: step == curStep && playingStatus.status == STATUS.ACTIVE,
        err: step == curStep && playingStatus.msg
      });
    }
  };
  return [
    step,
    pos,
    updateInsertPosition,
    editMode,
    meta,
    dispatch,
    closeEditMode,
    openEditMode,
    handleSave,
    playingStatus,
    replaceStep,
    stopRecording,
    curStep,
    click_handler2,
    click_handler_1,
    click_handler_2
  ];
}
class Step extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$s, create_fragment$t, safe_not_equal, {
      step: 0,
      playingStatus: 9,
      pos: 1,
      updateInsertPosition: 2,
      replaceStep: 10,
      stopRecording: 11
    });
  }
}
const get_end_slot_changes = (dirty) => ({});
const get_end_slot_context = (ctx) => ({});
function get_each_context$8(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[15] = list[i2];
  child_ctx[17] = i2;
  return child_ctx;
}
function create_else_block_1$3(ctx) {
  let t;
  return {
    c() {
      t = text("No steps recorded yet.");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_1$b(ctx) {
  let editstep;
  let current;
  editstep = new EditStep({});
  editstep.$on("cancel", ctx[9]);
  editstep.$on("save", ctx[8]);
  return {
    c() {
      create_component(editstep.$$.fragment);
    },
    m(target, anchor) {
      mount_component(editstep, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(editstep.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(editstep.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(editstep, detaching);
    }
  };
}
function create_each_block$8(key_1, ctx) {
  let first;
  let t;
  let step;
  let current;
  let if_block = ctx[6] === ctx[17] && create_if_block_1$b(ctx);
  step = new Step({
    props: {
      step: ctx[15],
      playingStatus: ctx[2],
      pos: ctx[17],
      updateInsertPosition: ctx[7],
      replaceStep: ctx[4],
      stopRecording: ctx[5]
    }
  });
  step.$on("delete", ctx[13]);
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      if (if_block)
        if_block.c();
      t = space();
      create_component(step.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t, anchor);
      mount_component(step, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (ctx[6] === ctx[17]) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & 72) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$b(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      const step_changes = {};
      if (dirty & 8)
        step_changes.step = ctx[15];
      if (dirty & 4)
        step_changes.playingStatus = ctx[2];
      if (dirty & 8)
        step_changes.pos = ctx[17];
      if (dirty & 16)
        step_changes.replaceStep = ctx[4];
      if (dirty & 32)
        step_changes.stopRecording = ctx[5];
      step.$set(step_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(step.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(step.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t);
      destroy_component(step, detaching);
    }
  };
}
function create_else_block$g(ctx) {
  let div;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<button class="bbx-border-none">+</button>`;
      attr(div, "class", "bbx-flex bbx-justify-center");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (!mounted) {
        dispose = listen(div, "click", ctx[14]);
        mounted = true;
      }
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$h(ctx) {
  let editstep;
  let current;
  editstep = new EditStep({});
  editstep.$on("cancel", ctx[9]);
  editstep.$on("save", ctx[8]);
  return {
    c() {
      create_component(editstep.$$.fragment);
    },
    m(target, anchor) {
      mount_component(editstep, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(editstep.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(editstep.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(editstep, detaching);
    }
  };
}
function create_fragment$s(ctx) {
  let div1;
  let t0;
  let div0;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t1;
  let current_block_type_index;
  let if_block;
  let t2;
  let div1_class_value;
  let current;
  const default_slot_template = ctx[12].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[11], null);
  let each_value = ctx[3];
  const get_key = (ctx2) => ctx2[15];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$8(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$8(key, child_ctx));
  }
  let each_1_else = null;
  if (!each_value.length) {
    each_1_else = create_else_block_1$3();
  }
  const if_block_creators = [create_if_block$h, create_else_block$g];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[6] === ctx2[3].length)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const end_slot_template = ctx[12].end;
  const end_slot = create_slot(end_slot_template, ctx, ctx[11], get_end_slot_context);
  return {
    c() {
      div1 = element("div");
      if (default_slot)
        default_slot.c();
      t0 = space();
      div0 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      if (each_1_else) {
        each_1_else.c();
      }
      t1 = space();
      if_block.c();
      t2 = space();
      if (end_slot)
        end_slot.c();
      attr(div0, "class", "bbx-steps bbx-pad bbx-gap-2x");
      toggle_class(div0, "active", ctx[1]);
      attr(div1, "class", div1_class_value = "bbx-sidebar " + ctx[0]);
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      append(div1, t0);
      append(div1, div0);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(div0, null);
      }
      if (each_1_else) {
        each_1_else.m(div0, null);
      }
      append(div0, t1);
      if_blocks[current_block_type_index].m(div0, null);
      append(div0, t2);
      if (end_slot) {
        end_slot.m(div0, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2048)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[11], !current ? get_all_dirty_from_scope(ctx2[11]) : get_slot_changes(default_slot_template, ctx2[11], dirty, null), null);
        }
      }
      if (dirty & 1020) {
        each_value = ctx2[3];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div0, outro_and_destroy_block, create_each_block$8, t1, get_each_context$8);
        check_outros();
        if (each_value.length) {
          if (each_1_else) {
            each_1_else.d(1);
            each_1_else = null;
          }
        } else if (!each_1_else) {
          each_1_else = create_else_block_1$3();
          each_1_else.c();
          each_1_else.m(div0, t1);
        }
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div0, t2);
      }
      if (end_slot) {
        if (end_slot.p && (!current || dirty & 2048)) {
          update_slot_base(end_slot, end_slot_template, ctx2, ctx2[11], !current ? get_all_dirty_from_scope(ctx2[11]) : get_slot_changes(end_slot_template, ctx2[11], dirty, get_end_slot_changes), get_end_slot_context);
        }
      }
      if (dirty & 2) {
        toggle_class(div0, "active", ctx2[1]);
      }
      if (!current || dirty & 1 && div1_class_value !== (div1_class_value = "bbx-sidebar " + ctx2[0])) {
        attr(div1, "class", div1_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(if_block);
      transition_in(end_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(if_block);
      transition_out(end_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (default_slot)
        default_slot.d(detaching);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      if (each_1_else)
        each_1_else.d();
      if_blocks[current_block_type_index].d();
      if (end_slot)
        end_slot.d(detaching);
    }
  };
}
function instance$r($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { class: clazz = "" } = $$props;
  let { playing } = $$props;
  let { playingStatus = {} } = $$props;
  let { steps } = $$props;
  let { addStep } = $$props;
  let { replaceStep } = $$props;
  let { stopRecording } = $$props;
  let insertStepAt = -1;
  function updateInsertPosition(pos) {
    stopRecording();
    $$invalidate(6, insertStepAt = pos);
  }
  function handleSave(e) {
    let newStep = e.detail.step;
    addStep(newStep, insertStepAt);
    $$invalidate(6, insertStepAt = -1);
  }
  function reset() {
    $$invalidate(6, insertStepAt = -1);
  }
  function delete_handler(event) {
    bubble.call(this, $$self, event);
  }
  const click_handler2 = () => $$invalidate(6, insertStepAt = steps.length);
  $$self.$$set = ($$props2) => {
    if ("class" in $$props2)
      $$invalidate(0, clazz = $$props2.class);
    if ("playing" in $$props2)
      $$invalidate(1, playing = $$props2.playing);
    if ("playingStatus" in $$props2)
      $$invalidate(2, playingStatus = $$props2.playingStatus);
    if ("steps" in $$props2)
      $$invalidate(3, steps = $$props2.steps);
    if ("addStep" in $$props2)
      $$invalidate(10, addStep = $$props2.addStep);
    if ("replaceStep" in $$props2)
      $$invalidate(4, replaceStep = $$props2.replaceStep);
    if ("stopRecording" in $$props2)
      $$invalidate(5, stopRecording = $$props2.stopRecording);
    if ("$$scope" in $$props2)
      $$invalidate(11, $$scope = $$props2.$$scope);
  };
  return [
    clazz,
    playing,
    playingStatus,
    steps,
    replaceStep,
    stopRecording,
    insertStepAt,
    updateInsertPosition,
    handleSave,
    reset,
    addStep,
    $$scope,
    slots,
    delete_handler,
    click_handler2
  ];
}
class Sidebar extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$r, create_fragment$s, safe_not_equal, {
      class: 0,
      playing: 1,
      playingStatus: 2,
      steps: 3,
      addStep: 10,
      replaceStep: 4,
      stopRecording: 5
    });
  }
}
function create_else_block$f(ctx) {
  let t0;
  let a;
  let t1_value = ctx[4].steps.length + "";
  let t1;
  let t2;
  let mounted;
  let dispose;
  let if_block = ctx[6] && create_if_block_1$a();
  return {
    c() {
      if (if_block)
        if_block.c();
      t0 = space();
      a = element("a");
      t1 = text(t1_value);
      t2 = text(" steps");
      attr(a, "href", "#");
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t0, anchor);
      insert(target, a, anchor);
      append(a, t1);
      append(a, t2);
      if (!mounted) {
        dispose = listen(a, "click", prevent_default(ctx[12]));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (ctx2[6]) {
        if (if_block)
          ;
        else {
          if_block = create_if_block_1$a();
          if_block.c();
          if_block.m(t0.parentNode, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 16 && t1_value !== (t1_value = ctx2[4].steps.length + ""))
        set_data(t1, t1_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(a);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$g(ctx) {
  let div1;
  let div0;
  let button0;
  let t1;
  let button1;
  let t3;
  let sidebar;
  let current;
  let mounted;
  let dispose;
  sidebar = new Sidebar({
    props: {
      macro: ctx[0],
      steps: ctx[7]
    }
  });
  sidebar.$on("delete", ctx[8]);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      button0 = element("button");
      button0.textContent = "Save";
      t1 = space();
      button1 = element("button");
      button1.textContent = "Cancel";
      t3 = space();
      create_component(sidebar.$$.fragment);
      attr(div0, "class", "flex gap-2 ml-2");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, button0);
      append(div0, t1);
      append(div0, button1);
      append(div1, t3);
      mount_component(sidebar, div1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[9]),
          listen(button1, "click", ctx[11])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const sidebar_changes = {};
      if (dirty & 1)
        sidebar_changes.macro = ctx2[0];
      if (dirty & 128)
        sidebar_changes.steps = ctx2[7];
      sidebar.$set(sidebar_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sidebar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sidebar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(sidebar);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_1$a(ctx) {
  let t;
  return {
    c() {
      t = text("Saving...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$8(ctx) {
  let i2;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", "fa fa-trash-o error");
      set_style(i2, "font-size", "1.5em");
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(i2);
    }
  };
}
function create_fragment$r(ctx) {
  let tr;
  let td0;
  let div2;
  let t0_value = ctx[4].name + "";
  let t0;
  let div1;
  let div0;
  let t1_value = (ctx[4].meta.url || "") + "";
  let t1;
  let t2;
  let td1;
  let current_block_type_index;
  let if_block;
  let t3;
  let td2;
  let button0;
  let t5;
  let button1;
  let t7;
  let td3;
  let confirmbtn;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block$g, create_else_block$f];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[5])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  confirmbtn = new ConfirmBtn({
    props: {
      alignRight: "1",
      $$slots: { default: [create_default_slot$8] },
      $$scope: { ctx }
    }
  });
  confirmbtn.$on("click", ctx[15]);
  return {
    c() {
      tr = element("tr");
      td0 = element("td");
      div2 = element("div");
      t0 = text(t0_value);
      div1 = element("div");
      div0 = element("div");
      t1 = text(t1_value);
      t2 = space();
      td1 = element("td");
      if_block.c();
      t3 = space();
      td2 = element("td");
      button0 = element("button");
      button0.textContent = "Open Recorder";
      t5 = space();
      button1 = element("button");
      button1.textContent = "View Monitors";
      t7 = space();
      td3 = element("td");
      create_component(confirmbtn.$$.fragment);
      attr(button0, "class", "btn btn-default btn-xs");
      attr(button1, "class", "btn btn-default btn-xs");
      attr(td3, "title", "Delete");
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td0);
      append(td0, div2);
      append(div2, t0);
      append(div2, div1);
      append(div1, div0);
      append(div0, t1);
      append(tr, t2);
      append(tr, td1);
      if_blocks[current_block_type_index].m(td1, null);
      append(tr, t3);
      append(tr, td2);
      append(td2, button0);
      append(td2, t5);
      append(td2, button1);
      append(tr, t7);
      append(tr, td3);
      mount_component(confirmbtn, td3, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[13]),
          listen(button1, "click", ctx[14])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & 16) && t0_value !== (t0_value = ctx2[4].name + ""))
        set_data(t0, t0_value);
      if ((!current || dirty & 16) && t1_value !== (t1_value = (ctx2[4].meta.url || "") + ""))
        set_data(t1, t1_value);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(td1, null);
      }
      const confirmbtn_changes = {};
      if (dirty & 65536) {
        confirmbtn_changes.$$scope = { dirty, ctx: ctx2 };
      }
      confirmbtn.$set(confirmbtn_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(confirmbtn.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(confirmbtn.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(tr);
      if_blocks[current_block_type_index].d();
      destroy_component(confirmbtn);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$q($$self, $$props, $$invalidate) {
  let $macro, $$unsubscribe_macro = noop, $$subscribe_macro = () => ($$unsubscribe_macro(), $$unsubscribe_macro = subscribe(macro, ($$value) => $$invalidate(4, $macro = $$value)), macro);
  $$self.$$.on_destroy.push(() => $$unsubscribe_macro());
  let { macro } = $$props;
  $$subscribe_macro();
  let { onSaveSteps: onSaveSteps2 } = $$props;
  let { openBrowser } = $$props;
  let { showMonitors } = $$props;
  let { onDelete } = $$props;
  let expanded = false;
  let saving = false;
  let copy = [...$macro.steps];
  function onDeleteStep(e) {
    let step = e.detail;
    let index2 = copy.indexOf(step);
    copy.splice(index2, 1);
    $$invalidate(7, copy = [...copy]);
  }
  async function onSave() {
    $$invalidate(5, expanded = false);
    $$invalidate(6, saving = true);
    await macro.save({ steps: copy });
    $$invalidate(6, saving = false);
  }
  const click_handler2 = (e) => $$invalidate(5, expanded = false);
  const click_handler_1 = (e) => $$invalidate(5, expanded = true);
  const click_handler_2 = (e) => openBrowser(macro);
  const click_handler_3 = (e) => showMonitors($macro);
  const click_handler_4 = (e) => onDelete(macro);
  $$self.$$set = ($$props2) => {
    if ("macro" in $$props2)
      $$subscribe_macro($$invalidate(0, macro = $$props2.macro));
    if ("onSaveSteps" in $$props2)
      $$invalidate(10, onSaveSteps2 = $$props2.onSaveSteps);
    if ("openBrowser" in $$props2)
      $$invalidate(1, openBrowser = $$props2.openBrowser);
    if ("showMonitors" in $$props2)
      $$invalidate(2, showMonitors = $$props2.showMonitors);
    if ("onDelete" in $$props2)
      $$invalidate(3, onDelete = $$props2.onDelete);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 16) {
      $$invalidate(7, copy = [...$macro.steps]);
    }
  };
  return [
    macro,
    openBrowser,
    showMonitors,
    onDelete,
    $macro,
    expanded,
    saving,
    copy,
    onDeleteStep,
    onSave,
    onSaveSteps2,
    click_handler2,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    click_handler_4
  ];
}
class Macro extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$q, create_fragment$r, safe_not_equal, {
      macro: 0,
      onSaveSteps: 10,
      openBrowser: 1,
      showMonitors: 2,
      onDelete: 3
    });
  }
}
function create_fragment$q(ctx) {
  let div;
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      input = element("input");
      attr(input, "type", "text");
      attr(input, "class", "form-control xform-control-sm p-1");
      attr(input, "placeholder", "Search...");
      attr(div, "class", "form-group mb-0 mr-6");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input);
      set_input_value(input, ctx[0]);
      if (!mounted) {
        dispose = [
          listen(input, "input", ctx[2]),
          listen(input, "input", ctx[1])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 1 && input.value !== ctx2[0]) {
        set_input_value(input, ctx2[0]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$p($$self, $$props, $$invalidate) {
  const dispatch = createEventDispatcher();
  let phrase = "";
  function onInput() {
    dispatch("search", { phrase: phrase.trim() });
  }
  function input_input_handler() {
    phrase = this.value;
    $$invalidate(0, phrase);
  }
  return [phrase, onInput, input_input_handler];
}
class SearchBar extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$p, create_fragment$q, safe_not_equal, {});
  }
}
function get_each_context$7(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i2];
  child_ctx[13] = i2;
  return child_ctx;
}
function create_catch_block$3(ctx) {
  return {
    c: noop,
    m: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$3(ctx) {
  return {
    c: noop,
    m: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_pending_block$3(ctx) {
  let td;
  let loader;
  let current;
  loader = new Loader({});
  return {
    c() {
      td = element("td");
      create_component(loader.$$.fragment);
      attr(td, "colspan", "4");
    },
    m(target, anchor) {
      insert(target, td, anchor);
      mount_component(loader, td, null);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(td);
      destroy_component(loader);
    }
  };
}
function create_else_block$e(ctx) {
  let tr;
  return {
    c() {
      tr = element("tr");
      tr.innerHTML = `<td>No macro found. 
        </td>`;
    },
    m(target, anchor) {
      insert(target, tr, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(tr);
    }
  };
}
function create_each_block$7(key_1, ctx) {
  let first;
  let macro;
  let current;
  macro = new Macro({
    props: {
      macro: ctx[11],
      onSaveSteps,
      openBrowser: ctx[1],
      showMonitors: ctx[2],
      onDelete: ctx[0]
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(macro.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(macro, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const macro_changes = {};
      if (dirty & 16)
        macro_changes.macro = ctx[11];
      if (dirty & 2)
        macro_changes.openBrowser = ctx[1];
      if (dirty & 4)
        macro_changes.showMonitors = ctx[2];
      if (dirty & 1)
        macro_changes.onDelete = ctx[0];
      macro.$set(macro_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(macro.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(macro.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      destroy_component(macro, detaching);
    }
  };
}
function create_fragment$p(ctx) {
  let div3;
  let div2;
  let div0;
  let h3;
  let t1;
  let small;
  let t2;
  let a;
  let t3;
  let t4;
  let div1;
  let t5;
  let searchbar;
  let t6;
  let listpager;
  let t7;
  let sortby;
  let t8;
  let table;
  let tbody;
  let tr0;
  let td;
  let t9;
  let tr1;
  let t16;
  let promise;
  let t17;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  searchbar = new SearchBar({});
  searchbar.$on("search", ctx[6]);
  listpager = new ListPager({ props: { store: ctx[3] } });
  sortby = new SortBy({
    props: {
      onSort: ctx[7],
      sortingFields: ctx[5],
      currentFieldName: ctx[4].orderBy
    }
  });
  const default_slot_template = ctx[9].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[8], null);
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$3,
    then: create_then_block$3,
    catch: create_catch_block$3,
    blocks: [, , ,]
  };
  handle_promise(promise = ctx[4].fetchPromise, info);
  let each_value = ctx[4].models;
  const get_key = (ctx2) => ctx2[11].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$7(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$7(key, child_ctx));
  }
  let each_1_else = null;
  if (!each_value.length) {
    each_1_else = create_else_block$e();
  }
  return {
    c() {
      div3 = element("div");
      div2 = element("div");
      div0 = element("div");
      h3 = element("h3");
      h3.textContent = "Macros (beta)";
      t1 = space();
      small = element("small");
      t2 = text("Create and use macros to perform automated actions.\n      ");
      a = element("a");
      t3 = text("Learn More");
      t4 = space();
      div1 = element("div");
      t5 = space();
      create_component(searchbar.$$.fragment);
      t6 = space();
      create_component(listpager.$$.fragment);
      t7 = space();
      create_component(sortby.$$.fragment);
      t8 = space();
      table = element("table");
      tbody = element("tbody");
      tr0 = element("tr");
      td = element("td");
      if (default_slot)
        default_slot.c();
      t9 = space();
      tr1 = element("tr");
      tr1.innerHTML = `<th style="width: 50%;">Name</th> 
        <th>Recorded Steps</th> 
        <th>Actions</th> 
        <th style="width: 20px"></th>`;
      t16 = space();
      info.block.c();
      t17 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      if (each_1_else) {
        each_1_else.c();
      }
      attr(a, "href", window.URL_WEBSITE + "/kb/help/macro-to-record-replay-actions");
      attr(a, "target", "_blank");
      set_style(div0, "flex", "1");
      attr(div1, "class", "flex-1");
      attr(div2, "class", "panel-heading flex items-center");
      attr(td, "colspan", "4");
      set_style(td, "background-color", "#eee");
      attr(tr1, "class", "bg-gray-200");
      attr(table, "class", "table");
      attr(div3, "class", "panel panel-default");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div2);
      append(div2, div0);
      append(div0, h3);
      append(div0, t1);
      append(div0, small);
      append(small, t2);
      append(small, a);
      append(a, t3);
      append(div2, t4);
      append(div2, div1);
      append(div2, t5);
      mount_component(searchbar, div2, null);
      append(div2, t6);
      mount_component(listpager, div2, null);
      append(div2, t7);
      mount_component(sortby, div2, null);
      append(div3, t8);
      append(div3, table);
      append(table, tbody);
      append(tbody, tr0);
      append(tr0, td);
      if (default_slot) {
        default_slot.m(td, null);
      }
      append(tbody, t9);
      append(tbody, tr1);
      append(tbody, t16);
      info.block.m(tbody, info.anchor = null);
      info.mount = () => tbody;
      info.anchor = t17;
      append(tbody, t17);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(tbody, null);
      }
      if (each_1_else) {
        each_1_else.m(tbody, null);
      }
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      const listpager_changes = {};
      if (dirty & 8)
        listpager_changes.store = ctx[3];
      listpager.$set(listpager_changes);
      const sortby_changes = {};
      if (dirty & 16)
        sortby_changes.currentFieldName = ctx[4].orderBy;
      sortby.$set(sortby_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 256)) {
          update_slot_base(default_slot, default_slot_template, ctx, ctx[8], !current ? get_all_dirty_from_scope(ctx[8]) : get_slot_changes(default_slot_template, ctx[8], dirty, null), null);
        }
      }
      info.ctx = ctx;
      dirty & 16 && promise !== (promise = ctx[4].fetchPromise) && handle_promise(promise, info);
      if (dirty & 23) {
        each_value = ctx[4].models;
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, tbody, outro_and_destroy_block, create_each_block$7, null, get_each_context$7);
        check_outros();
        if (!each_value.length && each_1_else) {
          each_1_else.p(ctx, dirty);
        } else if (!each_value.length) {
          each_1_else = create_else_block$e();
          each_1_else.c();
          each_1_else.m(tbody, null);
        } else if (each_1_else) {
          each_1_else.d(1);
          each_1_else = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(searchbar.$$.fragment, local);
      transition_in(listpager.$$.fragment, local);
      transition_in(sortby.$$.fragment, local);
      transition_in(default_slot, local);
      transition_in(info.block);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(searchbar.$$.fragment, local);
      transition_out(listpager.$$.fragment, local);
      transition_out(sortby.$$.fragment, local);
      transition_out(default_slot, local);
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      destroy_component(searchbar);
      destroy_component(listpager);
      destroy_component(sortby);
      if (default_slot)
        default_slot.d(detaching);
      info.block.d();
      info.token = null;
      info = null;
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      if (each_1_else)
        each_1_else.d();
    }
  };
}
async function onSaveSteps(e) {
  let macro = e.detail;
  await macro.save();
}
function instance$o($$self, $$props, $$invalidate) {
  let $store;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { onDelete } = $$props;
  let { openBrowser } = $$props;
  let { showMonitors } = $$props;
  let searchQuery = "";
  let sortingFields = [
    { value: "-ts", label: "Newest First" },
    { value: "ts", label: "Oldest First" },
    { value: "name", label: "Name" },
    {
      value: "-name",
      label: "Name - Descending"
    }
  ];
  let store2 = getContext$1("store");
  component_subscribe($$self, store2, (value) => $$invalidate(4, $store = value));
  async function onSearch2(e) {
    let { phrase } = e.detail;
    if (!phrase) {
      store2.setQuery({});
      return await store2.fetch({ reset: true });
    }
    searchQuery = `%${phrase}%`;
    store2.setQuery({
      $or: {
        "name.ilike": searchQuery,
        "meta:->>'url'.ilike": searchQuery
      }
    });
    return await store2.fetch({ reset: true });
  }
  async function onSort(by) {
    $$invalidate(3, store2.orderBy = by, store2);
    await store2.fetch({ reset: true });
  }
  $$self.$$set = ($$props2) => {
    if ("onDelete" in $$props2)
      $$invalidate(0, onDelete = $$props2.onDelete);
    if ("openBrowser" in $$props2)
      $$invalidate(1, openBrowser = $$props2.openBrowser);
    if ("showMonitors" in $$props2)
      $$invalidate(2, showMonitors = $$props2.showMonitors);
    if ("$$scope" in $$props2)
      $$invalidate(8, $$scope = $$props2.$$scope);
  };
  return [
    onDelete,
    openBrowser,
    showMonitors,
    store2,
    $store,
    sortingFields,
    onSearch2,
    onSort,
    $$scope,
    slots
  ];
}
class List$4 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$o, create_fragment$p, safe_not_equal, {
      onDelete: 0,
      openBrowser: 1,
      showMonitors: 2
    });
  }
}
var Modal_svelte_svelte_type_style_lang = "";
function create_fragment$o(ctx) {
  let div3;
  let div2;
  let div1;
  let div0;
  let div2_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  return {
    c() {
      div3 = element("div");
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      attr(div0, "class", "modal-body p-0");
      attr(div1, "class", "modal-content");
      attr(div2, "class", div2_class_value = "modal-dialog " + ctx[0] + " svelte-17wlcl9");
      attr(div2, "role", "document");
      attr(div3, "class", "modal");
      attr(div3, "tabindex", "-1");
      attr(div3, "role", "dialog");
      set_style(div3, "display", "block");
      set_style(div3, "background-color", "#fffc");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div2);
      append(div2, div1);
      append(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      ctx[5](div3);
      current = true;
      if (!mounted) {
        dispose = listen(window, "keydown", ctx[2]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[3], !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null), null);
        }
      }
      if (!current || dirty & 1 && div2_class_value !== (div2_class_value = "modal-dialog " + ctx2[0] + " svelte-17wlcl9")) {
        attr(div2, "class", div2_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      if (default_slot)
        default_slot.d(detaching);
      ctx[5](null);
      mounted = false;
      dispose();
    }
  };
}
function instance$n($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { widthClass = "" } = $$props;
  let elModal;
  createEventDispatcher();
  const handle_keydown = (e) => {
    if (e.key === "Tab") {
      const nodes = elModal.querySelectorAll("*");
      const tabbable = Array.from(nodes).filter((n) => n.tabIndex >= 0);
      let index2 = tabbable.indexOf(document.activeElement);
      if (index2 === -1 && e.shiftKey)
        index2 = 0;
      index2 += tabbable.length + (e.shiftKey ? -1 : 1);
      index2 %= tabbable.length;
      tabbable[index2].focus();
      e.preventDefault();
    }
  };
  const lastFocued = document.activeElement;
  if (lastFocued) {
    onDestroy(() => {
      lastFocued.focus();
    });
  }
  function div3_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elModal = $$value;
      $$invalidate(1, elModal);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("widthClass" in $$props2)
      $$invalidate(0, widthClass = $$props2.widthClass);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [widthClass, elModal, handle_keydown, $$scope, slots, div3_binding];
}
class Modal$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$n, create_fragment$o, safe_not_equal, { widthClass: 0 });
  }
}
var index = "";
function toMean(cum, curr, i2, _2) {
  return cum + (curr - cum) / (i2 + 1);
}
function toMax(cum, curr) {
  return curr > cum ? curr : cum;
}
function toMin(cum, curr) {
  return curr > cum ? cum : curr;
}
function getWordArr(word) {
  word = word.replace(/[0-9abcdef]{8}\-[0-9abcdef]{4}\-[0-9abcdef]{4}\-[0-9abcdef]{4}\-[0-9abcdef]{12}/g, " ");
  word = word.replace(/[0-9abcdef]{32}/g, " ");
  word = word.replace(/([a-z])([A-Z])/g, "$1 $2");
  let wordArr = word.split(/[\s\,\_\-\(\)\[\]\=]+/);
  return wordArr;
}
class XSet extends Set {
  static flatten(set2d) {
    let newSet = new XSet();
    for (let es of set2d) {
      for (let x of es) {
        newSet.add(x);
      }
    }
    return newSet;
  }
  constructor(arr) {
    super(arr);
  }
  get length() {
    return this.size;
  }
  get first() {
    let x;
    for (x of this) {
      break;
    }
    return x;
  }
  map(mapMethod) {
    return [...this].map(mapMethod);
  }
  mapToSet(mapMethod) {
    return new XSet(this.map(mapMethod));
  }
  filter(filterMethod) {
    return new XSet([...this].filter(filterMethod));
  }
  intersects(anotherSet) {
    for (let item of this) {
      if (anotherSet.has(item))
        return true;
    }
    return false;
  }
  intersection(anotherSet) {
    let newSet = new XSet();
    for (let x of this) {
      if (anotherSet.has(x))
        newSet.add(x);
    }
    return newSet;
  }
  isSubsetOf(anotherSet) {
    return [...this].every((item) => anotherSet.has(item));
  }
  isEqualTo(anotherSet) {
    return this.isSubsetOf(anotherSet) && anotherSet.isSubsetOf(this);
  }
  difference(anotherSet) {
    let diffList = [];
    for (let item of this) {
      if (!anotherSet.has(item)) {
        diffList.push(item);
      }
    }
    return new XSet(diffList);
  }
  union(anotherSet) {
    let newSet = new XSet();
    for (let item of this) {
      newSet.add(item);
    }
    for (let item of anotherSet) {
      newSet.add(item);
    }
    return newSet;
  }
  clone() {
    return new XSet([...this]);
  }
  toArray() {
    return [...this];
  }
}
let contextWords = ["title", "aria", "label", "img", "rating", "rate", "stock", "coming", "upvote", "downvote", "vote", "result", "price", "prize", "value"];
let penalWords = ["hidden", "hide", "false", "true", "blank", "inline", "auto", "dir", "medium", "small", "large"];
let stylingWords = ["link", "css", "align", "animation", "delay", "direction", "fill", "mode", "iteration", "name", "@keyframes", "state", "timing", "function", "backface", "visibility", "background", "attachment", "clip", "image", "origin", "position", "repeat", "size", "border", "bottom", "radius", "right", "style", "width", "collapse", "outset", "slice", "source", "spacing", "top", "box", "shadow", "sizing", "caption", "side", "clear", "column", "gap", "rule", "span", "columns", "counter", "increment", "reset", "cursor", "display", "empty", "cell", "flex", "basis", "flow", "wrap", "grow", "shrink", "float", "font", "family", "adjust", "stretch", "variant", "weight", "height", "justify", "letter", "line", "margin", "max", "min", "opacity", "order", "outline", "offset", "overflow", "padding", "page", "break", "after", "before", "inside", "perspective", "quotes", "resize", "tab", "table", "layout", "last", "decoration", "indent", "transform", "transition", "property", "vertical", "white", "space", "word", "index", "foramt", "row", "col", "format", "highlight", "vert", "middle", "large", "down", "small", "overlay", "trigger"];
/*! https://mths.be/cssesc v3.0.0 by @mathias */
var object = {};
var hasOwnProperty = object.hasOwnProperty;
var merge2 = function merge3(options, defaults2) {
  if (!options) {
    return defaults2;
  }
  var result = {};
  for (var key in defaults2) {
    result[key] = hasOwnProperty.call(options, key) ? options[key] : defaults2[key];
  }
  return result;
};
var regexAnySingleEscape = /[ -,\.\/:-@\[-\^`\{-~]/;
var regexSingleEscape = /[ -,\.\/:-@\[\]\^`\{-~]/;
var regexExcessiveSpaces = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g;
var cssesc = function cssesc2(string, options) {
  options = merge2(options, cssesc2.options);
  if (options.quotes != "single" && options.quotes != "double") {
    options.quotes = "single";
  }
  var quote2 = options.quotes == "double" ? '"' : "'";
  var isIdentifier = options.isIdentifier;
  var firstChar = string.charAt(0);
  var output = "";
  var counter = 0;
  var length = string.length;
  while (counter < length) {
    var character = string.charAt(counter++);
    var codePoint = character.charCodeAt();
    var value = void 0;
    if (codePoint < 32 || codePoint > 126) {
      if (codePoint >= 55296 && codePoint <= 56319 && counter < length) {
        var extra = string.charCodeAt(counter++);
        if ((extra & 64512) == 56320) {
          codePoint = ((codePoint & 1023) << 10) + (extra & 1023) + 65536;
        } else {
          counter--;
        }
      }
      value = "\\" + codePoint.toString(16).toUpperCase() + " ";
    } else {
      if (options.escapeEverything) {
        if (regexAnySingleEscape.test(character)) {
          value = "\\" + character;
        } else {
          value = "\\" + codePoint.toString(16).toUpperCase() + " ";
        }
      } else if (/[\t\n\f\r\x0B]/.test(character)) {
        value = "\\" + codePoint.toString(16).toUpperCase() + " ";
      } else if (character == "\\" || !isIdentifier && (character == '"' && quote2 == character || character == "'" && quote2 == character) || isIdentifier && regexSingleEscape.test(character)) {
        value = "\\" + character;
      } else {
        value = character;
      }
    }
    output += value;
  }
  if (isIdentifier) {
    if (/^-[-\d]/.test(output)) {
      output = "\\-" + output.slice(1);
    } else if (/\d/.test(firstChar)) {
      output = "\\3" + firstChar + " " + output.slice(1);
    }
  }
  output = output.replace(regexExcessiveSpaces, function($0, $1, $2) {
    if ($1 && $1.length % 2) {
      return $0;
    }
    return ($1 || "") + $2;
  });
  if (!isIdentifier && options.wrap) {
    return quote2 + output + quote2;
  }
  return output;
};
cssesc.options = {
  "escapeEverything": false,
  "isIdentifier": false,
  "quotes": "single",
  "wrap": false
};
cssesc.version = "3.0.0";
var cssesc_1 = cssesc;
function write$1(...msg) {
  console.log("SELECTORX", ...msg);
}
class Token {
  constructor(type, name, value, depth, offset, currentNode, targetNode) {
    this._context = -1;
    this._isDirectAncestor = -1;
    this._isMulti = -1;
    this._isNonGeneric = -1;
    this._isNotCssAttrib = -1;
    this._isNotRandGen = -1;
    this._notInRejection = -1;
    this._numPaths = -1;
    this._readability = -1;
    this._rightLean = -1;
    this._specificity = -1;
    this._value = value;
    this._type = type;
    this._name = name;
    this._depth = depth;
    this._offset = offset;
    this._currentNode = currentNode;
    this._targetNode = targetNode;
    this.typeNameVal = this.type + Token.separator + this.name + Token.separator + this.value;
  }
  static resetMaps() {
    this.metricMap = /* @__PURE__ */ new Map();
  }
  static generateToken(type, name, value, depth, offset, currentNode, targetNode) {
    let classMap = {
      "pos": TokenPos,
      "immediate": TokenImmediate,
      "tag": TokenTag,
      "attrib": TokenAttrib,
      "attribOnly": TokenAttribOnly,
      "attribStart": TokenAttribStart,
      "attribEnd": TokenAttribEnd,
      "attribContain": TokenAttribContain,
      "text": TokenText,
      "string": TokenString
    };
    return new classMap[type](type, name, value, depth, offset, currentNode, targetNode);
  }
  exacts(another) {
    return this.value === another.value && this.type === another.type && this.name === another.name && this.depth === another.depth && this.offset === another.offset;
  }
  equals(another) {
    return this.value === another.value && this.type === another.type && this.name === another.name;
  }
  get information() {
    return this.value;
  }
  get name() {
    return this._name || "";
  }
  get value() {
    return this._value || "";
  }
  get type() {
    return this._type;
  }
  get depth() {
    return this._depth;
  }
  get offset() {
    return this._offset;
  }
  get context() {
    if (this._context === -1) {
      this._context = getContext(this._targetNode, this._currentNode, this.information);
    }
    return this._context;
  }
  get isDirectAncestor() {
    if (this._isDirectAncestor === -1) {
      this._isDirectAncestor = this._offset === 0 ? 1 : 0;
    }
    return this._isDirectAncestor;
  }
  get isMulti() {
    if (this._isMulti === -1)
      throw new Error("metric not yet computed");
    return this._isMulti;
  }
  get isNonGeneric() {
    throw new Error("method not implemented");
  }
  get isNotCssAttrib() {
    if (this._isNotCssAttrib === -1) {
      this._isNotCssAttrib = isNotCssAttrib(this.information);
    }
    return this._isNotCssAttrib;
  }
  get isNotRandGen() {
    if (this._isNotRandGen === -1) {
      this._isNotRandGen = isNotRandGen(this.value);
    }
    return this._isNotRandGen;
  }
  get notInRejection() {
    if (this._notInRejection === -1)
      throw new Error("metric not yet computed");
    return this._notInRejection;
  }
  get numPaths() {
    if (this._numPaths === -1)
      throw new Error("metric not yet computed");
    return this._numPaths;
  }
  get readability() {
    if (this._readability === -1) {
      this._readability = getReadability(this.information);
    }
    return this._readability;
  }
  get rightLean() {
    if (this._rightLean === -1)
      throw new Error("metric not yet computed");
    return this._rightLean;
  }
  get specificity() {
    throw new Error("method not implemented");
  }
  getScore(weights) {
    return weights.isMulti * this.isMulti + weights.numPaths * this.numPaths + weights.rightLean * this.rightLean + weights.specificity * this.specificity + weights.isNonGeneric * this.isNonGeneric + weights.readability * this.readability + weights.context * this.context + weights.isNotCssAttrib * this.isNotCssAttrib + weights.isDirectAncestor * this.isDirectAncestor + weights.isNotRandGen * this.isNotRandGen + weights.notInRejection * this.notInRejection + weights.bias;
  }
  getQuery(_2) {
    throw new Error("method not implemented");
  }
  static printTokens(tokens, weights) {
    tokens[tokens.length - 1];
    let writeArr = [];
    for (let token of tokens) {
      writeArr.push(`
        ${JSON.stringify(token.value)}-${JSON.stringify(token.name)}-${JSON.stringify(token.type)} 
        score: ${token.getScore(weights)}
        multi: ${token.isMulti}
        numPaths: ${token.numPaths}
        specific: ${token.specificity}
        readability: ${token.readability}
        context: ${token.context}
        rightLean: ${token.rightLean}
        isNotCssAttrib: ${token.isNotCssAttrib}
        isDirectAncestor: ${token.isDirectAncestor}
        isNotRandGen: ${token.isNotRandGen}
        notInRejection: ${token.notInRejection}
        isNotGeneric: ${token.isNonGeneric}
      `);
    }
    write$1(writeArr.join("\n\n"));
  }
}
Token.metricMap = /* @__PURE__ */ new Map();
Token.separator = "<<<---|||--->>>";
let usefulTags1 = ["a", "h1", "h2", "h3", "h4", "h5", "li", "img"];
let usefulTags2 = ["td", "tr", "table", "tbody", "strong", "ul", "header", "footer", "p"];
class TokenTag extends Token {
  getQuery(root) {
    return Array.from(root.querySelectorAll(`${this.name}`));
  }
  get isNonGeneric() {
    if (this._isNonGeneric === -1) {
      this._isNonGeneric = usefulTags1.includes(this.name) || usefulTags2.includes(this.name) ? 1 : 0.2;
    }
    return this._isNonGeneric;
  }
  get specificity() {
    if (usefulTags1.includes(this.name)) {
      return 0.9;
    }
    if (usefulTags2.includes(this.name)) {
      return 0.7;
    }
    return 0.3;
  }
  get readability() {
    if (usefulTags1.includes(this.name)) {
      return 1;
    }
    if (usefulTags2.includes(this.name)) {
      return 0.7;
    }
    return 0.1;
  }
  get context() {
    if (usefulTags1.includes(this.name))
      return 1;
    if (usefulTags2.includes(this.name))
      return 0.8;
    return 0;
  }
  get isNotCssAttrib() {
    return 1;
  }
  get isNotRandGen() {
    return 1;
  }
}
class TokenPos extends Token {
  getQuery(root) {
    return Array.from(root.querySelectorAll(`${this.name}:nth-child(${this.value})`));
  }
  get isNonGeneric() {
    if (usefulTags1.includes(this.name) || usefulTags2.includes(this.name))
      return 1;
    return 0;
  }
  get specificity() {
    let specificity = 0.2;
    if (usefulTags1.includes(this.name))
      specificity = 0.7;
    if (usefulTags2.includes(this.name))
      specificity = 0.7;
    if (this.value === "1")
      ;
    return specificity;
  }
  get readability() {
    return 1;
  }
  get context() {
    return 0;
  }
  get isNotCssAttrib() {
    return 1;
  }
  get isNotRandGen() {
    return 1;
  }
}
class TokenImmediate extends Token {
  getQuery(_2) {
    return [];
  }
  get isNonGeneric() {
    return 0;
  }
  get specificity() {
    return 0.1;
  }
  get readability() {
    return 1;
  }
  get numPaths() {
    return 1;
  }
  get context() {
    return 0;
  }
  get isNotCssAttrib() {
    return 1;
  }
  get isNotRandGen() {
    return 1;
  }
}
class TokenAttrib extends Token {
  getQuery(root) {
    return Array.from(root.querySelectorAll(`[${this.name}='${cssesc_1(this.value, { isIdentifier: true })}']`));
  }
  get isNonGeneric() {
    return 1;
  }
  get specificity() {
    if (this._specificity === -1) {
      let usefulAttribNames = ["aria", "title", "label"];
      if (usefulAttribNames.some((name) => {
        var _a;
        return (_a = this._name) === null || _a === void 0 ? void 0 : _a.includes(name);
      }) || this.name === "id")
        this._specificity = 0.9;
      else
        this._specificity = 0.75;
    }
    return this._specificity;
  }
}
class TokenAttribOnly extends Token {
  get information() {
    return this.name;
  }
  getQuery(root) {
    return Array.from(root.querySelectorAll(`[${this.name}]`));
  }
  get isNonGeneric() {
    return 1;
  }
  get specificity() {
    return 0.65;
  }
  get isNotRandGen() {
    return 1;
  }
}
class TokenAttribStart extends TokenAttrib {
  getQuery(root) {
    return Array.from(root.querySelectorAll(`[${this.name}^='${cssesc_1(this.value, { isIdentifier: true })}']`));
  }
  get specificity() {
    return super.specificity - 0.05;
  }
}
class TokenAttribEnd extends TokenAttrib {
  getQuery(root) {
    return Array.from(root.querySelectorAll(`[${this.name}$='${cssesc_1(this.value, { isIdentifier: true })}']`));
  }
  get specificity() {
    return super.specificity - 0.05;
  }
}
class TokenAttribContain extends TokenAttrib {
  getQuery(root) {
    return Array.from(root.querySelectorAll(`[${this.name}*='${cssesc_1(this.value, { isIdentifier: true })}']`));
  }
  get specificity() {
    return super.specificity - 0.1;
  }
}
class TokenText extends Token {
  getQuery(root) {
    var str = "//*[contains(text(),'" + this.value + "')]";
    let queried = [];
    let iterator = document.evaluate(str, root, null, XPathResult.UNORDERED_NODE_ITERATOR_TYPE);
    try {
      var thisNode = iterator.iterateNext();
      while (thisNode) {
        queried.push(thisNode);
        thisNode = iterator.iterateNext();
      }
    } catch (e) {
      throw new Error("Document tree modified during iteration" + e);
    }
    return queried;
  }
  get isNonGeneric() {
    return 1;
  }
  get specificity() {
    return 0.9;
  }
  get context() {
    return 1;
  }
}
class TokenString extends Token {
  getQuery(root) {
    var str = "//*[contains(string(),'" + this.value + "')]";
    let queried = [];
    let iterator = document.evaluate(str, root, null, XPathResult.UNORDERED_NODE_ITERATOR_TYPE);
    try {
      var thisNode = iterator.iterateNext();
      while (thisNode) {
        queried.push(thisNode);
        thisNode = iterator.iterateNext();
      }
    } catch (e) {
      throw new Error("Document tree modified during iteration" + e);
    }
    return queried;
  }
  get isNonGeneric() {
    return 1;
  }
  get specificity() {
    return 0.85;
  }
  get context() {
    return 1;
  }
}
function getContext(target, currentNode, value) {
  var _a, _b;
  let targetText = (_a = target.textContent) === null || _a === void 0 ? void 0 : _a.replace(/[\s\-\_]+/g, " ").toLowerCase().slice(0, 100);
  let currentText = (_b = currentNode.textContent) === null || _b === void 0 ? void 0 : _b.replace(/[\s\-\_]+/g, " ").toLowerCase().slice(0, 100);
  let wordArr = getWordArr(value);
  let scoreArr = wordArr.map((word) => {
    word = word.toLowerCase();
    if (target.nodeName.toLowerCase() === "a" && word.includes("link"))
      return 1;
    if (targetText === null || targetText === void 0 ? void 0 : targetText.includes(word))
      return 1;
    if (currentText === null || currentText === void 0 ? void 0 : currentText.includes(word))
      return 1;
    if (contextWords.some((cw) => word.startsWith(cw)))
      return 1;
    return 0;
  });
  return scoreArr.reduce(toMax);
}
function getReadability(value) {
  if (value === "")
    return 0.1;
  let wordArr = getWordArr(value);
  let scoreArr = wordArr.map(getSingleWordReadability);
  return scoreArr.reduce(toMean);
}
function getSingleWordReadability(word) {
  let twoCharWords = ["in", "of", "at", "by", "to"];
  if (word.length <= 2 && !twoCharWords.includes(word))
    return 0;
  word = word.toLowerCase();
  let readability = 1;
  let numbers = word.replace(/\D/g, "").length;
  let consLength = word.replace(/[a,e,i,o,u,y]/ig, " ").split(" ").map((x) => x.length).reduce(toMax);
  let nonSpecial = word.replace(/\W/g, "").length;
  if (numbers > 0) {
    readability *= 1 - numbers / word.length;
  }
  if (consLength > 3) {
    readability *= Math.pow(0.9, consLength - 3);
  }
  readability *= nonSpecial / word.length;
  return readability;
}
function isNotCssAttrib(value) {
  if (value === "")
    return 0.1;
  let wordArr = getWordArr(value);
  let scoreArr = wordArr.map((word) => {
    word = word.toLowerCase();
    let badWords = penalWords.concat(stylingWords);
    for (let bw of badWords) {
      if (bw.length > 3 && word === bw)
        return 0;
      else if (bw.length <= 3 && word === bw)
        return 0;
    }
    return 1;
  });
  return scoreArr.reduce(toMin);
}
function isNotRandGen(value) {
  let isUuid = /[0-9abcdef]{8}\-[0-9abcdef]{4}\-[0-9abcdef]{4}\-[0-9abcdef]{4}\-[0-9abcdef]{12}/.test(value);
  if (isUuid)
    return 0;
  let numVals = value.replace(/\D/g, "");
  if (numVals.length >= value.length / 2)
    return 0;
  let contWords = value.replace(/\s/g, "").replace(/[^a-zA-Z\-\_]/g, " ").split(" ").map((word) => word.length).reduce(toMax);
  if (contWords / value.length < 0.3)
    return 0;
  return 1;
}
let excludeTags = ["script", "style", "link", "head", "noscript", "object", "meta"];
let excludeAttribs = ["srcdoc", "style", "onafterprint", "onbeforeprint", "onbeforeunload", "onerror", "onhaschange", "onload", "onmessage", "onoffline", "onpagehide", "onpageshow", "onpopstate", "onredo", "onresize", "onstorage", "onundo", "onunload", "onblur", "onchange", "oncontextmenu", "onfocus", "onformchange", "onforminput", "oninput", "oninvalid", "onreset", "onselect", "onsubmit", "onkeydown", "onkeypress", "onkeyup", "onclick", "ondblclick", "ondrag", "ondragend", "ondragenter", "ondragleave", "ondragover", "ondragstart", "ondrop", "onmousedown", "onmousemove", "onmouseout", "onmouseover", "onmouseup", "onmousewheel", "onscroll", "onabort", "oncanplay", "oncanplaythrough", "ondurationchange", "onemptied", "onended", "onerror", "onloadeddata", "onloadedmetadata", "onloadstart", "onpause", "onplay", "onplaying", "onprogress", "onratechange", "onreadystatechange", "onseeked", "onseeking", "onstalled", "onsuspend", "ontimeupdate", "onvolumechange", "onwaiting"];
class SelectorNode {
  constructor(node2, left, right, desc, options, depth, offset, filterCallback) {
    this.filterCallback = filterCallback;
    this.domNode = node2;
    this.tokens = [];
    this.generateTokens(node2, options, depth, offset);
    this.discarded = /* @__PURE__ */ new Map();
    this.desc = desc;
    this.leftSib = left;
    this.rightSib = right;
  }
  static buildTree(target, node2, options, depth, offset, filterCallback) {
    if (!node2.contains(target)) {
      throw new Error("target is not in subtree");
    }
    let desc = null;
    let left = null;
    let right = null;
    if (target !== node2) {
      let desiredChild = Array.from(node2.childNodes).filter((child) => child.contains(target))[0];
      desc = SelectorNode.buildTree(target, desiredChild, options, depth + 1, offset, filterCallback);
    }
    if (options.siblingNodes && offset > -2) {
      let leftSib = getLeftSibling(node2);
      if (leftSib) {
        let tOpts = Object.assign({}, options);
        tOpts.immediate = leftSib.immediate;
        left = SelectorNode.buildTree(leftSib.node, leftSib.node, tOpts, depth, offset - 1, filterCallback);
      }
    }
    return new SelectorNode(node2, left, right, desc, options, depth, offset, filterCallback);
  }
  addNewToken(type, name, value, depth, offset) {
    if (typeof this.filterCallback === "undefined" || this.filterCallback(type, name, value, depth, offset)) {
      let token = Token.generateToken(type, name, value, depth, offset, this.domNode, this.targetNode);
      if (!this.tokens.some((tok) => tok.equals(token)))
        this.tokens.push(token);
    }
  }
  addPartialTokens(name, value, words, depth, offset, onlyContains = false) {
    if (!onlyContains) {
      if (words.length > 0) {
        let firstWord = words.shift();
        let type = value.indexOf(firstWord) === 0 ? "attribStart" : "attribContain";
        this.addNewToken(type, name, firstWord, depth, offset);
      }
      if (words.length > 0) {
        let lastWord = words.pop();
        let type = value.indexOf(lastWord) === value.length - lastWord.length ? "attribEnd" : "attribContain";
        this.addNewToken(type, name, lastWord, depth, offset);
      }
    }
    for (let word of words) {
      this.addNewToken("attribContain", name, word, depth, offset);
    }
  }
  discardAll() {
    if (this.leftSib) {
      this.leftSib.discardAll();
    }
    if (this.rightSib) {
      this.rightSib.discardAll();
    }
    if (this.desc) {
      this.desc.discardAll();
    }
    while (this.tokens.length > 0) {
      let token = this.tokens.pop();
      this.discarded.set(token, this.tokens.length);
    }
  }
  flushDiscarded() {
    this.discarded.clear();
    if (this.leftSib)
      this.leftSib.flushDiscarded();
    if (this.rightSib)
      this.rightSib.flushDiscarded();
    if (this.desc)
      this.desc.flushDiscarded();
  }
  generateTokens(node2, options, depth, offset) {
    let element2 = node2;
    this.addNewToken("tag", element2.tagName.toLowerCase(), null, depth, offset);
    if (options.immediate)
      this.addNewToken("immediate", null, null, depth, offset);
    for (let { name, value } of Array.from(element2.attributes)) {
      if (name.length > 100 || name.includes(":") || name.indexOf("xmlns") >= 0 || excludeAttribs.includes(name))
        continue;
      if (value.trim().length > 0) {
        if (name === "class") {
          let words = value.split(" ").filter((word) => word.trim().length > 0);
          if (options.partAttrib) {
            words = words.concat(getWordArr(value).filter((w) => w.trim().length > 0));
            words = [...new Set(words)];
          }
          this.addPartialTokens(name, value, words, depth, offset, true);
        } else {
          if (value.length <= 100)
            this.addNewToken("attrib", name, value, depth, offset);
          if (options.partAttrib) {
            let words = getWordArr(value).filter((word) => word.trim().length > 1);
            this.addPartialTokens(name, value, words, depth, offset);
          }
        }
      }
      if (name !== "id" && name !== "class")
        this.addNewToken("attribOnly", name, null, depth, offset);
    }
    if (element2.parentElement) {
      let children = Array.from(element2.parentElement.children);
      this.addNewToken("pos", element2.tagName.toLowerCase(), (children.indexOf(element2) + 1).toString(), depth, offset);
    }
  }
  getLength() {
    return 1 + (this.desc ? this.desc.getLength() : 0);
  }
  getNodeAtLevel(level, offset = 0) {
    if (level == 0) {
      if (offset === 0) {
        return this;
      } else if (offset < 0 && this.leftSib) {
        return this.leftSib.getNodeAtLevel(0, offset + 1);
      } else if (offset > 0 && this.rightSib) {
        return this.rightSib.getNodeAtLevel(0, offset - 1);
      } else {
        throw new Error("offset out of bound");
      }
    } else if (level > 0 && this.desc) {
      return this.desc.getNodeAtLevel(level - 1);
    } else {
      throw new Error("level out of bound");
    }
  }
  getNodeCount() {
    let totalCount = 1;
    if (this.leftSib) {
      totalCount += this.leftSib.getNodeCount();
    }
    if (this.rightSib) {
      totalCount += this.rightSib.getNodeCount();
    }
    if (this.desc) {
      totalCount += this.desc.getNodeCount();
    }
    return totalCount;
  }
  getSubtree(node2) {
    if (node2 === this.domNode)
      return this;
    else if (this.domNode.contains(node2) && this.desc)
      return this.desc.getSubtree(node2);
    else
      throw new Error("subtree not found in selectorTree");
  }
  get targetNode() {
    if (this.desc)
      return this.desc.targetNode;
    else
      return this.domNode;
  }
  getTokenLength() {
    let count2 = 0;
    count2 += this.tokens.length;
    if (this.leftSib)
      count2 += this.leftSib.getTokenLength();
    if (this.rightSib)
      count2 += this.rightSib.getTokenLength();
    if (this.desc)
      count2 += this.desc.getTokenLength();
    return count2;
  }
  getTokenPositions(token) {
    let positions = [];
    if (this.leftSib) {
      positions = positions.concat(this.leftSib.getTokenPositions(token).map((x) => [x[0], x[1] - 1]));
    }
    if (this.rightSib) {
      positions = positions.concat(this.rightSib.getTokenPositions(token).map((x) => [x[0], x[1] + 1]));
    }
    if (this.tokens.includes(token))
      positions.push([0, 0]);
    if (this.desc) {
      positions = positions.concat(this.desc.getTokenPositions(token).map((x) => [x[0] + 1, x[1]]));
    }
    return positions;
  }
  getTokens() {
    let tokens = [];
    if (this.leftSib)
      tokens = tokens.concat(this.leftSib.getTokens());
    if (this.rightSib)
      tokens = tokens.concat(this.rightSib.getTokens());
    tokens = tokens.concat(this.tokens);
    if (this.desc)
      tokens = tokens.concat(this.desc.getTokens());
    return [...new Set(tokens)];
  }
  hasTokens() {
    let usefulTokens = this.tokens.filter((token) => !["immediate", "nthType", "nth", "pos"].includes(token.type));
    return usefulTokens.length > 0;
  }
  isImmediate() {
    for (let token of this.tokens) {
      if (token.type === "immediate") {
        return true;
      }
    }
    return false;
  }
  includes(token, isOnlyStem = false) {
    for (let t of this.tokens) {
      if (t.equals(token))
        return true;
    }
    if (!isOnlyStem) {
      if (this.leftSib && this.leftSib.includes(token, isOnlyStem))
        return true;
      else if (this.rightSib && this.rightSib.includes(token, isOnlyStem))
        return true;
    }
    if (this.desc && this.desc.includes(token, isOnlyStem))
      return true;
    return false;
  }
  removeToken(tokenDepth, tokenOffset, token) {
    if (tokenDepth === 0 && tokenOffset < 0 && this.leftSib) {
      this.leftSib.removeToken(tokenDepth, tokenOffset + 1, token);
    } else if (tokenDepth === 0 && tokenOffset > 0 && this.rightSib) {
      this.rightSib.removeToken(tokenDepth, tokenOffset - 1, token);
    } else if (tokenDepth > 0 && this.desc) {
      this.desc.removeToken(tokenDepth - 1, tokenOffset, token);
    } else if (tokenDepth === 0 && tokenOffset === 0) {
      let idx = this.tokens.indexOf(token);
      if (idx === -1)
        throw new Error("token not in current position");
      this.tokens.splice(idx, 1);
      this.discarded.set(token, idx);
    } else {
      throw new Error("token was not in subtree");
    }
  }
  restoreDiscarded(token, tokenDepth, tokenOffset) {
    if (tokenDepth === 0 && tokenOffset < 0 && this.leftSib) {
      this.leftSib.restoreDiscarded(token, tokenDepth, tokenOffset + 1);
    } else if (tokenDepth === 0 && tokenOffset > 0 && this.rightSib) {
      this.rightSib.restoreDiscarded(token, tokenDepth, tokenOffset - 1);
    } else if (tokenDepth > 0 && this.desc) {
      this.desc.restoreDiscarded(token, tokenDepth - 1, tokenOffset);
    } else if (tokenDepth === 0 && tokenOffset === 0) {
      for (let [discarded, idx] of this.discarded.entries()) {
        if (token === discarded) {
          this.tokens.splice(idx, 0, token);
          this.discarded.delete(token);
        }
      }
    } else {
      throw new Error("token was not in subtree");
    }
  }
}
function getLeftSibling(node2) {
  if (node2.parentNode && node2.parentNode.children.length > 0) {
    let children = Array.from(node2.parentNode.children);
    let node_idx = children.indexOf(node2);
    let i2 = node_idx - 1;
    while (i2 >= 0) {
      if (!excludeTags.includes(children[i2].nodeName.toLowerCase())) {
        return { node: children[i2], immediate: node_idx - i2 === 1 };
      }
      i2--;
    }
  }
  return null;
}
function buildQuery(tree) {
  var _a;
  let path = "";
  let firstLeft = tree.leftSib;
  let secondLeft = firstLeft === null || firstLeft === void 0 ? void 0 : firstLeft.leftSib;
  if (tree.hasTokens()) {
    if (secondLeft === null || secondLeft === void 0 ? void 0 : secondLeft.hasTokens()) {
      path += formatTokens(secondLeft);
      path += secondLeft.isImmediate() && (firstLeft === null || firstLeft === void 0 ? void 0 : firstLeft.hasTokens()) ? "+" : "~";
      path += " ";
    }
    if (firstLeft === null || firstLeft === void 0 ? void 0 : firstLeft.hasTokens()) {
      path += formatTokens(firstLeft);
      path += firstLeft.isImmediate() ? "+" : "~";
      path += " ";
    }
    if (tree.hasTokens()) {
      path += formatTokens(tree);
    } else {
      path += "*";
    }
    path += ((_a = tree.desc) === null || _a === void 0 ? void 0 : _a.hasTokens()) && tree.isImmediate() ? ">" : "";
  }
  if (tree.desc) {
    path += " " + buildQuery(tree.desc);
  }
  if (path.trim() === "")
    return "*";
  return path.trim();
}
function formatTokens(selectorTree) {
  let path = "";
  for (let token of selectorTree.tokens) {
    if (token.type.startsWith("attrib") && (token.name.includes(":") || token.name === "xmlns")) {
      continue;
    }
    if (token.type === "pos") {
      let idx = getNthIndex(selectorTree.domNode);
      if (selectorTree.tokens.some((token2) => token2.type === "nthType") && selectorTree.tokens.some((token2) => token2.type === "tag")) {
        path += "";
      } else if (idx === 1) {
        path += ":first-child";
      } else {
        path += `:nth-child(${idx})`;
      }
    } else if (token.type === "tag") {
      path += cssesc_1(token.name, { isIdentifier: true });
    } else if (token.type === "attrib") {
      if (token.name === "id") {
        path += "#" + cssesc_1(token.value, { isIdentifier: true });
      } else if (token.name === "class" && !token.value.includes(" ")) {
        path += "." + cssesc_1(token.value, { isIdentifier: true });
      } else {
        path += `[${cssesc_1(token.name, { isIdentifier: true })}='${cssesc_1(token.value, { isIdentifier: true })}']`;
      }
    } else if (token.type === "attribOnly") {
      path += `[${cssesc_1(token.name, { isIdentifier: true })}]`;
    } else if (token.type === "attribStart") {
      if (token.name === "class" && selectorTree.domNode.classList.contains(token.value)) {
        path += "." + cssesc_1(token.value, { isIdentifier: true });
      } else {
        path += `[${cssesc_1(token.name, { isIdentifier: true })}^='${cssesc_1(token.value, { isIdentifier: true })}']`;
      }
    } else if (token.type === "attribEnd") {
      if (token.name === "class" && selectorTree.domNode.classList.contains(token.value)) {
        path += "." + cssesc_1(token.value, { isIdentifier: true });
      } else {
        path += `[${cssesc_1(token.name, { isIdentifier: true })}$='${cssesc_1(token.value, { isIdentifier: true })}']`;
      }
    } else if (token.type === "attribContain") {
      if (token.name === "class" && selectorTree.domNode.classList.contains(token.value)) {
        path += "." + cssesc_1(token.value, { isIdentifier: true });
      } else {
        path += `[${cssesc_1(token.name, { isIdentifier: true })}*='${cssesc_1(token.value, { isIdentifier: true })}']`;
      }
    } else if (token.type === "immediate") {
      path += "";
    } else {
      throw new Error("the type " + token.type + " is unhandled");
    }
  }
  return path;
}
function getNthIndex(node2) {
  let parent2 = node2.parentElement;
  if (parent2) {
    return Array.from(parent2.children).indexOf(node2) + 1;
  } else {
    throw new Error("no parent");
  }
}
function write(...msg) {
  console.log("SELECTORX", ...msg);
}
class Core {
  constructor(options) {
    this._selected = new XSet();
    this._rejected = new XSet();
    this._doc = document;
    this._root = document.documentElement;
    this._queryCache = /* @__PURE__ */ new Map();
    this._selectorTrees = new XSet();
    this._options = options;
    this._tokenOpts = { text: false, partAttrib: true, immediate: true, siblingNodes: true };
    this._weights = { isMulti: 8, numPaths: 8, rightLean: 2, specificity: 1, isNonGeneric: 1, readability: 1, context: 1, isNotCssAttrib: 1, isDirectAncestor: 2, isNotRandGen: 8, notInRejection: 0, bias: 0 };
    this._unionSeparator = " , ";
    this.debug = false;
  }
  _buildQuery(_2) {
    throw new Error("Method not Implemented");
  }
  _checkTreeValidity(target, queried) {
    if (queried.length === 0)
      return false;
    if (!queried.has(target))
      return false;
    return true;
  }
  get selected() {
    return [...this._selected];
  }
  get rejected() {
    return [...this._rejected];
  }
  isSelection(node2) {
    return this._selected.has(node2);
  }
  isRejection(node2) {
    return this._rejected.has(node2);
  }
  async _getOrderedTokens(selectorTrees) {
    let rejectorTrees = this._getSelectorTreeArr(this._rejected);
    let selectorTree = selectorTrees.first;
    let tokens = selectorTree.getTokens();
    this._updateTokenMetrics(tokens, selectorTrees, rejectorTrees);
    let orderedTokens = await this._orderTokens(tokens);
    return orderedTokens;
  }
  _updateTokenMetrics(tokens, selectorTrees, rejectorTrees) {
    Token.resetMaps();
    if (!rejectorTrees)
      rejectorTrees = new XSet();
    for (let token of tokens) {
      let totalPaths = selectorTrees.map((tree) => tree.includes(token, true)).reduce((cum, cur) => {
        return cum + (cur ? 1 : 0);
      }, 0);
      token._isMulti = totalPaths > 1 ? 1 : 0;
      token._notInRejection = rejectorTrees.toArray().some((tree) => tree.includes(token)) ? 0 : 1;
      token._numPaths = totalPaths / selectorTrees.length;
      token._rightLean = token._depth / selectorTrees.first.getLength();
    }
  }
  async _orderTokens(tokens) {
    var _a;
    let tokenSorter = (_a = this._options) === null || _a === void 0 ? void 0 : _a.tokenSorter;
    if (typeof tokenSorter !== "undefined") {
      tokens = await tokenSorter(tokens);
    } else {
      tokens.sort((t1, t2) => {
        let score1 = t1.getScore(this._weights);
        let score2 = t2.getScore(this._weights);
        if (score1 != score2)
          return score2 - score1;
        else
          return t2.name.length + t2.value.length - (t1.name.length + t1.value.length);
      });
    }
    return tokens;
  }
  _getSelectorTreeArr(nodes) {
    if (this._root) {
      return nodes.mapToSet((node2) => {
        var _a;
        return SelectorNode.buildTree(node2, this._root, this._tokenOpts, 0, 0, (_a = this._options) === null || _a === void 0 ? void 0 : _a.filterCallback);
      });
    } else
      throw new Error("root node not set");
  }
  async _predict() {
    this._selectorTrees = new XSet();
    let unsatisfied = this._selected.clone();
    while (unsatisfied.length > 0) {
      let selectorTree = await this._simplify(unsatisfied);
      this._selectorTrees.add(selectorTree);
      let preds = this._query(selectorTree);
      unsatisfied = unsatisfied.difference(preds);
    }
    return this._selectorTrees.map((tree) => this._buildQuery(tree)).join(this._unionSeparator);
  }
  _query(selectorTree) {
    let selector2 = this._buildQuery(selectorTree);
    if (!this._queryCache.has(selector2)) {
      this._queryCache.set(selector2, this._querySelectorAll(selector2));
    }
    return this._queryCache.get(selector2);
  }
  _querySelectorAll(_2) {
    throw new Error("method not implemented");
  }
  reset() {
    this._selected = new XSet();
    this._rejected = new XSet();
    this._selectorTrees = new XSet();
    this._root = this._doc.documentElement;
    this._queryCache = /* @__PURE__ */ new Map();
  }
  async _simplify(_2) {
    throw new Error("method not implemented");
  }
  _updateRoot() {
    if (this.selected.length === 0)
      return;
    this._queryCache = /* @__PURE__ */ new Map();
    this._doc = this._selected.first.ownerDocument;
    this._root = this._doc.documentElement;
    for (let node2 of this._selected) {
      if (node2.ownerDocument !== this._doc)
        throw new Error("elements do not belong to the same document");
    }
    for (let node2 of this._rejected) {
      if (node2.ownerDocument !== this._doc)
        throw new Error("elements do not belong to the same document");
    }
  }
}
class Get extends Core {
  constructor(selected, options) {
    super(options);
    this._selected = new XSet(selected);
    this._updateRoot();
  }
  _checkIfBetter(target, queried, lastQueried) {
    if (!this._checkTreeValidity(target, queried))
      return false;
    if (!queried.isSubsetOf(lastQueried))
      return false;
    return true;
  }
  _isDoneSimplifying(queried, unsatisfied) {
    if (queried.length > this._selected.length)
      return false;
    if (!queried.isSubsetOf(this._selected))
      return false;
    let alreadyCovered = this._selected.difference(unsatisfied);
    if (alreadyCovered.intersects(queried))
      return false;
    return true;
  }
  _shakeTree(tree, tokenBuildOrder) {
    let queried = this._query(tree);
    let tokens = tree.getTokens();
    tokenBuildOrder = tokenBuildOrder.reverse();
    tokenBuildOrder = tokenBuildOrder.filter((token) => tokens.includes(token));
    for (let token of tokenBuildOrder) {
      tree.removeToken(token._depth, token._offset, token);
      let newQueried = this._query(tree);
      if (queried.length != newQueried.length || newQueried.difference(queried).size > 0) {
        tree.restoreDiscarded(token, token._depth, token._offset);
      }
    }
  }
  async _simplify(unsatisfied) {
    let selectorTrees = this._getSelectorTreeArr(unsatisfied);
    let tokenBuildOrder = await this._getOrderedTokens(selectorTrees);
    let selectorTree = selectorTrees.first;
    let queried = this._query(selectorTree);
    if (!this._checkTreeValidity(selectorTree.targetNode, queried)) {
      this.reset();
      throw new Error("not a valid tree was built " + this._buildQuery(selectorTree));
    }
    selectorTree.discardAll();
    let lastQueried = this._query(selectorTree);
    this.debug && Token.printTokens(tokenBuildOrder, this._weights);
    for (let token of tokenBuildOrder) {
      selectorTree.restoreDiscarded(token, token.depth, token.offset);
      this.debug && write("added", token.type, token.name, token.value);
      let queried2 = this._query(selectorTree);
      if (!this._checkIfBetter(selectorTree.targetNode, queried2, lastQueried)) {
        selectorTree.removeToken(token.depth, token.offset, token);
        this.debug && write("undone", token.type, token.name, token.value);
      } else {
        lastQueried = queried2;
      }
      this.debug && write("query", this._buildQuery(selectorTree), queried2.length);
      if (this._isDoneSimplifying(queried2, unsatisfied)) {
        break;
      }
    }
    this.debug && write("before shake", this._buildQuery(selectorTree), queried.length);
    this._shakeTree(selectorTree, tokenBuildOrder);
    this.debug && write("after shake", this._buildQuery(selectorTree), queried.length);
    return selectorTree;
  }
}
class GetCss extends Get {
  _buildQuery(selectorTree) {
    return buildQuery(selectorTree);
  }
  constructor(selected, options) {
    super(selected, options);
    this._tokenOpts.text = false;
    this._unionSeparator = " , ";
    this.debug = false;
  }
  _querySelectorAll(selector2) {
    if (!selector2)
      return new XSet();
    if (!this._doc)
      throw new Error("document not set");
    let queried = new XSet(Array.from(this._doc.querySelectorAll(selector2)));
    return queried;
  }
}
async function getCss(selected, options) {
  return await new GetCss(selected, options)._predict();
}
class Similar extends Core {
  constructor() {
    super();
    this._latestAction = Similar.NO_ACTION;
    this._similar = new XSet();
    this._tokenOpts.partAttrib = false;
    this._tokenOpts.text = false;
    this._tokenOpts.siblingNodes = false;
    this._weights = {
      isMulti: 4,
      numPaths: 4,
      rightLean: 0,
      specificity: 0.5,
      isNonGeneric: 0,
      readability: 0,
      context: 0,
      isNotCssAttrib: 1,
      isDirectAncestor: 0,
      isNotRandGen: 0,
      notInRejection: 1,
      bias: 0
    };
    this.debug = false;
  }
  async addSelection(node2) {
    await this._add(node2, this._selected, this._rejected, Similar.ADDED_SELECTION);
  }
  async addRejection(node2) {
    await this._add(node2, this._rejected, this._selected, Similar.ADDED_REJECTION);
  }
  async _add(node2, addList, remList, status) {
    if (addList.length > 0 && this._doc != node2.ownerDocument) {
      throw new Error("element not part of document");
    }
    if (remList.length > 0 && this._doc != node2.ownerDocument) {
      throw new Error("element not part of document");
    }
    if (remList.has(node2)) {
      remList.delete(node2);
    }
    if (!addList.has(node2)) {
      addList.add(node2);
      this._latestAction = status;
      await this.update();
    }
  }
  async removeSelection(node2) {
    await this._remove(node2, this._selected, Similar.REMOVED_SELECTION);
  }
  async removeRejection(node2) {
    await this._remove(node2, this._rejected, Similar.REMOVED_REJECTION);
  }
  async _remove(node2, remList, status) {
    if (remList.length > 0 && this._doc != node2.ownerDocument) {
      throw new Error("element not part of document");
    }
    if (remList.has(node2)) {
      remList.delete(node2);
      this._latestAction = status;
      await this.update();
    }
  }
  async update() {
    this._updateRoot();
    if (this._selected.length === 0)
      throw new Error("empty list of selected");
    await this._predict();
    let preds = XSet.flatten(this._selectorTrees.mapToSet((tree) => this._query(tree)));
    this._similar = preds.difference(this._selected);
  }
  get similar() {
    return [...this._similar];
  }
  isSimilar(node2) {
    return this._similar.has(node2);
  }
  reset() {
    super.reset();
    this._rejected = new XSet();
    this._similar = new XSet();
    this._latestAction = Similar.NO_ACTION;
  }
  async set(targArr) {
    let target = new XSet(targArr);
    this.reset();
    let match = false;
    let pending = target.clone();
    while (pending.length > 0) {
      let node2 = pending.first;
      await this.addSelection(node2);
      let rejectables = this._similar.difference(target);
      while (rejectables.length > 0) {
        await this.addRejection(rejectables.first);
        rejectables = this._similar.difference(target);
      }
      let preds = this.selected.concat(this.similar);
      pending = target.filter((node3) => !preds.includes(node3));
      if (pending.length === 0 && rejectables.length === 0) {
        match = true;
        break;
      }
    }
    if (!match)
      throw new Error("could not create a set of selection and rejection for the given list of elements");
  }
  _buildQuery(selectorTree) {
    return buildQuery(selectorTree);
  }
  _isDesiredSimplification(target, queried, unsatisfied, lastQueried) {
    let alreadyCovered = this._selected.difference(unsatisfied);
    return this._checkTreeValidity(target, queried) && !queried.intersects(alreadyCovered) && !queried.intersects(this._rejected) && (this._unAffectingDiscard(queried, lastQueried) || this._isCoveringExtra(queried, lastQueried, unsatisfied));
  }
  _querySelectorAll(selector2) {
    if (!selector2)
      return new XSet();
    let queried = Array.from(this._root.querySelectorAll(selector2));
    return new XSet(queried);
  }
  get _additionalUnsatisfied() {
    let lastSimilar = this._latestAction === Similar.ADDED_SELECTION ? this._similar : new XSet();
    let queriedSoFar = XSet.flatten(this._selectorTrees.mapToSet((tree) => this._query(tree)));
    let uncoveredLastSimilar = lastSimilar.difference(queriedSoFar);
    return uncoveredLastSimilar;
  }
  async _simplify(unsatisfied) {
    unsatisfied = unsatisfied.union(this._additionalUnsatisfied);
    let selectorTrees = this._getSelectorTreeArr(unsatisfied);
    let tokenOrder = await this._getOrderedTokens(selectorTrees);
    let discardOrder = tokenOrder.reverse();
    let selectorTree = selectorTrees.first;
    let lastQueried = this._query(selectorTree);
    if (!this._checkTreeValidity(selectorTree.targetNode, this._query(selectorTree))) {
      this.reset();
      throw new Error("not a valid tree was built " + this._buildQuery(selectorTree));
    }
    for (let discardable of discardOrder) {
      selectorTree.removeToken(discardable._depth, discardable._offset, discardable);
      let queried = this._query(selectorTree);
      if (this._isDesiredSimplification(selectorTree.targetNode, queried, unsatisfied, lastQueried)) {
        lastQueried = queried;
        selectorTree.flushDiscarded();
      } else {
        selectorTree.restoreDiscarded(discardable, discardable._depth, discardable._offset);
      }
      if (this._isDoneSimplifying(queried, unsatisfied))
        break;
    }
    return selectorTree;
  }
  _isDoneSimplifying(queried, unsatisfied) {
    return unsatisfied.isSubsetOf(queried);
  }
  _unAffectingDiscard(queried, lastQueried) {
    return lastQueried.isEqualTo(queried);
  }
  _isCoveringExtra(queried, lastQueried, unsatisfied) {
    let covered = queried.intersection(unsatisfied);
    let extra = covered.difference(lastQueried);
    return extra.size > 0;
  }
  _updateRoot() {
    super._updateRoot();
    let updated = true;
    while (updated) {
      updated = false;
      for (let child of Array.from(this._root.childNodes)) {
        if (this.selected.every((node2) => child.contains(node2)) && this.selected.every((node2) => node2 != child)) {
          this._root = child;
          updated = true;
        }
      }
    }
  }
}
Similar.ADDED_SELECTION = 1;
Similar.REMOVED_SELECTION = 2;
Similar.ADDED_REJECTION = 3;
Similar.REMOVED_REJECTION = 4;
Similar.NO_ACTION = 0;
async function getProxies() {
  let proxies = (await Api.api("/proxies/global")).data;
  let customProxies = (await Api.api("/proxies")).data;
  customProxies = customProxies.map((p) => ({ ...p, available: true }));
  return [...proxies, ...customProxies];
}
function create_icon_slot$1(ctx) {
  let img;
  let img_src_value;
  return {
    c() {
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = "/assets/icons/ic_ip.svg"))
        attr(img, "src", img_src_value);
      attr(img, "height", "20px");
    },
    m(target, anchor) {
      insert(target, img, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(img);
    }
  };
}
function create_fragment$n(ctx) {
  let menu;
  let updating_id;
  let current;
  const menu_spread_levels = [{ items: ctx[1] }, ctx[2]];
  function menu_id_binding(value) {
    ctx[4](value);
  }
  let menu_props = {
    $$slots: { icon: [create_icon_slot$1] },
    $$scope: { ctx }
  };
  for (let i2 = 0; i2 < menu_spread_levels.length; i2 += 1) {
    menu_props = assign$1(menu_props, menu_spread_levels[i2]);
  }
  if (ctx[0] !== void 0) {
    menu_props.id = ctx[0];
  }
  menu = new Menu$1({ props: menu_props });
  binding_callbacks.push(() => bind$2(menu, "id", menu_id_binding));
  return {
    c() {
      create_component(menu.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menu, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const menu_changes = dirty & 6 ? get_spread_update(menu_spread_levels, [
        dirty & 2 && { items: ctx2[1] },
        dirty & 4 && get_spread_object(ctx2[2])
      ]) : {};
      if (dirty & 64) {
        menu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_id && dirty & 1) {
        updating_id = true;
        menu_changes.id = ctx2[0];
        add_flush_callback(() => updating_id = false);
      }
      menu.$set(menu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menu, detaching);
    }
  };
}
function instance$m($$self, $$props, $$invalidate) {
  const omit_props_names = ["id", "proxy"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { id: id2 } = $$props;
  let { proxy } = $$props;
  createEventDispatcher();
  let items = [];
  onMount(async () => {
    $$invalidate(1, items = await getProxies());
  });
  function menu_id_binding(value) {
    id2 = value;
    $$invalidate(0, id2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("id" in $$new_props)
      $$invalidate(0, id2 = $$new_props.id);
    if ("proxy" in $$new_props)
      $$invalidate(3, proxy = $$new_props.proxy);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 3) {
      $$invalidate(3, proxy = items.find((item) => item.id == id2));
    }
  };
  return [id2, items, $$restProps, proxy, menu_id_binding];
}
class SelectProxy extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$m, create_fragment$n, safe_not_equal, { id: 0, proxy: 3 });
  }
}
function create_icon_slot(ctx) {
  let t;
  return {
    c() {
      t = text("\u{1F464}");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_1$4(ctx) {
  let t;
  return {
    c() {
      t = text("Manage Profiles");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$7(ctx) {
  let t;
  return {
    c() {
      t = text("Learn More");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_bottom_slot(ctx) {
  let li;
  let t0;
  let menuitemlink0;
  let t1;
  let menuitemlink1;
  let current;
  menuitemlink0 = new MenuItemLink({
    props: {
      href: "#/w/" + team + "/profiles/",
      target: "_blank",
      $$slots: { default: [create_default_slot_1$4] },
      $$scope: { ctx }
    }
  });
  menuitemlink1 = new MenuItemLink({
    props: {
      href: URL_WEBSITE + "/kb/help/profiles-for-cloud-monitors",
      target: "_blank",
      $$slots: { default: [create_default_slot$7] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      li = element("li");
      t0 = space();
      create_component(menuitemlink0.$$.fragment);
      t1 = space();
      create_component(menuitemlink1.$$.fragment);
      attr(li, "class", "divider");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      insert(target, t0, anchor);
      mount_component(menuitemlink0, target, anchor);
      insert(target, t1, anchor);
      mount_component(menuitemlink1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitemlink0_changes = {};
      if (dirty & 256) {
        menuitemlink0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemlink0.$set(menuitemlink0_changes);
      const menuitemlink1_changes = {};
      if (dirty & 256) {
        menuitemlink1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemlink1.$set(menuitemlink1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitemlink0.$$.fragment, local);
      transition_in(menuitemlink1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitemlink0.$$.fragment, local);
      transition_out(menuitemlink1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      if (detaching)
        detach(t0);
      destroy_component(menuitemlink0, detaching);
      if (detaching)
        detach(t1);
      destroy_component(menuitemlink1, detaching);
    }
  };
}
function create_fragment$m(ctx) {
  let searchablemenu;
  let updating_id;
  let current;
  const searchablemenu_spread_levels = [{ items: ctx[1] }, ctx[3]];
  function searchablemenu_id_binding(value) {
    ctx[5](value);
  }
  let searchablemenu_props = {
    $$slots: {
      bottom: [create_bottom_slot],
      icon: [create_icon_slot]
    },
    $$scope: { ctx }
  };
  for (let i2 = 0; i2 < searchablemenu_spread_levels.length; i2 += 1) {
    searchablemenu_props = assign$1(searchablemenu_props, searchablemenu_spread_levels[i2]);
  }
  if (ctx[0] !== void 0) {
    searchablemenu_props.id = ctx[0];
  }
  searchablemenu = new SearchableMenu({ props: searchablemenu_props });
  binding_callbacks.push(() => bind$2(searchablemenu, "id", searchablemenu_id_binding));
  searchablemenu.$on("search", ctx[2]);
  return {
    c() {
      create_component(searchablemenu.$$.fragment);
    },
    m(target, anchor) {
      mount_component(searchablemenu, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const searchablemenu_changes = dirty & 10 ? get_spread_update(searchablemenu_spread_levels, [
        dirty & 2 && { items: ctx2[1] },
        dirty & 8 && get_spread_object(ctx2[3])
      ]) : {};
      if (dirty & 256) {
        searchablemenu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_id && dirty & 1) {
        updating_id = true;
        searchablemenu_changes.id = ctx2[0];
        add_flush_callback(() => updating_id = false);
      }
      searchablemenu.$set(searchablemenu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(searchablemenu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(searchablemenu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(searchablemenu, detaching);
    }
  };
}
let team = "0";
function instance$l($$self, $$props, $$invalidate) {
  const omit_props_names = ["id", "session"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { id: id2 } = $$props;
  let { session } = $$props;
  createEventDispatcher();
  let items = [];
  getSessions();
  function onSearch2(e) {
    let phrase = e.detail;
    getSessions({ "name.ilike": `%${phrase}%` });
  }
  async function getSessions(query = {}) {
    let res2 = await Api.api("/sessions", query);
    $$invalidate(1, items = res2.data);
    if (id2 && !items.find((item) => item.id == id2)) {
      let item = await Api.api(`/sessions/${id2}`);
      $$invalidate(1, items = [item, ...items]);
    }
  }
  function searchablemenu_id_binding(value) {
    id2 = value;
    $$invalidate(0, id2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("id" in $$new_props)
      $$invalidate(0, id2 = $$new_props.id);
    if ("session" in $$new_props)
      $$invalidate(4, session = $$new_props.session);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 3) {
      $$invalidate(4, session = items.find((item) => item.id == id2));
    }
  };
  return [id2, items, onSearch2, $$restProps, session, searchablemenu_id_binding];
}
class SelectSession extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$l, create_fragment$m, safe_not_equal, { id: 0, session: 4 });
  }
}
var recorder = "";
function debounce(callback, wait2) {
  let timeout = null;
  return (...args) => {
    const next = () => callback(...args);
    clearTimeout(timeout);
    timeout = setTimeout(next, wait2);
  };
}
function wait(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
function create_if_block_1$9(ctx) {
  let div;
  let t;
  return {
    c() {
      div = element("div");
      t = text(ctx[1]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & 2)
        set_data(t, ctx2[1]);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block$f(ctx) {
  let progress;
  let current;
  progress = new Progress({});
  return {
    c() {
      create_component(progress.$$.fragment);
    },
    m(target, anchor) {
      mount_component(progress, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(progress.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(progress.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(progress, detaching);
    }
  };
}
function create_fragment$l(ctx) {
  let div1;
  let t0;
  let t1;
  let div0;
  let current;
  let if_block0 = ctx[1] && create_if_block_1$9(ctx);
  let if_block1 = ctx[0] && create_if_block$f();
  return {
    c() {
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      div0 = element("div");
      attr(div0, "class", "bbx-browser-body bbx-border");
      attr(div1, "class", "bbx-browser");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      if (if_block0)
        if_block0.m(div1, null);
      append(div1, t0);
      if (if_block1)
        if_block1.m(div1, null);
      append(div1, t1);
      append(div1, div0);
      ctx[4](div0);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (ctx2[1]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_1$9(ctx2);
          if_block0.c();
          if_block0.m(div1, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx2[0]) {
        if (if_block1) {
          if (dirty & 1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$f();
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      ctx[4](null);
    }
  };
}
function instance$k($$self, $$props, $$invalidate) {
  let { bbx } = $$props;
  let loading2 = true;
  let loadError2;
  let view;
  const dispatch = createEventDispatcher();
  let container;
  onMount(async () => {
    try {
      view = await createView({ ...bbx, container });
      dispatch("ready", view);
    } catch (e) {
      $$invalidate(1, loadError2 = e);
      dispatch("error", e);
    }
    $$invalidate(0, loading2 = false);
  });
  onDestroy(() => {
  });
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      container = $$value;
      $$invalidate(2, container);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("bbx" in $$props2)
      $$invalidate(3, bbx = $$props2.bbx);
  };
  return [loading2, loadError2, container, bbx, div0_binding];
}
class Browser$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$k, create_fragment$l, safe_not_equal, { bbx: 3 });
  }
}
function create_fragment$k(ctx) {
  let div2;
  return {
    c() {
      div2 = element("div");
      div2.innerHTML = `<div class="bbx-header bbx-pad bbx-border">Inspector</div> 
  <div class="bbx-pad">Placeholder for DOM Inspector</div>`;
      attr(div2, "class", "bbx-inspector");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div2);
    }
  };
}
class Inspector extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$k, safe_not_equal, {});
  }
}
const get_tb_r_r_slot_changes = (dirty) => ({});
const get_tb_r_r_slot_context = (ctx) => ({});
const get_tb_r_l_slot_changes = (dirty) => ({});
const get_tb_r_l_slot_context = (ctx) => ({});
const get_tb_url_r_slot_changes = (dirty) => ({});
const get_tb_url_r_slot_context = (ctx) => ({});
const get_tb_url_l_slot_changes = (dirty) => ({});
const get_tb_url_l_slot_context = (ctx) => ({});
const get_tb_l_slot_changes = (dirty) => ({});
const get_tb_l_slot_context = (ctx) => ({});
function create_default_slot_2$1(ctx) {
  let t;
  return {
    c() {
      t = text("Inspect Element");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_items_slot_1(ctx) {
  let menuitem;
  let current;
  menuitem = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot_2$1] },
      $$scope: { ctx }
    }
  });
  menuitem.$on("click", ctx[21]);
  return {
    c() {
      create_component(menuitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitem_changes = {};
      if (dirty[1] & 1) {
        menuitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem.$set(menuitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem, detaching);
    }
  };
}
function create_else_block$d(ctx) {
  let button;
  let t;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t = text("Start Recording");
      attr(button, "class", "bbx-btn");
      button.disabled = ctx[5];
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t);
      if (!mounted) {
        dispose = listen(button, "click", ctx[12]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 32) {
        button.disabled = ctx2[5];
      }
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$8(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = "Stop Recording";
      attr(button, "class", "bbx-btn");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", ctx[13]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_1$3(ctx) {
  let t;
  return {
    c() {
      t = text("Reset Steps");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_items_slot(ctx) {
  let menuitem;
  let current;
  menuitem = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot_1$3] },
      $$scope: { ctx }
    }
  });
  menuitem.$on("click", ctx[16]);
  return {
    c() {
      create_component(menuitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitem_changes = {};
      if (dirty[1] & 1) {
        menuitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem.$set(menuitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem, detaching);
    }
  };
}
function create_default_slot$6(ctx) {
  let div0;
  let t1;
  let div2;
  let t2;
  let div1;
  let t3;
  let button0;
  let t4;
  let t5;
  let button1;
  let t6;
  let button1_disabled_value;
  let t7;
  let menubtn;
  let t8;
  let div3;
  let current;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (ctx2[3])
      return create_if_block_1$8;
    return create_else_block$d;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  menubtn = new MenuBtn({
    props: {
      class: "bbx-pad-x",
      $$slots: { items: [create_items_slot] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div0 = element("div");
      div0.textContent = "Recorder";
      t1 = space();
      div2 = element("div");
      if_block.c();
      t2 = space();
      div1 = element("div");
      t3 = space();
      button0 = element("button");
      t4 = text("Replay");
      t5 = space();
      button1 = element("button");
      t6 = text("Stop");
      t7 = space();
      create_component(menubtn.$$.fragment);
      t8 = space();
      div3 = element("div");
      div3.innerHTML = `<span class="bbx-flex-1">Steps</span>`;
      attr(div0, "class", "bbx-header bbx-pad");
      set_style(div1, "flex", "1");
      attr(button0, "class", "bbx-btn");
      button0.disabled = ctx[5];
      attr(button1, "class", "bbx-btn");
      button1.disabled = button1_disabled_value = !ctx[5];
      attr(div2, "class", "bbx-tb bbx-pad bbx-gap bbx-border-b");
      attr(div3, "class", "bbx-subheader bbx-flex");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      insert(target, t1, anchor);
      insert(target, div2, anchor);
      if_block.m(div2, null);
      append(div2, t2);
      append(div2, div1);
      append(div2, t3);
      append(div2, button0);
      append(button0, t4);
      append(div2, t5);
      append(div2, button1);
      append(button1, t6);
      append(div2, t7);
      mount_component(menubtn, div2, null);
      insert(target, t8, anchor);
      insert(target, div3, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[15]),
          listen(button1, "click", ctx[14])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div2, t2);
        }
      }
      if (!current || dirty[0] & 32) {
        button0.disabled = ctx2[5];
      }
      if (!current || dirty[0] & 32 && button1_disabled_value !== (button1_disabled_value = !ctx2[5])) {
        button1.disabled = button1_disabled_value;
      }
      const menubtn_changes = {};
      if (dirty[1] & 1) {
        menubtn_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menubtn.$set(menubtn_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menubtn.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menubtn.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div2);
      if_block.d();
      destroy_component(menubtn);
      if (detaching)
        detach(t8);
      if (detaching)
        detach(div3);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$e(ctx) {
  let inspector_1;
  let current;
  inspector_1 = new Inspector({});
  return {
    c() {
      create_component(inspector_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inspector_1, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(inspector_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inspector_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inspector_1, detaching);
    }
  };
}
function create_fragment$j(ctx) {
  let div5;
  let div3;
  let div1;
  let button0;
  let t1;
  let button1;
  let t3;
  let t4;
  let div2;
  let svg;
  let image;
  let image_href_value;
  let t5;
  let t6;
  let input;
  let t7;
  let t8;
  let a;
  let t10;
  let t11;
  let menubtn;
  let t12;
  let t13;
  let button2;
  let t15;
  let button3;
  let t17;
  let div4;
  let browser_1;
  let t18;
  let sidebar;
  let t19;
  let div5_class_value;
  let current;
  let mounted;
  let dispose;
  const tb_l_slot_template = ctx[27]["tb-l"];
  const tb_l_slot = create_slot(tb_l_slot_template, ctx, ctx[31], get_tb_l_slot_context);
  const tb_url_l_slot_template = ctx[27]["tb-url-l"];
  const tb_url_l_slot = create_slot(tb_url_l_slot_template, ctx, ctx[31], get_tb_url_l_slot_context);
  const tb_url_r_slot_template = ctx[27]["tb-url-r"];
  const tb_url_r_slot = create_slot(tb_url_r_slot_template, ctx, ctx[31], get_tb_url_r_slot_context);
  const tb_r_l_slot_template = ctx[27]["tb-r-l"];
  const tb_r_l_slot = create_slot(tb_r_l_slot_template, ctx, ctx[31], get_tb_r_l_slot_context);
  menubtn = new MenuBtn({
    props: {
      $$slots: { items: [create_items_slot_1] },
      $$scope: { ctx }
    }
  });
  const tb_r_r_slot_template = ctx[27]["tb-r-r"];
  const tb_r_r_slot = create_slot(tb_r_r_slot_template, ctx, ctx[31], get_tb_r_r_slot_context);
  browser_1 = new Browser$1({ props: { bbx: ctx[2] } });
  browser_1.$on("ready", ctx[11]);
  browser_1.$on("error", onBrowserError);
  sidebar = new Sidebar({
    props: {
      playing: ctx[5],
      playingStatus: ctx[6],
      steps: ctx[4],
      addStep: ctx[9],
      replaceStep: ctx[10],
      stopRecording: ctx[13],
      $$slots: { default: [create_default_slot$6] },
      $$scope: { ctx }
    }
  });
  sidebar.$on("delete", ctx[17]);
  let if_block = ctx[7] && create_if_block$e();
  let div5_levels = [
    {
      class: div5_class_value = "bbx-recorder " + ctx[1]
    },
    ctx[22]
  ];
  let div5_data = {};
  for (let i2 = 0; i2 < div5_levels.length; i2 += 1) {
    div5_data = assign$1(div5_data, div5_levels[i2]);
  }
  return {
    c() {
      div5 = element("div");
      div3 = element("div");
      div1 = element("div");
      button0 = element("button");
      button0.innerHTML = `<div style="transform: translateY(-2px)">\u279C</div>`;
      t1 = space();
      button1 = element("button");
      button1.textContent = "\u279C";
      t3 = space();
      if (tb_l_slot)
        tb_l_slot.c();
      t4 = space();
      div2 = element("div");
      svg = svg_element("svg");
      image = svg_element("image");
      t5 = space();
      if (tb_url_l_slot)
        tb_url_l_slot.c();
      t6 = space();
      input = element("input");
      t7 = space();
      if (tb_url_r_slot)
        tb_url_r_slot.c();
      t8 = space();
      a = element("a");
      a.textContent = "Reload";
      t10 = space();
      if (tb_r_l_slot)
        tb_r_l_slot.c();
      t11 = space();
      create_component(menubtn.$$.fragment);
      t12 = space();
      if (tb_r_r_slot)
        tb_r_r_slot.c();
      t13 = space();
      button2 = element("button");
      button2.textContent = "Save";
      t15 = space();
      button3 = element("button");
      button3.textContent = "Cancel";
      t17 = space();
      div4 = element("div");
      create_component(browser_1.$$.fragment);
      t18 = space();
      create_component(sidebar.$$.fragment);
      t19 = space();
      if (if_block)
        if_block.c();
      attr(button0, "title", "Go Back");
      set_style(button0, "transform", "rotate(180deg)");
      attr(button1, "title", "Go Forward");
      attr(image, "href", image_href_value = "https://monitor.distill.io/v1/getfavicon?url=" + ctx[0]);
      attr(image, "width", "20");
      attr(image, "height", "20");
      attr(svg, "class", "bbx-favicon");
      input.disabled = true;
      attr(input, "class", "bbx-urlbar bbx-pad");
      attr(a, "href", "#");
      attr(a, "class", "bbx-action bbx-pad-x");
      attr(div2, "class", "bbx-urlbar");
      attr(div3, "class", "bbx-tb bbx-pad bbx-gap");
      attr(div4, "class", "bbx-recorder-body");
      set_attributes(div5, div5_data);
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div3);
      append(div3, div1);
      append(div1, button0);
      append(div1, t1);
      append(div1, button1);
      append(div3, t3);
      if (tb_l_slot) {
        tb_l_slot.m(div3, null);
      }
      append(div3, t4);
      append(div3, div2);
      append(div2, svg);
      append(svg, image);
      append(div2, t5);
      if (tb_url_l_slot) {
        tb_url_l_slot.m(div2, null);
      }
      append(div2, t6);
      append(div2, input);
      set_input_value(input, ctx[0]);
      append(div2, t7);
      if (tb_url_r_slot) {
        tb_url_r_slot.m(div2, null);
      }
      append(div2, t8);
      append(div2, a);
      append(div3, t10);
      if (tb_r_l_slot) {
        tb_r_l_slot.m(div3, null);
      }
      append(div3, t11);
      mount_component(menubtn, div3, null);
      append(div3, t12);
      if (tb_r_r_slot) {
        tb_r_r_slot.m(div3, null);
      }
      append(div3, t13);
      append(div3, button2);
      append(div3, t15);
      append(div3, button3);
      append(div5, t17);
      append(div5, div4);
      mount_component(browser_1, div4, null);
      append(div4, t18);
      mount_component(sidebar, div4, null);
      append(div5, t19);
      if (if_block)
        if_block.m(div5, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[18]),
          listen(button1, "click", ctx[19]),
          listen(input, "input", ctx[28]),
          listen(a, "click", prevent_default(ctx[20])),
          listen(button2, "click", ctx[29]),
          listen(button3, "click", ctx[30])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (tb_l_slot) {
        if (tb_l_slot.p && (!current || dirty[1] & 1)) {
          update_slot_base(tb_l_slot, tb_l_slot_template, ctx2, ctx2[31], !current ? get_all_dirty_from_scope(ctx2[31]) : get_slot_changes(tb_l_slot_template, ctx2[31], dirty, get_tb_l_slot_changes), get_tb_l_slot_context);
        }
      }
      if (!current || dirty[0] & 1 && image_href_value !== (image_href_value = "https://monitor.distill.io/v1/getfavicon?url=" + ctx2[0])) {
        attr(image, "href", image_href_value);
      }
      if (tb_url_l_slot) {
        if (tb_url_l_slot.p && (!current || dirty[1] & 1)) {
          update_slot_base(tb_url_l_slot, tb_url_l_slot_template, ctx2, ctx2[31], !current ? get_all_dirty_from_scope(ctx2[31]) : get_slot_changes(tb_url_l_slot_template, ctx2[31], dirty, get_tb_url_l_slot_changes), get_tb_url_l_slot_context);
        }
      }
      if (dirty[0] & 1 && input.value !== ctx2[0]) {
        set_input_value(input, ctx2[0]);
      }
      if (tb_url_r_slot) {
        if (tb_url_r_slot.p && (!current || dirty[1] & 1)) {
          update_slot_base(tb_url_r_slot, tb_url_r_slot_template, ctx2, ctx2[31], !current ? get_all_dirty_from_scope(ctx2[31]) : get_slot_changes(tb_url_r_slot_template, ctx2[31], dirty, get_tb_url_r_slot_changes), get_tb_url_r_slot_context);
        }
      }
      if (tb_r_l_slot) {
        if (tb_r_l_slot.p && (!current || dirty[1] & 1)) {
          update_slot_base(tb_r_l_slot, tb_r_l_slot_template, ctx2, ctx2[31], !current ? get_all_dirty_from_scope(ctx2[31]) : get_slot_changes(tb_r_l_slot_template, ctx2[31], dirty, get_tb_r_l_slot_changes), get_tb_r_l_slot_context);
        }
      }
      const menubtn_changes = {};
      if (dirty[1] & 1) {
        menubtn_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menubtn.$set(menubtn_changes);
      if (tb_r_r_slot) {
        if (tb_r_r_slot.p && (!current || dirty[1] & 1)) {
          update_slot_base(tb_r_r_slot, tb_r_r_slot_template, ctx2, ctx2[31], !current ? get_all_dirty_from_scope(ctx2[31]) : get_slot_changes(tb_r_r_slot_template, ctx2[31], dirty, get_tb_r_r_slot_changes), get_tb_r_r_slot_context);
        }
      }
      const browser_1_changes = {};
      if (dirty[0] & 4)
        browser_1_changes.bbx = ctx2[2];
      browser_1.$set(browser_1_changes);
      const sidebar_changes = {};
      if (dirty[0] & 32)
        sidebar_changes.playing = ctx2[5];
      if (dirty[0] & 64)
        sidebar_changes.playingStatus = ctx2[6];
      if (dirty[0] & 16)
        sidebar_changes.steps = ctx2[4];
      if (dirty[0] & 40 | dirty[1] & 1) {
        sidebar_changes.$$scope = { dirty, ctx: ctx2 };
      }
      sidebar.$set(sidebar_changes);
      if (ctx2[7]) {
        if (if_block) {
          if (dirty[0] & 128) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$e();
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div5, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      set_attributes(div5, div5_data = get_spread_update(div5_levels, [
        (!current || dirty[0] & 2 && div5_class_value !== (div5_class_value = "bbx-recorder " + ctx2[1])) && { class: div5_class_value },
        dirty[0] & 4194304 && ctx2[22]
      ]));
    },
    i(local) {
      if (current)
        return;
      transition_in(tb_l_slot, local);
      transition_in(tb_url_l_slot, local);
      transition_in(tb_url_r_slot, local);
      transition_in(tb_r_l_slot, local);
      transition_in(menubtn.$$.fragment, local);
      transition_in(tb_r_r_slot, local);
      transition_in(browser_1.$$.fragment, local);
      transition_in(sidebar.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(tb_l_slot, local);
      transition_out(tb_url_l_slot, local);
      transition_out(tb_url_r_slot, local);
      transition_out(tb_r_l_slot, local);
      transition_out(menubtn.$$.fragment, local);
      transition_out(tb_r_r_slot, local);
      transition_out(browser_1.$$.fragment, local);
      transition_out(sidebar.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div5);
      if (tb_l_slot)
        tb_l_slot.d(detaching);
      if (tb_url_l_slot)
        tb_url_l_slot.d(detaching);
      if (tb_url_r_slot)
        tb_url_r_slot.d(detaching);
      if (tb_r_l_slot)
        tb_r_l_slot.d(detaching);
      destroy_component(menubtn);
      if (tb_r_r_slot)
        tb_r_r_slot.d(detaching);
      destroy_component(browser_1);
      destroy_component(sidebar);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function onBrowserError(e) {
  console.error("onBrowserError", e.detail);
}
function instance$j($$self, $$props, $$invalidate) {
  const omit_props_names = ["class", "proxy", "session", "bbx", "findSelector", "url", "initialSteps"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  let { class: clazz = "" } = $$props;
  let { proxy = null } = $$props;
  let { session = null } = $$props;
  let { bbx } = $$props;
  let { findSelector } = $$props;
  let { url } = $$props;
  let { initialSteps = [] } = $$props;
  let browser;
  let browserView;
  let recorder2;
  let recording = false;
  let steps = [];
  let playing = false;
  let playingStatus = {};
  let inspector = false;
  const dispatch = createEventDispatcher();
  function addStep(step, i2) {
    recorder2.insertStep(step, i2);
  }
  function replaceStep(step, i2) {
    recorder2.replaceStep(step, i2);
  }
  async function onBrowserReady(e) {
    browserView = e.detail;
    browser = browserView.store;
    recorder2 = new Base(browserView, findSelector, initialSteps);
    if (initialSteps.length === 0) {
      await wait(1e3);
      recorder2.start();
      $$invalidate(3, recording = true);
    }
    recorder2.on("change", onRecordingChanged);
    goto();
    onRecordingChanged();
  }
  onDestroy(() => {
    recorder2.off("change", onRecordingChanged);
  });
  let onRecordingChanged = debounce(() => {
    $$invalidate(4, steps = recorder2.getSteps());
  }, 100);
  async function goto(_url = url) {
    await browser.pages[0].goto(_url);
  }
  async function record() {
    recorder2.start();
    $$invalidate(5, playing = false);
    $$invalidate(3, recording = true);
  }
  async function stopRecording() {
    recorder2.stop();
    $$invalidate(5, playing = false);
    $$invalidate(3, recording = false);
  }
  async function stopReplay() {
    $$invalidate(5, playing = false);
  }
  async function replay2() {
    $$invalidate(5, playing = true);
    $$invalidate(3, recording = false);
    recorder2.stop();
    await resetBBX();
    goto(url);
    try {
      $$invalidate(6, playingStatus = {});
      for (let step of steps) {
        if (!playing) {
          break;
        }
        $$invalidate(6, playingStatus = { step, status: "ACTIVE" });
        if (!step.isEffect()) {
          await wait(1e3);
        }
        await step.play(browserView);
        $$invalidate(6, playingStatus = { step, status: "DONE" });
      }
      $$invalidate(5, playing = false);
    } catch (e) {
      console.error(`ERR: play step: `, e);
      $$invalidate(6, playingStatus = {
        ...playingStatus,
        status: "ERR",
        msg: e.message || e.msg
      });
    }
    $$invalidate(3, recording = false);
  }
  async function onReset() {
    recorder2.stop();
    recorder2.reset();
    recorder2.start();
    await resetBBX();
    await goto();
    $$invalidate(5, playing = false);
    $$invalidate(3, recording = true);
  }
  async function resetBBX() {
    let pages = browser.pages.slice(0);
    await browser.newPage();
    await Promise.all(pages.map((p) => p.close()));
  }
  function onDeleteStep({ detail }) {
    recorder2.deleteStep(detail);
  }
  function getActivePage() {
    return browser.getActivePage();
  }
  function goBack() {
    getActivePage().goBack();
  }
  function goForward() {
    getActivePage().goForward();
  }
  function onReload() {
    getActivePage().reload();
  }
  function openInspector() {
    $$invalidate(7, inspector = true);
  }
  function onProxyChange(proxy2) {
    return browserView == null ? void 0 : browserView.client.api("proxy", "PUT", { id: (proxy2 == null ? void 0 : proxy2.id) || [] });
  }
  function onSessionChange(session2) {
    return browser == null ? void 0 : browser.call("setCookies", (session2 == null ? void 0 : session2.cookies) || []);
  }
  function input_input_handler() {
    url = this.value;
    $$invalidate(0, url);
  }
  const click_handler2 = (e) => dispatch("save", toJSON(steps));
  const click_handler_1 = (e) => dispatch("cancel");
  $$self.$$set = ($$new_props) => {
    $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(22, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(1, clazz = $$new_props.class);
    if ("proxy" in $$new_props)
      $$invalidate(23, proxy = $$new_props.proxy);
    if ("session" in $$new_props)
      $$invalidate(24, session = $$new_props.session);
    if ("bbx" in $$new_props)
      $$invalidate(2, bbx = $$new_props.bbx);
    if ("findSelector" in $$new_props)
      $$invalidate(25, findSelector = $$new_props.findSelector);
    if ("url" in $$new_props)
      $$invalidate(0, url = $$new_props.url);
    if ("initialSteps" in $$new_props)
      $$invalidate(26, initialSteps = $$new_props.initialSteps);
    if ("$$scope" in $$new_props)
      $$invalidate(31, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 8388608) {
      onProxyChange(proxy);
    }
    if ($$self.$$.dirty[0] & 16777216) {
      onSessionChange(session);
    }
  };
  return [
    url,
    clazz,
    bbx,
    recording,
    steps,
    playing,
    playingStatus,
    inspector,
    dispatch,
    addStep,
    replaceStep,
    onBrowserReady,
    record,
    stopRecording,
    stopReplay,
    replay2,
    onReset,
    onDeleteStep,
    goBack,
    goForward,
    onReload,
    openInspector,
    $$restProps,
    proxy,
    session,
    findSelector,
    initialSteps,
    slots,
    input_input_handler,
    click_handler2,
    click_handler_1,
    $$scope
  ];
}
class Recorder_1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$j, create_fragment$j, safe_not_equal, {
      class: 1,
      proxy: 23,
      session: 24,
      bbx: 2,
      findSelector: 25,
      url: 0,
      initialSteps: 26
    }, null, [-1, -1]);
  }
}
function create_else_block$c(ctx) {
  let t;
  return {
    c() {
      t = text("creating browser...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block$d(ctx) {
  let bbxrecorder;
  let current;
  bbxrecorder = new Recorder_1({
    props: {
      bbx: ctx[3],
      initialSteps: ctx[5],
      findSelector: ctx[6],
      proxy: ctx[1],
      session: ctx[2],
      url: ctx[4].meta.url,
      $$slots: { "tb-url-r": [create_tb_url_r_slot] },
      $$scope: { ctx }
    }
  });
  bbxrecorder.$on("save", ctx[9]);
  bbxrecorder.$on("cancel", ctx[10]);
  return {
    c() {
      create_component(bbxrecorder.$$.fragment);
    },
    m(target, anchor) {
      mount_component(bbxrecorder, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const bbxrecorder_changes = {};
      if (dirty & 8)
        bbxrecorder_changes.bbx = ctx2[3];
      if (dirty & 2)
        bbxrecorder_changes.proxy = ctx2[1];
      if (dirty & 4)
        bbxrecorder_changes.session = ctx2[2];
      if (dirty & 16)
        bbxrecorder_changes.url = ctx2[4].meta.url;
      if (dirty & 4102) {
        bbxrecorder_changes.$$scope = { dirty, ctx: ctx2 };
      }
      bbxrecorder.$set(bbxrecorder_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(bbxrecorder.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(bbxrecorder.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(bbxrecorder, detaching);
    }
  };
}
function create_tb_url_r_slot(ctx) {
  let selectproxy;
  let updating_proxy;
  let t;
  let selectsession;
  let updating_session;
  let current;
  function selectproxy_proxy_binding(value) {
    ctx[7](value);
  }
  let selectproxy_props = { class: "bbx-action px-2", title: "Proxy" };
  if (ctx[1] !== void 0) {
    selectproxy_props.proxy = ctx[1];
  }
  selectproxy = new SelectProxy({ props: selectproxy_props });
  binding_callbacks.push(() => bind$2(selectproxy, "proxy", selectproxy_proxy_binding));
  function selectsession_session_binding(value) {
    ctx[8](value);
  }
  let selectsession_props = {
    class: "bbx-action px-2",
    title: "Profile"
  };
  if (ctx[2] !== void 0) {
    selectsession_props.session = ctx[2];
  }
  selectsession = new SelectSession({ props: selectsession_props });
  binding_callbacks.push(() => bind$2(selectsession, "session", selectsession_session_binding));
  return {
    c() {
      create_component(selectproxy.$$.fragment);
      t = space();
      create_component(selectsession.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectproxy, target, anchor);
      insert(target, t, anchor);
      mount_component(selectsession, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectproxy_changes = {};
      if (!updating_proxy && dirty & 2) {
        updating_proxy = true;
        selectproxy_changes.proxy = ctx2[1];
        add_flush_callback(() => updating_proxy = false);
      }
      selectproxy.$set(selectproxy_changes);
      const selectsession_changes = {};
      if (!updating_session && dirty & 4) {
        updating_session = true;
        selectsession_changes.session = ctx2[2];
        add_flush_callback(() => updating_session = false);
      }
      selectsession.$set(selectsession_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(selectproxy.$$.fragment, local);
      transition_in(selectsession.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectproxy.$$.fragment, local);
      transition_out(selectsession.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectproxy, detaching);
      if (detaching)
        detach(t);
      destroy_component(selectsession, detaching);
    }
  };
}
function create_fragment$i(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$d, create_else_block$c];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[3])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$i($$self, $$props, $$invalidate) {
  let $macro, $$unsubscribe_macro = noop, $$subscribe_macro = () => ($$unsubscribe_macro(), $$unsubscribe_macro = subscribe(macro, ($$value) => $$invalidate(4, $macro = $$value)), macro);
  $$self.$$.on_destroy.push(() => $$unsubscribe_macro());
  let { macro } = $$props;
  $$subscribe_macro();
  let proxy;
  let session;
  let api = getContext$1("api");
  let bbx;
  let initialSteps = $macro.steps;
  onMount(async () => {
    try {
      $$invalidate(3, bbx = await api("/selectors2", "POST"));
    } catch (e) {
      console.error(e);
      loading = false;
      loadError = `Please try again later, failed to load recorder: ${e.message}`;
    }
  });
  async function findSelector(el) {
    let expr = await getCss([el], el.ownerDocument);
    return new CSSSelector(expr);
  }
  function selectproxy_proxy_binding(value) {
    proxy = value;
    $$invalidate(1, proxy);
  }
  function selectsession_session_binding(value) {
    session = value;
    $$invalidate(2, session);
  }
  function save_handler(event) {
    bubble.call(this, $$self, event);
  }
  function cancel_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("macro" in $$props2)
      $$subscribe_macro($$invalidate(0, macro = $$props2.macro));
  };
  return [
    macro,
    proxy,
    session,
    bbx,
    $macro,
    initialSteps,
    findSelector,
    selectproxy_proxy_binding,
    selectsession_session_binding,
    save_handler,
    cancel_handler
  ];
}
class Recorder extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$i, create_fragment$i, safe_not_equal, { macro: 0 });
  }
}
function get_each_context$6(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[25] = list[i2];
  child_ctx[27] = i2;
  return child_ctx;
}
function create_if_block_5$2(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "Please enter name and a valid start url for the recorder";
      attr(div, "class", "error");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_4$3(ctx) {
  let span;
  let t0;
  let t1_value = ctx[1].models.length + "";
  let t1;
  let t2;
  let t3;
  let t4;
  return {
    c() {
      span = element("span");
      t0 = text("Used ");
      t1 = text(t1_value);
      t2 = text(" of ");
      t3 = text(ctx[9]);
      t4 = text(" macros.");
      attr(span, "class", "error");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
      append(span, t2);
      append(span, t3);
      append(span, t4);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t1_value !== (t1_value = ctx2[1].models.length + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block_3$3(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = "Upgrade account to create and use macros in cloud.";
      attr(span, "class", "error");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_default_slot_2(ctx) {
  let div1;
  let div0;
  let input0;
  let t0;
  let input1;
  let t1;
  let span;
  let button;
  let t2;
  let button_disabled_value;
  let t3;
  let t4;
  let mounted;
  let dispose;
  let if_block0 = ctx[5] && create_if_block_5$2();
  function select_block_type(ctx2, dirty) {
    if (ctx2[9] == 0)
      return create_if_block_3$3;
    if (ctx2[2])
      return create_if_block_4$3;
  }
  let current_block_type = select_block_type(ctx);
  let if_block1 = current_block_type && current_block_type(ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      input0 = element("input");
      t0 = space();
      input1 = element("input");
      t1 = space();
      span = element("span");
      button = element("button");
      t2 = text("Add New Macro");
      t3 = space();
      if (if_block0)
        if_block0.c();
      t4 = space();
      if (if_block1)
        if_block1.c();
      attr(input0, "type", "text");
      attr(input0, "class", "form-control w-96");
      attr(input0, "placeholder", "New Macro Name");
      attr(input1, "type", "text");
      attr(input1, "class", "form-control w-96");
      attr(input1, "placeholder", "Start URL");
      attr(button, "class", "btn btn-default");
      attr(button, "role", "button");
      button.disabled = button_disabled_value = ctx[2] || ctx[7];
      attr(span, "class", "inline-block");
      attr(div0, "class", "flex");
      attr(div1, "class", "");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, input0);
      set_input_value(input0, ctx[3]);
      append(div0, t0);
      append(div0, input1);
      set_input_value(input1, ctx[4]);
      append(div0, t1);
      append(div0, span);
      append(span, button);
      append(button, t2);
      append(div1, t3);
      if (if_block0)
        if_block0.m(div1, null);
      append(div1, t4);
      if (if_block1)
        if_block1.m(div1, null);
      if (!mounted) {
        dispose = [
          listen(input0, "input", ctx[18]),
          listen(input1, "input", ctx[19]),
          listen(button, "click", ctx[11])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 8 && input0.value !== ctx2[3]) {
        set_input_value(input0, ctx2[3]);
      }
      if (dirty & 16 && input1.value !== ctx2[4]) {
        set_input_value(input1, ctx2[4]);
      }
      if (dirty & 132 && button_disabled_value !== (button_disabled_value = ctx2[2] || ctx2[7])) {
        button.disabled = button_disabled_value;
      }
      if (ctx2[5]) {
        if (if_block0)
          ;
        else {
          if_block0 = create_if_block_5$2();
          if_block0.c();
          if_block0.m(div1, t4);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if (if_block1)
          if_block1.d(1);
        if_block1 = current_block_type && current_block_type(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(div1, null);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (if_block0)
        if_block0.d();
      if (if_block1) {
        if_block1.d();
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_2$4(ctx) {
  let recordermodal;
  let current;
  recordermodal = new Modal$1({
    props: {
      $$slots: { default: [create_default_slot_1$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(recordermodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(recordermodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const recordermodal_changes = {};
      if (dirty & 268435520) {
        recordermodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      recordermodal.$set(recordermodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(recordermodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(recordermodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(recordermodal, detaching);
    }
  };
}
function create_default_slot_1$2(ctx) {
  let recorder2;
  let current;
  recorder2 = new Recorder({
    props: {
      class: "w-full",
      macro: ctx[6]
    }
  });
  recorder2.$on("cancel", ctx[14]);
  recorder2.$on("save", ctx[13]);
  return {
    c() {
      create_component(recorder2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(recorder2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const recorder_changes = {};
      if (dirty & 64)
        recorder_changes.macro = ctx2[6];
      recorder2.$set(recorder_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(recorder2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(recorder2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(recorder2, detaching);
    }
  };
}
function create_if_block$c(ctx) {
  let modal;
  let current;
  modal = new Modal$2({
    props: {
      $$slots: {
        header: [create_header_slot$2],
        default: [create_default_slot$5]
      },
      $$scope: { ctx }
    }
  });
  modal.$on("close", ctx[20]);
  return {
    c() {
      create_component(modal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modal_changes = {};
      if (dirty & 268435712) {
        modal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal.$set(modal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal, detaching);
    }
  };
}
function create_else_block$b(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let each_value = ctx[8].sieves;
  const get_key = (ctx2) => ctx2[25].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$6(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$6(key, child_ctx));
  }
  let each_1_else = null;
  if (!each_value.length) {
    each_1_else = create_else_block_1$2();
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
      if (each_1_else) {
        each_1_else.c();
      }
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      if (each_1_else) {
        each_1_else.m(target, anchor);
      }
    },
    p(ctx2, dirty) {
      if (dirty & 256) {
        each_value = ctx2[8].sieves;
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, destroy_block, create_each_block$6, each_1_anchor, get_each_context$6);
        if (each_value.length) {
          if (each_1_else) {
            each_1_else.d(1);
            each_1_else = null;
          }
        } else if (!each_1_else) {
          each_1_else = create_else_block_1$2();
          each_1_else.c();
          each_1_else.m(each_1_anchor.parentNode, each_1_anchor);
        }
      }
    },
    d(detaching) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
      if (detaching)
        detach(each_1_anchor);
      if (each_1_else)
        each_1_else.d(detaching);
    }
  };
}
function create_if_block_1$7(ctx) {
  let t;
  return {
    c() {
      t = text("Loading...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_else_block_1$2(ctx) {
  let t;
  return {
    c() {
      t = text("No monitor found using this macro.");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_each_block$6(key_1, ctx) {
  let div;
  let t_value = ctx[25].name + "";
  let t;
  return {
    key: key_1,
    first: null,
    c() {
      div = element("div");
      t = text(t_value);
      this.first = div;
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 256 && t_value !== (t_value = ctx[25].name + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_default_slot$5(ctx) {
  let div;
  function select_block_type_1(ctx2, dirty) {
    if (!ctx2[8].sieves)
      return create_if_block_1$7;
    return create_else_block$b;
  }
  let current_block_type = select_block_type_1(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      set_style(div, "max-height", "70vh");
      set_style(div, "overflow", "auto");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_block.m(div, null);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_1(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div, null);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_block.d();
    }
  };
}
function create_header_slot$2(ctx) {
  let span;
  let t0;
  let t1_value = ctx[8].name + "";
  let t1;
  return {
    c() {
      span = element("span");
      t0 = text("Monitors - ");
      t1 = text(t1_value);
      attr(span, "slot", "header");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
    },
    p(ctx2, dirty) {
      if (dirty & 256 && t1_value !== (t1_value = ctx2[8].name + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_fragment$h(ctx) {
  let list;
  let t0;
  let t1;
  let if_block1_anchor;
  let current;
  list = new List$4({
    props: {
      onDelete: ctx[12],
      openBrowser: ctx[15],
      showMonitors: ctx[16],
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    }
  });
  let if_block0 = ctx[6] && create_if_block_2$4(ctx);
  let if_block1 = ctx[8] && create_if_block$c(ctx);
  return {
    c() {
      create_component(list.$$.fragment);
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      mount_component(list, target, anchor);
      insert(target, t0, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const list_changes = {};
      if (dirty & 268435646) {
        list_changes.$$scope = { dirty, ctx: ctx2 };
      }
      list.$set(list_changes);
      if (ctx2[6]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 64) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_2$4(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[8]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 256) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$c(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(list.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(list.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      destroy_component(list, detaching);
      if (detaching)
        detach(t0);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t1);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(if_block1_anchor);
    }
  };
}
function instance$h($$self, $$props, $$invalidate) {
  let $store;
  let $user, $$unsubscribe_user = noop, $$subscribe_user = () => ($$unsubscribe_user(), $$unsubscribe_user = subscribe(user, ($$value) => $$invalidate(21, $user = $$value)), user);
  $$self.$$.on_destroy.push(() => $$unsubscribe_user());
  let { api = getContext$1("api") } = $$props;
  let { user = getContext$1("user") } = $$props;
  $$subscribe_user();
  let limit = $user.constraint.macro;
  let limitReached = false;
  let newName = "";
  let url = "";
  let missingInfo = false;
  let openMacro;
  let savingMacro = false;
  let showMonitorsForMacro = null;
  let store2 = new Macros([], { orderBy: "-ts" });
  component_subscribe($$self, store2, (value) => $$invalidate(1, $store = value));
  setContext("store", store2);
  onMount(async () => {
    await store2.fetch();
  });
  async function onAdd() {
    if (!newName || !url) {
      $$invalidate(5, missingInfo = true);
      return;
    }
    if (!url.startsWith("http")) {
      $$invalidate(4, url = "https://" + url);
    }
    $$invalidate(5, missingInfo = false);
    $$invalidate(7, savingMacro = true);
    $$invalidate(6, openMacro = await store2.create({
      name: newName || "Untitled",
      meta: { url }
    }, { wait: true }));
    $$invalidate(3, newName = "");
    $$invalidate(7, savingMacro = false);
    store2.fetch();
  }
  async function onDelete(model) {
    await removeMacroFromSieve(model.id);
    await model.destroy();
  }
  async function removeMacroFromSieve(id2) {
    let res2 = await api(`/sieves?macro_id=${id2}`, {
      "state.in": [40, 45, 90],
      _opt: { only: ["id"], limit: 100 }
    });
    let ids = res2.data.map((s) => s.id);
    if (ids.length == 0) {
      return;
    }
    await api("/batch/sieves", "PUT", { ids, macro_id: null });
    if (res2.total_count > res2.count) {
      await removeMacroFromSieve(id2);
    }
  }
  async function onSaveMacro(e) {
    await openMacro.save({ steps: e.detail });
    $$invalidate(6, openMacro = null);
    await store2.fetch();
  }
  function onDiscardMacro() {
    $$invalidate(6, openMacro = null);
  }
  function openBrowser(macro) {
    $$invalidate(6, openMacro = macro);
  }
  async function showMonitors(macro) {
    $$invalidate(8, showMonitorsForMacro = { ...macro, sieves: null });
    $$invalidate(8, showMonitorsForMacro.sieves = (await api(`/sieves?state.in[0]=40&state.in[1]=45&_opt[limit]=500&macro_id=${macro.id}`)).data, showMonitorsForMacro);
  }
  function input0_input_handler() {
    newName = this.value;
    $$invalidate(3, newName);
  }
  function input1_input_handler() {
    url = this.value;
    $$invalidate(4, url);
  }
  const close_handler = () => $$invalidate(8, showMonitorsForMacro = null);
  $$self.$$set = ($$props2) => {
    if ("api" in $$props2)
      $$invalidate(17, api = $$props2.api);
    if ("user" in $$props2)
      $$subscribe_user($$invalidate(0, user = $$props2.user));
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2) {
      $$invalidate(2, limitReached = $store.models.length >= limit);
    }
  };
  return [
    user,
    $store,
    limitReached,
    newName,
    url,
    missingInfo,
    openMacro,
    savingMacro,
    showMonitorsForMacro,
    limit,
    store2,
    onAdd,
    onDelete,
    onSaveMacro,
    onDiscardMacro,
    openBrowser,
    showMonitors,
    api,
    input0_input_handler,
    input1_input_handler,
    close_handler
  ];
}
class Macros_1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$h, create_fragment$h, safe_not_equal, { api: 17, user: 0 });
  }
}
class Session extends base.Model {
}
class Sessions extends base.PagedCollection {
  constructor() {
    super(...arguments);
    __publicField(this, "model", Session);
    __publicField(this, "url", "/sessions");
    __publicField(this, "limit", 20);
  }
}
function get_each_context$5(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[22] = list[i2];
  return child_ctx;
}
function create_each_block$5(key_1, ctx) {
  let option;
  let t_value = ctx[22].name + "";
  let t;
  let option_value_value;
  return {
    key: key_1,
    first: null,
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = option_value_value = ctx[22].id;
      option.value = option.__value;
      this.first = option;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 32 && t_value !== (t_value = ctx[22].name + ""))
        set_data(t, t_value);
      if (dirty & 32 && option_value_value !== (option_value_value = ctx[22].id)) {
        option.__value = option_value_value;
        option.value = option.__value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_if_block$b(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "loading...";
      set_style(div, "padding", "5px");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$g(ctx) {
  let div6;
  let div1;
  let h3;
  let t0_value = ctx[6].name + "";
  let t0;
  let t1;
  let t2;
  let div0;
  let button0;
  let t4;
  let button1;
  let t7;
  let ul;
  let li;
  let a;
  let t8;
  let t9;
  let div5;
  let div3;
  let div2;
  let input_1;
  let t10;
  let span2;
  let button2;
  let t12;
  let select;
  let option;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t14;
  let t15;
  let div4;
  let mounted;
  let dispose;
  let each_value = ctx[5];
  const get_key = (ctx2) => ctx2[22].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$5(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$5(key, child_ctx));
  }
  let if_block = ctx[1] && create_if_block$b();
  return {
    c() {
      div6 = element("div");
      div1 = element("div");
      h3 = element("h3");
      t0 = text(t0_value);
      t1 = text(" - Remote Browser");
      t2 = space();
      div0 = element("div");
      button0 = element("button");
      button0.textContent = "Save Cookies and Close";
      t4 = space();
      button1 = element("button");
      button1.innerHTML = `<span class="caret"></span> 
        <span class="sr-only">Toogle</span>`;
      t7 = space();
      ul = element("ul");
      li = element("li");
      a = element("a");
      t8 = text("Close (New Cookies not saved)");
      t9 = space();
      div5 = element("div");
      div3 = element("div");
      div2 = element("div");
      input_1 = element("input");
      t10 = space();
      span2 = element("span");
      button2 = element("button");
      button2.textContent = "Go";
      t12 = space();
      select = element("select");
      option = element("option");
      option.textContent = "-- Proxy --";
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t14 = space();
      if (if_block)
        if_block.c();
      t15 = space();
      div4 = element("div");
      set_style(h3, "flex", "1");
      attr(button0, "class", "btn btn-default");
      attr(button1, "type", "button");
      attr(button1, "class", "btn btn-default drowdown-toggle");
      attr(button1, "data-toggle", "dropdown");
      attr(a, "href", href);
      attr(ul, "class", "dropdown-menu");
      attr(div0, "class", "btn-group");
      attr(div1, "class", "panel-heading");
      set_style(div1, "display", "flex");
      set_style(div1, "align-items", "center");
      attr(input_1, "class", "form-control");
      attr(input_1, "type", "text");
      attr(button2, "class", "btn btn-default");
      attr(span2, "class", "input-group-btn");
      attr(div2, "class", "input-group flex-1");
      option.__value = "";
      option.value = option.__value;
      attr(div3, "class", "flex gap-2");
      attr(div4, "class", "flex-auto");
      set_style(div4, "position", "relative");
      set_style(div4, "background-color", "#fff");
      attr(div5, "class", "panel-body flex-auto flex flex-column");
      set_style(div5, "padding", "0");
      attr(div6, "class", "panel panel-default flex-auto flex flex-column");
      set_style(div6, "margin", "0");
    },
    m(target, anchor) {
      insert(target, div6, anchor);
      append(div6, div1);
      append(div1, h3);
      append(h3, t0);
      append(h3, t1);
      append(div1, t2);
      append(div1, div0);
      append(div0, button0);
      append(div0, t4);
      append(div0, button1);
      append(div0, t7);
      append(div0, ul);
      append(ul, li);
      append(li, a);
      append(a, t8);
      append(div6, t9);
      append(div6, div5);
      append(div5, div3);
      append(div3, div2);
      append(div2, input_1);
      set_input_value(input_1, ctx[4]);
      ctx[13](input_1);
      append(div2, t10);
      append(div2, span2);
      append(span2, button2);
      append(div3, t12);
      append(div3, select);
      append(select, option);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(select, null);
      }
      append(div5, t14);
      if (if_block)
        if_block.m(div5, null);
      append(div5, t15);
      append(div5, div4);
      ctx[14](div4);
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[9]),
          listen(a, "click", ctx[10]),
          listen(input_1, "input", ctx[12]),
          listen(input_1, "keypress", ctx[11]),
          listen(button2, "click", ctx[7]),
          listen(select, "change", ctx[8])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 64 && t0_value !== (t0_value = ctx2[6].name + ""))
        set_data(t0, t0_value);
      if (dirty & 16 && input_1.value !== ctx2[4]) {
        set_input_value(input_1, ctx2[4]);
      }
      if (dirty & 32) {
        each_value = ctx2[5];
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, select, destroy_block, create_each_block$5, null, get_each_context$5);
      }
      if (ctx2[1]) {
        if (if_block)
          ;
        else {
          if_block = create_if_block$b();
          if_block.c();
          if_block.m(div5, t15);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div6);
      ctx[13](null);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      if (if_block)
        if_block.d();
      ctx[14](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
let href = "#";
function instance$g($$self, $$props, $$invalidate) {
  let $session, $$unsubscribe_session = noop, $$subscribe_session = () => ($$unsubscribe_session(), $$unsubscribe_session = subscribe(session, ($$value) => $$invalidate(6, $session = $$value)), session);
  $$self.$$.on_destroy.push(() => $$unsubscribe_session());
  let { session } = $$props;
  $$subscribe_session();
  let api = getContext$1("api");
  getContext$1("store");
  let loading2 = true;
  let input;
  let container;
  let bbx;
  let browserView;
  let browser;
  let url = "https://www.google.com";
  let proxies = [];
  const dispatch = createEventDispatcher();
  onMount(async () => {
    bbx = await api("/selectors2", "POST");
    browserView = await createView({ ...bbx, container });
    browser = browserView.store;
    await browser.call("setCookies", session.cookies || []);
    $$invalidate(1, loading2 = false);
    $$invalidate(5, proxies = await getProxies());
    go();
  });
  onDestroy(() => {
    api("/selectors2/" + bbx.id, "DELETE");
  });
  function go() {
    if (url) {
      browser.pages[0].goto(url);
    }
  }
  async function onSelectProxy(e) {
    let id2 = e.target.value;
    $$invalidate(1, loading2 = true);
    await browserView.client.api("proxy", "PUT", { id: id2 });
    $$invalidate(1, loading2 = false);
  }
  async function onSaveAndClose() {
    let res2 = await browser.call("getCookies");
    let cookies = res2;
    dispatch("save", { url, cookies });
  }
  function onDiscard(e) {
    e.preventDefault();
    dispatch("discard");
  }
  function onInputKey(e) {
    if (e.keyCode == 13) {
      go();
      input.blur();
    }
  }
  function input_1_input_handler() {
    url = this.value;
    $$invalidate(4, url);
  }
  function input_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      input = $$value;
      $$invalidate(2, input);
    });
  }
  function div4_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      container = $$value;
      $$invalidate(3, container);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("session" in $$props2)
      $$subscribe_session($$invalidate(0, session = $$props2.session));
  };
  return [
    session,
    loading2,
    input,
    container,
    url,
    proxies,
    $session,
    go,
    onSelectProxy,
    onSaveAndClose,
    onDiscard,
    onInputKey,
    input_1_input_handler,
    input_1_binding,
    div4_binding
  ];
}
class Browser extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$g, create_fragment$g, safe_not_equal, { session: 0 });
  }
}
function create_default_slot_1$1(ctx) {
  let t;
  return {
    c() {
      t = text("clear cookies");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$4(ctx) {
  let i2;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", "fa fa-trash-o error");
      set_style(i2, "font-size", "1.5em");
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(i2);
    }
  };
}
function create_fragment$f(ctx) {
  let tr;
  let td0;
  let t0_value = ctx[5].name + "";
  let t0;
  let t1;
  let td1;
  let t2_value = (ctx[5].cookies ? ctx[5].cookies.length : 0) + "";
  let t2;
  let t3;
  let td2;
  let button0;
  let t5;
  let button1;
  let t7;
  let div1;
  let confirmbtn0;
  let t8;
  let div0;
  let t9;
  let td3;
  let confirmbtn1;
  let current;
  let mounted;
  let dispose;
  confirmbtn0 = new ConfirmBtn({
    props: {
      class: "btn-xs",
      $$slots: { default: [create_default_slot_1$1] },
      $$scope: { ctx }
    }
  });
  confirmbtn0.$on("click", ctx[8]);
  confirmbtn1 = new ConfirmBtn({
    props: {
      alignRight: "1",
      $$slots: { default: [create_default_slot$4] },
      $$scope: { ctx }
    }
  });
  confirmbtn1.$on("click", ctx[9]);
  return {
    c() {
      tr = element("tr");
      td0 = element("td");
      t0 = text(t0_value);
      t1 = space();
      td1 = element("td");
      t2 = text(t2_value);
      t3 = space();
      td2 = element("td");
      button0 = element("button");
      button0.textContent = "open remote browser";
      t5 = space();
      button1 = element("button");
      button1.textContent = "view monitors";
      t7 = space();
      div1 = element("div");
      create_component(confirmbtn0.$$.fragment);
      t8 = space();
      div0 = element("div");
      t9 = space();
      td3 = element("td");
      create_component(confirmbtn1.$$.fragment);
      attr(button0, "class", "btn btn-default btn-xs");
      attr(button1, "class", "btn btn-default btn-xs");
      attr(div1, "class", "inline");
      attr(td3, "title", "Delete");
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td0);
      append(td0, t0);
      append(tr, t1);
      append(tr, td1);
      append(td1, t2);
      append(tr, t3);
      append(tr, td2);
      append(td2, button0);
      append(td2, t5);
      append(td2, button1);
      append(td2, t7);
      append(td2, div1);
      mount_component(confirmbtn0, div1, null);
      append(div1, t8);
      append(div1, div0);
      append(tr, t9);
      append(tr, td3);
      mount_component(confirmbtn1, td3, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[6]),
          listen(button1, "click", ctx[7])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & 32) && t0_value !== (t0_value = ctx2[5].name + ""))
        set_data(t0, t0_value);
      if ((!current || dirty & 32) && t2_value !== (t2_value = (ctx2[5].cookies ? ctx2[5].cookies.length : 0) + ""))
        set_data(t2, t2_value);
      const confirmbtn0_changes = {};
      if (dirty & 1024) {
        confirmbtn0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      confirmbtn0.$set(confirmbtn0_changes);
      const confirmbtn1_changes = {};
      if (dirty & 1024) {
        confirmbtn1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      confirmbtn1.$set(confirmbtn1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(confirmbtn0.$$.fragment, local);
      transition_in(confirmbtn1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(confirmbtn0.$$.fragment, local);
      transition_out(confirmbtn1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(tr);
      destroy_component(confirmbtn0);
      destroy_component(confirmbtn1);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$f($$self, $$props, $$invalidate) {
  let $sess, $$unsubscribe_sess = noop, $$subscribe_sess = () => ($$unsubscribe_sess(), $$unsubscribe_sess = subscribe(sess, ($$value) => $$invalidate(5, $sess = $$value)), sess);
  $$self.$$.on_destroy.push(() => $$unsubscribe_sess());
  let { sess } = $$props;
  $$subscribe_sess();
  let { onClear: onClear2 } = $$props;
  let { openBrowser } = $$props;
  let { showMonitors } = $$props;
  let { onDelete } = $$props;
  const click_handler2 = (e) => openBrowser(sess);
  const click_handler_1 = (e) => showMonitors($sess);
  const click_handler_2 = (e) => onClear2(sess);
  const click_handler_3 = (e) => onDelete(sess);
  $$self.$$set = ($$props2) => {
    if ("sess" in $$props2)
      $$subscribe_sess($$invalidate(0, sess = $$props2.sess));
    if ("onClear" in $$props2)
      $$invalidate(1, onClear2 = $$props2.onClear);
    if ("openBrowser" in $$props2)
      $$invalidate(2, openBrowser = $$props2.openBrowser);
    if ("showMonitors" in $$props2)
      $$invalidate(3, showMonitors = $$props2.showMonitors);
    if ("onDelete" in $$props2)
      $$invalidate(4, onDelete = $$props2.onDelete);
  };
  return [
    sess,
    onClear2,
    openBrowser,
    showMonitors,
    onDelete,
    $sess,
    click_handler2,
    click_handler_1,
    click_handler_2,
    click_handler_3
  ];
}
class Profile extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$f, create_fragment$f, safe_not_equal, {
      sess: 0,
      onClear: 1,
      openBrowser: 2,
      showMonitors: 3,
      onDelete: 4
    });
  }
}
function get_each_context$4(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[12] = list[i2];
  child_ctx[14] = i2;
  return child_ctx;
}
function create_catch_block$2(ctx) {
  return {
    c: noop,
    m: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$2(ctx) {
  return {
    c: noop,
    m: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_pending_block$2(ctx) {
  let td;
  let loader;
  let current;
  loader = new Loader({});
  return {
    c() {
      td = element("td");
      create_component(loader.$$.fragment);
      attr(td, "colspan", "4");
    },
    m(target, anchor) {
      insert(target, td, anchor);
      mount_component(loader, td, null);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(td);
      destroy_component(loader);
    }
  };
}
function create_else_block$a(ctx) {
  let tr;
  return {
    c() {
      tr = element("tr");
      tr.innerHTML = `<td>No session found. 
      </td>`;
    },
    m(target, anchor) {
      insert(target, tr, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(tr);
    }
  };
}
function create_each_block$4(key_1, ctx) {
  let first;
  let profile;
  let current;
  profile = new Profile({
    props: {
      sess: ctx[12],
      onClear: ctx[2],
      openBrowser: ctx[0],
      showMonitors: ctx[1],
      onDelete: ctx[3]
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(profile.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(profile, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const profile_changes = {};
      if (dirty & 32)
        profile_changes.sess = ctx[12];
      if (dirty & 4)
        profile_changes.onClear = ctx[2];
      if (dirty & 1)
        profile_changes.openBrowser = ctx[0];
      if (dirty & 2)
        profile_changes.showMonitors = ctx[1];
      if (dirty & 8)
        profile_changes.onDelete = ctx[3];
      profile.$set(profile_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(profile.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(profile.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      destroy_component(profile, detaching);
    }
  };
}
function create_fragment$e(ctx) {
  let div3;
  let div2;
  let div0;
  let h3;
  let t1;
  let small;
  let t2;
  let a;
  let t3;
  let t4;
  let div1;
  let t5;
  let searchbar;
  let t6;
  let listpager;
  let t7;
  let sortby;
  let t8;
  let table;
  let tbody;
  let tr0;
  let td;
  let t9;
  let tr1;
  let t16;
  let promise;
  let t17;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  searchbar = new SearchBar({});
  searchbar.$on("search", ctx[7]);
  listpager = new ListPager({ props: { store: ctx[4] } });
  sortby = new SortBy({
    props: {
      onSort: ctx[8],
      sortingFields: ctx[6],
      currentFieldName: ctx[5].orderBy
    }
  });
  const default_slot_template = ctx[10].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[9], null);
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$2,
    then: create_then_block$2,
    catch: create_catch_block$2,
    blocks: [, , ,]
  };
  handle_promise(promise = ctx[5].fetchPromise, info);
  let each_value = ctx[5].models;
  const get_key = (ctx2) => ctx2[12].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$4(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$4(key, child_ctx));
  }
  let each_1_else = null;
  if (!each_value.length) {
    each_1_else = create_else_block$a();
  }
  return {
    c() {
      div3 = element("div");
      div2 = element("div");
      div0 = element("div");
      h3 = element("h3");
      h3.textContent = "Profiles";
      t1 = space();
      small = element("small");
      t2 = text("Create and use profiles for checks in cloud that require cookies or authentication.\n      ");
      a = element("a");
      t3 = text("Learn More");
      t4 = space();
      div1 = element("div");
      t5 = space();
      create_component(searchbar.$$.fragment);
      t6 = space();
      create_component(listpager.$$.fragment);
      t7 = space();
      create_component(sortby.$$.fragment);
      t8 = space();
      table = element("table");
      tbody = element("tbody");
      tr0 = element("tr");
      td = element("td");
      if (default_slot)
        default_slot.c();
      t9 = space();
      tr1 = element("tr");
      tr1.innerHTML = `<th>Name</th> 
        <th>Cookies</th> 
        <th>Options</th> 
        <th style="width: 20px"></th>`;
      t16 = space();
      info.block.c();
      t17 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      if (each_1_else) {
        each_1_else.c();
      }
      attr(a, "href", URL_WEBSITE + "/kb/help/profiles-for-cloud-monitors");
      attr(a, "target", "_blank");
      set_style(div0, "flex", "1");
      attr(div1, "class", "flex-1");
      set_style(div1, "max-width", "50px");
      attr(div2, "class", "panel-heading flex items-center");
      attr(td, "colspan", "4");
      set_style(td, "background-color", "#eee");
      attr(tr1, "class", "bg-gray-200");
      attr(table, "class", "table");
      attr(div3, "class", "panel panel-default");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div2);
      append(div2, div0);
      append(div0, h3);
      append(div0, t1);
      append(div0, small);
      append(small, t2);
      append(small, a);
      append(a, t3);
      append(div2, t4);
      append(div2, div1);
      append(div2, t5);
      mount_component(searchbar, div2, null);
      append(div2, t6);
      mount_component(listpager, div2, null);
      append(div2, t7);
      mount_component(sortby, div2, null);
      append(div3, t8);
      append(div3, table);
      append(table, tbody);
      append(tbody, tr0);
      append(tr0, td);
      if (default_slot) {
        default_slot.m(td, null);
      }
      append(tbody, t9);
      append(tbody, tr1);
      append(tbody, t16);
      info.block.m(tbody, info.anchor = null);
      info.mount = () => tbody;
      info.anchor = t17;
      append(tbody, t17);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(tbody, null);
      }
      if (each_1_else) {
        each_1_else.m(tbody, null);
      }
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      const listpager_changes = {};
      if (dirty & 16)
        listpager_changes.store = ctx[4];
      listpager.$set(listpager_changes);
      const sortby_changes = {};
      if (dirty & 32)
        sortby_changes.currentFieldName = ctx[5].orderBy;
      sortby.$set(sortby_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 512)) {
          update_slot_base(default_slot, default_slot_template, ctx, ctx[9], !current ? get_all_dirty_from_scope(ctx[9]) : get_slot_changes(default_slot_template, ctx[9], dirty, null), null);
        }
      }
      info.ctx = ctx;
      dirty & 32 && promise !== (promise = ctx[5].fetchPromise) && handle_promise(promise, info);
      if (dirty & 47) {
        each_value = ctx[5].models;
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, tbody, outro_and_destroy_block, create_each_block$4, null, get_each_context$4);
        check_outros();
        if (!each_value.length && each_1_else) {
          each_1_else.p(ctx, dirty);
        } else if (!each_value.length) {
          each_1_else = create_else_block$a();
          each_1_else.c();
          each_1_else.m(tbody, null);
        } else if (each_1_else) {
          each_1_else.d(1);
          each_1_else = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(searchbar.$$.fragment, local);
      transition_in(listpager.$$.fragment, local);
      transition_in(sortby.$$.fragment, local);
      transition_in(default_slot, local);
      transition_in(info.block);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(searchbar.$$.fragment, local);
      transition_out(listpager.$$.fragment, local);
      transition_out(sortby.$$.fragment, local);
      transition_out(default_slot, local);
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      destroy_component(searchbar);
      destroy_component(listpager);
      destroy_component(sortby);
      if (default_slot)
        default_slot.d(detaching);
      info.block.d();
      info.token = null;
      info = null;
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      if (each_1_else)
        each_1_else.d();
    }
  };
}
function instance$e($$self, $$props, $$invalidate) {
  let $store;
  let { $$slots: slots = {}, $$scope } = $$props;
  let store2 = getContext$1("store");
  component_subscribe($$self, store2, (value) => $$invalidate(5, $store = value));
  let { openBrowser } = $$props;
  let { showMonitors } = $$props;
  let { onClear: onClear2 } = $$props;
  let { onDelete } = $$props;
  let searchQuery = "";
  let sortingFields = [
    { value: "-ts", label: "Newest First" },
    { value: "ts", label: "Oldest First" },
    { value: "name", label: "Name" },
    {
      value: "-name",
      label: "Name - Descending"
    }
  ];
  async function onSearch2(e) {
    let { phrase } = e.detail;
    if (!phrase) {
      store2.setQuery({});
      return await store2.fetch({ reset: true });
    }
    searchQuery = `%${phrase}%`;
    store2.setQuery({ "name.ilike": searchQuery });
    await store2.fetch({ reset: true });
  }
  async function onSort(by) {
    $$invalidate(4, store2.orderBy = by, store2);
    await store2.fetch({ reset: true });
  }
  $$self.$$set = ($$props2) => {
    if ("openBrowser" in $$props2)
      $$invalidate(0, openBrowser = $$props2.openBrowser);
    if ("showMonitors" in $$props2)
      $$invalidate(1, showMonitors = $$props2.showMonitors);
    if ("onClear" in $$props2)
      $$invalidate(2, onClear2 = $$props2.onClear);
    if ("onDelete" in $$props2)
      $$invalidate(3, onDelete = $$props2.onDelete);
    if ("$$scope" in $$props2)
      $$invalidate(9, $$scope = $$props2.$$scope);
  };
  return [
    openBrowser,
    showMonitors,
    onClear2,
    onDelete,
    store2,
    $store,
    sortingFields,
    onSearch2,
    onSort,
    $$scope,
    slots
  ];
}
class List$3 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$e, create_fragment$e, safe_not_equal, {
      openBrowser: 0,
      showMonitors: 1,
      onClear: 2,
      onDelete: 3
    });
  }
}
const get_header_slot_changes = (dirty) => ({});
const get_header_slot_context = (ctx) => ({});
function create_fragment$d(ctx) {
  let div5;
  let div4;
  let div3;
  let div0;
  let button0;
  let t1;
  let h4;
  let t2;
  let div1;
  let t3;
  let div2;
  let button1;
  let current;
  let mounted;
  let dispose;
  const header_slot_template = ctx[4].header;
  const header_slot = create_slot(header_slot_template, ctx, ctx[3], get_header_slot_context);
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  return {
    c() {
      div5 = element("div");
      div4 = element("div");
      div3 = element("div");
      div0 = element("div");
      button0 = element("button");
      button0.innerHTML = `<span aria-hidden="true">\xD7</span>`;
      t1 = space();
      h4 = element("h4");
      if (header_slot)
        header_slot.c();
      t2 = space();
      div1 = element("div");
      if (default_slot)
        default_slot.c();
      t3 = space();
      div2 = element("div");
      button1 = element("button");
      button1.textContent = "close modal";
      attr(button0, "type", "button");
      attr(button0, "class", "close");
      attr(button0, "data-dismiss", "modal");
      attr(button0, "aria-label", "Close");
      attr(h4, "class", "modal-title");
      attr(div0, "class", "modal-header");
      attr(div1, "class", "modal-body");
      attr(button1, "type", "button");
      button1.autofocus = true;
      attr(button1, "class", "btn btn-default");
      attr(div2, "class", "modal-footer");
      attr(div3, "class", "modal-content");
      attr(div4, "class", "modal-dialog");
      attr(div4, "role", "document");
      attr(div5, "class", "modal");
      attr(div5, "tabindex", "-1");
      attr(div5, "role", "dialog");
      set_style(div5, "display", "block");
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div4);
      append(div4, div3);
      append(div3, div0);
      append(div0, button0);
      append(div0, t1);
      append(div0, h4);
      if (header_slot) {
        header_slot.m(h4, null);
      }
      append(div3, t2);
      append(div3, div1);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      append(div3, t3);
      append(div3, div2);
      append(div2, button1);
      ctx[5](div5);
      current = true;
      button1.focus();
      if (!mounted) {
        dispose = [
          listen(window, "keydown", ctx[2]),
          listen(button1, "click", ctx[1]),
          listen(div5, "click", ctx[1])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (header_slot) {
        if (header_slot.p && (!current || dirty & 8)) {
          update_slot_base(header_slot, header_slot_template, ctx2, ctx2[3], !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(header_slot_template, ctx2[3], dirty, get_header_slot_changes), get_header_slot_context);
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[3], !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(header_slot, local);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(header_slot, local);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div5);
      if (header_slot)
        header_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      ctx[5](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$d($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const dispatch = createEventDispatcher();
  const close = () => dispatch("close");
  let modal;
  const handle_keydown = (e) => {
    if (e.key === "Escape") {
      close();
      return;
    }
    if (e.key === "Tab") {
      const nodes = modal.querySelectorAll("*");
      const tabbable = Array.from(nodes).filter((n) => n.tabIndex >= 0);
      let index2 = tabbable.indexOf(document.activeElement);
      if (index2 === -1 && e.shiftKey)
        index2 = 0;
      index2 += tabbable.length + (e.shiftKey ? -1 : 1);
      index2 %= tabbable.length;
      tabbable[index2].focus();
      e.preventDefault();
    }
  };
  const previously_focused = typeof document !== "undefined" && document.activeElement;
  if (previously_focused) {
    onDestroy(() => {
      previously_focused.focus();
    });
  }
  function div5_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      modal = $$value;
      $$invalidate(0, modal);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [modal, close, handle_keydown, $$scope, slots, div5_binding];
}
class Modal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$d, create_fragment$d, safe_not_equal, {});
  }
}
function get_each_context$3(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[22] = list[i2];
  child_ctx[24] = i2;
  return child_ctx;
}
function create_if_block_4$2(ctx) {
  let span;
  let t0;
  let t1_value = ctx[0].models.length + "";
  let t1;
  let t2;
  let t3;
  let t4;
  return {
    c() {
      span = element("span");
      t0 = text("Used ");
      t1 = text(t1_value);
      t2 = text(" of ");
      t3 = text(ctx[6]);
      t4 = text(" profiles.");
      attr(span, "class", "error");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
      append(span, t2);
      append(span, t3);
      append(span, t4);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t1_value !== (t1_value = ctx2[0].models.length + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block_3$2(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = "Upgrade account to create and use profiles in cloud.";
      attr(span, "class", "error");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_default_slot_1(ctx) {
  let div1;
  let div0;
  let input;
  let t0;
  let span;
  let button;
  let t1;
  let t2;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (ctx2[6] == 0)
      return create_if_block_3$2;
    if (ctx2[1])
      return create_if_block_4$2;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type && current_block_type(ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      input = element("input");
      t0 = space();
      span = element("span");
      button = element("button");
      t1 = text("Add New Profile");
      t2 = space();
      if (if_block)
        if_block.c();
      attr(input, "type", "text");
      attr(input, "class", "form-control");
      attr(input, "placeholder", "New Profile Name");
      attr(button, "class", "btn btn-default");
      attr(button, "role", "button");
      button.disabled = ctx[1];
      attr(span, "class", "input-group-btn");
      attr(div0, "class", "input-group mr3");
      attr(div1, "class", "flex items-center");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, input);
      set_input_value(input, ctx[2]);
      append(div0, t0);
      append(div0, span);
      append(span, button);
      append(button, t1);
      append(div1, t2);
      if (if_block)
        if_block.m(div1, null);
      if (!mounted) {
        dispose = [
          listen(input, "input", ctx[14]),
          listen(button, "click", ctx[8])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 4 && input.value !== ctx2[2]) {
        set_input_value(input, ctx2[2]);
      }
      if (dirty & 2) {
        button.disabled = ctx2[1];
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if (if_block)
          if_block.d(1);
        if_block = current_block_type && current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div1, null);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (if_block) {
        if_block.d();
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_2$3(ctx) {
  let div;
  let browser;
  let current;
  browser = new Browser({
    props: { session: ctx[3] }
  });
  browser.$on("save", ctx[10]);
  browser.$on("discard", ctx[11]);
  browser.$on("clear", ctx[15]);
  return {
    c() {
      div = element("div");
      create_component(browser.$$.fragment);
      attr(div, "class", "flex");
      set_style(div, "z-index", "10");
      set_style(div, "background-color", "#fff");
      set_style(div, "position", "fixed");
      set_style(div, "right", "0");
      set_style(div, "bottom", "0");
      set_style(div, "width", "70vw");
      set_style(div, "height", "80vh");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(browser, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const browser_changes = {};
      if (dirty & 8)
        browser_changes.session = ctx2[3];
      browser.$set(browser_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(browser.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(browser.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(browser);
    }
  };
}
function create_if_block$a(ctx) {
  let modal;
  let current;
  modal = new Modal({
    props: {
      $$slots: {
        header: [create_header_slot$1],
        default: [create_default_slot$3]
      },
      $$scope: { ctx }
    }
  });
  modal.$on("close", ctx[16]);
  return {
    c() {
      create_component(modal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modal_changes = {};
      if (dirty & 33554448) {
        modal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal.$set(modal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal, detaching);
    }
  };
}
function create_else_block$9(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let each_value = ctx[4].sieves;
  const get_key = (ctx2) => ctx2[22].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$3(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$3(key, child_ctx));
  }
  let each_1_else = null;
  if (!each_value.length) {
    each_1_else = create_else_block_1$1();
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
      if (each_1_else) {
        each_1_else.c();
      }
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      if (each_1_else) {
        each_1_else.m(target, anchor);
      }
    },
    p(ctx2, dirty) {
      if (dirty & 16) {
        each_value = ctx2[4].sieves;
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, destroy_block, create_each_block$3, each_1_anchor, get_each_context$3);
        if (each_value.length) {
          if (each_1_else) {
            each_1_else.d(1);
            each_1_else = null;
          }
        } else if (!each_1_else) {
          each_1_else = create_else_block_1$1();
          each_1_else.c();
          each_1_else.m(each_1_anchor.parentNode, each_1_anchor);
        }
      }
    },
    d(detaching) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
      if (detaching)
        detach(each_1_anchor);
      if (each_1_else)
        each_1_else.d(detaching);
    }
  };
}
function create_if_block_1$6(ctx) {
  let t;
  return {
    c() {
      t = text("Loading...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_else_block_1$1(ctx) {
  let t;
  return {
    c() {
      t = text("No monitor found");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_each_block$3(key_1, ctx) {
  let div;
  let t_value = ctx[22].name + "";
  let t;
  return {
    key: key_1,
    first: null,
    c() {
      div = element("div");
      t = text(t_value);
      this.first = div;
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 16 && t_value !== (t_value = ctx[22].name + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_default_slot$3(ctx) {
  let div;
  function select_block_type_1(ctx2, dirty) {
    if (!ctx2[4].sieves)
      return create_if_block_1$6;
    return create_else_block$9;
  }
  let current_block_type = select_block_type_1(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      set_style(div, "max-height", "70vh");
      set_style(div, "overflow", "auto");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_block.m(div, null);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_1(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div, null);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_block.d();
    }
  };
}
function create_header_slot$1(ctx) {
  let span;
  let t0;
  let t1_value = ctx[4].name + "";
  let t1;
  return {
    c() {
      span = element("span");
      t0 = text("Monitors - ");
      t1 = text(t1_value);
      attr(span, "slot", "header");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
    },
    p(ctx2, dirty) {
      if (dirty & 16 && t1_value !== (t1_value = ctx2[4].name + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_fragment$c(ctx) {
  let list;
  let t0;
  let t1;
  let if_block1_anchor;
  let current;
  list = new List$3({
    props: {
      store: ctx[7],
      openBrowser: ctx[12],
      showMonitors: ctx[13],
      onClear,
      onDelete: ctx[9],
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    }
  });
  let if_block0 = ctx[3] && create_if_block_2$3(ctx);
  let if_block1 = ctx[4] && create_if_block$a(ctx);
  return {
    c() {
      create_component(list.$$.fragment);
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      mount_component(list, target, anchor);
      insert(target, t0, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const list_changes = {};
      if (dirty & 33554439) {
        list_changes.$$scope = { dirty, ctx: ctx2 };
      }
      list.$set(list_changes);
      if (ctx2[3]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_2$3(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[4]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 16) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$a(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(list.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(list.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      destroy_component(list, detaching);
      if (detaching)
        detach(t0);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t1);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(if_block1_anchor);
    }
  };
}
async function onClear(session) {
  await session.save({ cookies: [] });
}
function instance$c($$self, $$props, $$invalidate) {
  let $store;
  let $user;
  let api = getContext$1("api");
  let user = getContext$1("user");
  component_subscribe($$self, user, (value) => $$invalidate(17, $user = value));
  getContext$1("labels");
  let limit = $user.constraint.session;
  let limitReached = false;
  let newName;
  let openSession;
  let showMonitorsForSession = null;
  let store2 = new Sessions([], { orderBy: "-ts" });
  component_subscribe($$self, store2, (value) => $$invalidate(0, $store = value));
  setContext("api", api);
  setContext("store", store2);
  onMount(async () => {
    await store2.fetch();
  });
  async function onAdd() {
    $$invalidate(3, openSession = await store2.create({ name: newName || "Untitled" }));
    $$invalidate(2, newName = "");
  }
  async function onDelete(model) {
    await removeSessionFromSieve(model.id);
    await model.destroy();
  }
  async function removeSessionFromSieve(id2) {
    let res2 = await api(`/sieves?session_id=${id2}`, {
      "state.in": [40, 45, 90],
      _opt: { only: ["id"], limit: 100 }
    });
    let ids = res2.data.map((s) => s.id);
    if (ids.length == 0) {
      return;
    }
    await api("/batch/sieves", "PUT", { ids, session_id: null });
    if (res2.total_count > res2.count) {
      await removeSessionFromSieve(id2);
    }
  }
  async function onSaveData(e) {
    let { cookies } = e.detail;
    await openSession.save({ cookies });
    $$invalidate(3, openSession = null);
  }
  function onDiscard() {
    $$invalidate(3, openSession = null);
  }
  function openBrowser(session) {
    $$invalidate(3, openSession = session);
  }
  async function showMonitors(session) {
    $$invalidate(4, showMonitorsForSession = { ...session, sieves: null });
    $$invalidate(4, showMonitorsForSession.sieves = (await api(`/sieves?state.in[0]=40&state.in[1]=45&_opt[limit]=500&session_id=${session.id}`)).data, showMonitorsForSession);
  }
  function input_input_handler() {
    newName = this.value;
    $$invalidate(2, newName);
  }
  const clear_handler = (e) => onClear(openSession.id);
  const close_handler = () => $$invalidate(4, showMonitorsForSession = null);
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $$invalidate(1, limitReached = $store.length >= limit);
    }
  };
  return [
    $store,
    limitReached,
    newName,
    openSession,
    showMonitorsForSession,
    user,
    limit,
    store2,
    onAdd,
    onDelete,
    onSaveData,
    onDiscard,
    openBrowser,
    showMonitors,
    input_input_handler,
    clear_handler,
    close_handler
  ];
}
class Profiles extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$c, create_fragment$c, safe_not_equal, {});
  }
}
function createProxies(api) {
  let fetched = false;
  const { subscribe: subscribe2, set, update } = writable({
    loading: true,
    custom: {
      total_count: 0,
      count: 0,
      offset: 0,
      data: []
    },
    global: {
      total_count: 0,
      count: 0,
      offset: 0,
      data: []
    },
    plan_id: ""
  });
  async function fetch_custom_proxy() {
    const custom = await api("/proxies");
    const constraint = await api("/users/constraints");
    const global = await api("/proxies/global");
    update((old) => ({
      loading: false,
      constraint,
      custom,
      global,
      plan_id: constraint.plan_id
    }));
  }
  async function del(id2) {
    let res2 = await api("/proxies/" + id2, "DELETE");
    fetch_custom_proxy();
    return res2;
  }
  async function add(doc) {
    const res2 = await api("/proxies", "POST", doc);
    fetch_custom_proxy();
    return res2;
  }
  async function patch2(doc) {
    const res2 = await api("/proxies/" + doc.id, "PATCH", doc);
    await fetch_custom_proxy();
    return res2;
  }
  return {
    subscribe: subscribe2,
    async fetch() {
      !fetched && await fetch_custom_proxy();
      fetched = true;
    },
    del,
    add,
    patch: patch2
  };
}
var EditProxy_svelte_svelte_type_style_lang = "";
function create_if_block_1$5(ctx) {
  let p;
  let t;
  return {
    c() {
      p = element("p");
      t = text(ctx[1]);
      attr(p, "class", "error");
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, t);
    },
    p(ctx2, dirty) {
      if (dirty & 2)
        set_data(t, ctx2[1]);
    },
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
function create_default_slot$2(ctx) {
  let form;
  let div1;
  let label0;
  let t1;
  let div0;
  let input0;
  let t2;
  let div3;
  let label1;
  let t4;
  let div2;
  let input1;
  let t5;
  let span;
  let t9;
  let mounted;
  let dispose;
  let if_block = ctx[1] && create_if_block_1$5(ctx);
  return {
    c() {
      form = element("form");
      div1 = element("div");
      label0 = element("label");
      label0.textContent = "Name";
      t1 = space();
      div0 = element("div");
      input0 = element("input");
      t2 = space();
      div3 = element("div");
      label1 = element("label");
      label1.textContent = "Proxy";
      t4 = space();
      div2 = element("div");
      input1 = element("input");
      t5 = space();
      span = element("span");
      span.innerHTML = `Add a proxy that authenticates using username and password. <br/> 
          Format: username:password@address:port<br/>
          Example: alpha:bravo@my-proxy-host:9000`;
      t9 = space();
      if (if_block)
        if_block.c();
      attr(label0, "for", "name");
      attr(label0, "class", "col-sm-3 col-form-label svelte-va63su");
      attr(input0, "id", "name");
      attr(input0, "type", "text");
      attr(input0, "class", "form-control");
      attr(input0, "placeholder", "A name to identify proxies from dropdowns");
      attr(div0, "class", "col-sm-9");
      attr(div1, "class", "form-group row");
      attr(label1, "for", "proxylist");
      attr(label1, "class", "col-sm-3 col-form-label svelte-va63su");
      attr(input1, "type", "text");
      attr(input1, "class", "form-control");
      attr(input1, "rows", "4");
      attr(span, "class", "help");
      attr(div2, "class", "col-sm-9");
      attr(div3, "class", "form-group row");
    },
    m(target, anchor) {
      insert(target, form, anchor);
      append(form, div1);
      append(div1, label0);
      append(div1, t1);
      append(div1, div0);
      append(div0, input0);
      set_input_value(input0, ctx[0].name);
      append(form, t2);
      append(form, div3);
      append(div3, label1);
      append(div3, t4);
      append(div3, div2);
      append(div2, input1);
      set_input_value(input1, ctx[0].gateway);
      append(div2, t5);
      append(div2, span);
      append(form, t9);
      if (if_block)
        if_block.m(form, null);
      if (!mounted) {
        dispose = [
          listen(input0, "input", ctx[5]),
          listen(input1, "input", ctx[6])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1 && input0.value !== ctx2[0].name) {
        set_input_value(input0, ctx2[0].name);
      }
      if (dirty & 1 && input1.value !== ctx2[0].gateway) {
        set_input_value(input1, ctx2[0].gateway);
      }
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1$5(ctx2);
          if_block.c();
          if_block.m(form, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching)
        detach(form);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_else_block$8(ctx) {
  let t;
  return {
    c() {
      t = text("Edit Proxy");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block$9(ctx) {
  let t;
  return {
    c() {
      t = text("Add New Proxy");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_header_slot(ctx) {
  let span;
  function select_block_type(ctx2, dirty) {
    if (ctx2[2])
      return create_if_block$9;
    return create_else_block$8;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      span = element("span");
      if_block.c();
      attr(span, "slot", "header");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      if_block.m(span, null);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(span);
      if_block.d();
    }
  };
}
function create_buttons_slot(ctx) {
  let span;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      span = element("span");
      button = element("button");
      button.textContent = "Save";
      attr(button, "class", "btn btn-primary");
      attr(span, "slot", "buttons");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, button);
      if (!mounted) {
        dispose = listen(button, "click", ctx[4]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(span);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$b(ctx) {
  let modal;
  let current;
  modal = new Modal$2({
    props: {
      $$slots: {
        buttons: [create_buttons_slot],
        header: [create_header_slot],
        default: [create_default_slot$2]
      },
      $$scope: { ctx }
    }
  });
  modal.$on("close", ctx[3]);
  modal.$on("submit", ctx[4]);
  return {
    c() {
      create_component(modal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modal_changes = {};
      if (dirty & 515) {
        modal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal.$set(modal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal, detaching);
    }
  };
}
function instance$b($$self, $$props, $$invalidate) {
  let { proxy } = $$props;
  const dispatch = createEventDispatcher();
  const store2 = getContext$1("store");
  let errMsg = "";
  let isNew = !proxy.id;
  function close() {
    dispatch("close");
  }
  async function handleEdit() {
    let gateway = proxy.gateway;
    $$invalidate(1, errMsg = "");
    if (/https*:\/\//.test(gateway)) {
      gateway = gateway.slice(gateway.indexOf(":") + 3);
    }
    try {
      let url = new URL("http://" + gateway);
      if (!url.username || !url.password) {
        throw new Error("Missing username or password");
      }
    } catch (e) {
      $$invalidate(1, errMsg = `Invalid proxy ${gateway} at line #${i + 1} (${e.message})`);
      return;
    }
    try {
      if (isNew) {
        await store2.add({ ...proxy, gateway });
      } else {
        await store2.patch({ ...proxy, gateway });
      }
      close();
    } catch (err) {
      $$invalidate(1, errMsg = err.message);
    }
  }
  function input0_input_handler() {
    proxy.name = this.value;
    $$invalidate(0, proxy);
  }
  function input1_input_handler() {
    proxy.gateway = this.value;
    $$invalidate(0, proxy);
  }
  $$self.$$set = ($$props2) => {
    if ("proxy" in $$props2)
      $$invalidate(0, proxy = $$props2.proxy);
  };
  return [
    proxy,
    errMsg,
    isNew,
    close,
    handleEdit,
    input0_input_handler,
    input1_input_handler
  ];
}
class EditProxy extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$b, create_fragment$b, safe_not_equal, { proxy: 0 });
  }
}
function get_each_context$2(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i2];
  child_ctx[8] = i2;
  return child_ctx;
}
function create_else_block$7(ctx) {
  let tr;
  return {
    c() {
      tr = element("tr");
      tr.innerHTML = `<td colspan="4">Click the add button to add your own proxies and use them for checks in cloud.</td>`;
    },
    m(target, anchor) {
      insert(target, tr, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(tr);
    }
  };
}
function create_if_block$8(ctx) {
  let tr;
  let td0;
  let t0_value = ctx[6].name + "";
  let t0;
  let t1;
  let td1;
  let t2_value = ctx[6].description + "";
  let t2;
  let t3;
  let td2;
  let div;
  let t4_value = ctx[6].gateway + "";
  let t4;
  let t5;
  let td3;
  let t7;
  let td4;
  let button1;
  let mounted;
  let dispose;
  function click_handler2(...args) {
    return ctx[3](ctx[6], ...args);
  }
  function click_handler_1(...args) {
    return ctx[4](ctx[6], ...args);
  }
  return {
    c() {
      tr = element("tr");
      td0 = element("td");
      t0 = text(t0_value);
      t1 = space();
      td1 = element("td");
      t2 = text(t2_value);
      t3 = space();
      td2 = element("td");
      div = element("div");
      t4 = text(t4_value);
      t5 = space();
      td3 = element("td");
      td3.innerHTML = `<button class="btn btn-default btn-xs btn-slim">Edit</button>`;
      t7 = space();
      td4 = element("td");
      button1 = element("button");
      button1.textContent = "Delete";
      set_style(div, "max-height", "200px");
      set_style(div, "overflow", "hidden");
      attr(button1, "class", "btn btn-danger btn-xs btn-slim");
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td0);
      append(td0, t0);
      append(tr, t1);
      append(tr, td1);
      append(td1, t2);
      append(tr, t3);
      append(tr, td2);
      append(td2, div);
      append(div, t4);
      append(tr, t5);
      append(tr, td3);
      append(tr, t7);
      append(tr, td4);
      append(td4, button1);
      if (!mounted) {
        dispose = [
          listen(td3, "click", click_handler2),
          listen(button1, "click", click_handler_1)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 1 && t0_value !== (t0_value = ctx[6].name + ""))
        set_data(t0, t0_value);
      if (dirty & 1 && t2_value !== (t2_value = ctx[6].description + ""))
        set_data(t2, t2_value);
      if (dirty & 1 && t4_value !== (t4_value = ctx[6].gateway + ""))
        set_data(t4, t4_value);
    },
    d(detaching) {
      if (detaching)
        detach(tr);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_each_block$2(key_1, ctx) {
  let first;
  let if_block_anchor;
  let if_block = ctx[6].state == 40 && create_if_block$8(ctx);
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (ctx[6].state == 40) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block$8(ctx);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching)
        detach(first);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment$a(ctx) {
  let div2;
  let div1;
  let t1;
  let table;
  let thead;
  let t9;
  let tbody;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t10;
  let tr1;
  let td;
  let button;
  let t12;
  let p;
  let mounted;
  let dispose;
  let each_value = ctx[0];
  const get_key = (ctx2) => ctx2[6].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$2(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$2(key, child_ctx));
  }
  let each_1_else = null;
  if (!each_value.length) {
    each_1_else = create_else_block$7();
  }
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      div1.innerHTML = `<div style="flex: 1"><h3>My Proxies (beta)</h3></div>`;
      t1 = space();
      table = element("table");
      thead = element("thead");
      thead.innerHTML = `<tr><th class="col-name">Name</th> 
        <th class="col-desc">Description</th> 
        <th class="col-gateway">Proxy</th> 
        <th class="col-edit"></th> 
        <th class="col-del"></th></tr>`;
      t9 = space();
      tbody = element("tbody");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      if (each_1_else) {
        each_1_else.c();
      }
      t10 = space();
      tr1 = element("tr");
      td = element("td");
      button = element("button");
      button.textContent = "Add New Proxy";
      t12 = space();
      p = element("p");
      p.textContent = "Custom proxies are available in Flexi in Enterprise plans";
      attr(div1, "class", "panel-heading flex items-center");
      attr(button, "class", "btn btn-primary");
      attr(p, "class", "help");
      attr(td, "colspan", "5");
      attr(table, "class", "table");
      attr(div2, "class", "panel panel-default");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div2, t1);
      append(div2, table);
      append(table, thead);
      append(table, t9);
      append(table, tbody);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(tbody, null);
      }
      if (each_1_else) {
        each_1_else.m(tbody, null);
      }
      append(tbody, t10);
      append(tbody, tr1);
      append(tr1, td);
      append(td, button);
      append(td, t12);
      append(td, p);
      if (!mounted) {
        dispose = listen(button, "click", ctx[5]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 7) {
        each_value = ctx2[0];
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, tbody, destroy_block, create_each_block$2, t10, get_each_context$2);
        if (!each_value.length && each_1_else) {
          each_1_else.p(ctx2, dirty);
        } else if (!each_value.length) {
          each_1_else = create_else_block$7();
          each_1_else.c();
          each_1_else.m(tbody, t10);
        } else if (each_1_else) {
          each_1_else.d(1);
          each_1_else = null;
        }
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div2);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      if (each_1_else)
        each_1_else.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$a($$self, $$props, $$invalidate) {
  let { proxies } = $$props;
  let { onDelete } = $$props;
  let { onEdit } = $$props;
  const click_handler2 = (proxy, e) => onEdit(proxy);
  const click_handler_1 = (proxy, e) => onDelete(proxy.id);
  const click_handler_2 = (e) => onEdit({
    name: "New Proxy Name",
    gateway: "",
    description: ""
  });
  $$self.$$set = ($$props2) => {
    if ("proxies" in $$props2)
      $$invalidate(0, proxies = $$props2.proxies);
    if ("onDelete" in $$props2)
      $$invalidate(1, onDelete = $$props2.onDelete);
    if ("onEdit" in $$props2)
      $$invalidate(2, onEdit = $$props2.onEdit);
  };
  return [proxies, onDelete, onEdit, click_handler2, click_handler_1, click_handler_2];
}
class List$2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$a, create_fragment$a, safe_not_equal, { proxies: 0, onDelete: 1, onEdit: 2 });
  }
}
function get_each_context$1(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[1] = list[i2];
  child_ctx[3] = i2;
  return child_ctx;
}
function create_else_block_1(ctx) {
  let tr;
  return {
    c() {
      tr = element("tr");
      tr.innerHTML = `<td colspan="3">We are adding proxies to the inventory. Check back soon to view updated list.</td>`;
    },
    m(target, anchor) {
      insert(target, tr, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(tr);
    }
  };
}
function create_else_block$6(ctx) {
  let t;
  return {
    c() {
      t = text("Available");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block$7(ctx) {
  let t_value = ctx[1].msgUpgrade + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[1].msgUpgrade + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_each_block$1(key_1, ctx) {
  let tr;
  let td0;
  let t0_value = ctx[1].name + "";
  let t0;
  let t1;
  let td1;
  let t2_value = (ctx[1].cost || 2) + "";
  let t2;
  let t3;
  let td2;
  let t4_value = ctx[1].description + "";
  let t4;
  let t5;
  let td3;
  function select_block_type(ctx2, dirty) {
    if (ctx2[1].msgUpgrade)
      return create_if_block$7;
    return create_else_block$6;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    key: key_1,
    first: null,
    c() {
      tr = element("tr");
      td0 = element("td");
      t0 = text(t0_value);
      t1 = space();
      td1 = element("td");
      t2 = text(t2_value);
      t3 = space();
      td2 = element("td");
      t4 = text(t4_value);
      t5 = space();
      td3 = element("td");
      if_block.c();
      this.first = tr;
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td0);
      append(td0, t0);
      append(tr, t1);
      append(tr, td1);
      append(td1, t2);
      append(tr, t3);
      append(tr, td2);
      append(td2, t4);
      append(tr, t5);
      append(tr, td3);
      if_block.m(td3, null);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 1 && t0_value !== (t0_value = ctx[1].name + ""))
        set_data(t0, t0_value);
      if (dirty & 1 && t2_value !== (t2_value = (ctx[1].cost || 2) + ""))
        set_data(t2, t2_value);
      if (dirty & 1 && t4_value !== (t4_value = ctx[1].description + ""))
        set_data(t4, t4_value);
      if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
        if_block.p(ctx, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx);
        if (if_block) {
          if_block.c();
          if_block.m(td3, null);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(tr);
      if_block.d();
    }
  };
}
function create_fragment$9(ctx) {
  let div2;
  let div1;
  let t3;
  let table;
  let thead;
  let t11;
  let tbody;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t12;
  let tr1;
  let each_value = ctx[0];
  const get_key = (ctx2) => ctx2[1].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$1(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$1(key, child_ctx));
  }
  let each_1_else = null;
  if (!each_value.length) {
    each_1_else = create_else_block_1();
  }
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      div1.innerHTML = `<div style="flex: 1"><h3>Managed Proxies</h3> 
      <small>Distill provided premium proxies available for checks in cloud.</small></div>`;
      t3 = space();
      table = element("table");
      thead = element("thead");
      thead.innerHTML = `<tr><th width="200">Name</th> 
        <th width="100">Cost*</th> 
        <th>Description</th> 
        <th width="200">Availability</th></tr>`;
      t11 = space();
      tbody = element("tbody");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      if (each_1_else) {
        each_1_else.c();
      }
      t12 = space();
      tr1 = element("tr");
      tr1.innerHTML = `<td colspan="4">*The cost of using a proxy is accounted as checks in the account. If a proxy&#39;s cost is N, 1 check using that proxy will be counted as N checks.</td>`;
      attr(div1, "class", "panel-heading flex items-center");
      attr(table, "class", "table");
      attr(div2, "class", "panel panel-default");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div2, t3);
      append(div2, table);
      append(table, thead);
      append(table, t11);
      append(table, tbody);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(tbody, null);
      }
      if (each_1_else) {
        each_1_else.m(tbody, null);
      }
      append(tbody, t12);
      append(tbody, tr1);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        each_value = ctx2[0];
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, tbody, destroy_block, create_each_block$1, t12, get_each_context$1);
        if (!each_value.length && each_1_else) {
          each_1_else.p(ctx2, dirty);
        } else if (!each_value.length) {
          each_1_else = create_else_block_1();
          each_1_else.c();
          each_1_else.m(tbody, t12);
        } else if (each_1_else) {
          each_1_else.d(1);
          each_1_else = null;
        }
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div2);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      if (each_1_else)
        each_1_else.d();
    }
  };
}
function instance$9($$self, $$props, $$invalidate) {
  let { proxies } = $$props;
  $$self.$$set = ($$props2) => {
    if ("proxies" in $$props2)
      $$invalidate(0, proxies = $$props2.proxies);
  };
  return [proxies];
}
class ListManaged extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$9, create_fragment$9, safe_not_equal, { proxies: 0 });
  }
}
function create_else_block$5(ctx) {
  let list;
  let t;
  let listmanaged;
  let current;
  list = new List$2({
    props: {
      proxies: ctx[1].custom.data,
      onDelete: ctx[5],
      onEdit: ctx[4]
    }
  });
  listmanaged = new ListManaged({
    props: { proxies: ctx[1].global.data }
  });
  return {
    c() {
      create_component(list.$$.fragment);
      t = space();
      create_component(listmanaged.$$.fragment);
    },
    m(target, anchor) {
      mount_component(list, target, anchor);
      insert(target, t, anchor);
      mount_component(listmanaged, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const list_changes = {};
      if (dirty & 2)
        list_changes.proxies = ctx2[1].custom.data;
      list.$set(list_changes);
      const listmanaged_changes = {};
      if (dirty & 2)
        listmanaged_changes.proxies = ctx2[1].global.data;
      listmanaged.$set(listmanaged_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(list.$$.fragment, local);
      transition_in(listmanaged.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(list.$$.fragment, local);
      transition_out(listmanaged.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(list, detaching);
      if (detaching)
        detach(t);
      destroy_component(listmanaged, detaching);
    }
  };
}
function create_if_block_1$4(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "Loading data...";
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block$6(ctx) {
  let modaleditproxy;
  let current;
  modaleditproxy = new EditProxy({
    props: {
      proxy: ctx[0],
      api: ctx[2]
    }
  });
  modaleditproxy.$on("close", ctx[6]);
  return {
    c() {
      create_component(modaleditproxy.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modaleditproxy, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modaleditproxy_changes = {};
      if (dirty & 1)
        modaleditproxy_changes.proxy = ctx2[0];
      modaleditproxy.$set(modaleditproxy_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modaleditproxy.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modaleditproxy.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modaleditproxy, detaching);
    }
  };
}
function create_fragment$8(ctx) {
  let current_block_type_index;
  let if_block0;
  let t;
  let if_block1_anchor;
  let current;
  const if_block_creators = [create_if_block_1$4, create_else_block$5];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[1].loading)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block1 = ctx[0] != null && create_if_block$6(ctx);
  return {
    c() {
      if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, t, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(t.parentNode, t);
      }
      if (ctx2[0] != null) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$6(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(t);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(if_block1_anchor);
    }
  };
}
function instance$8($$self, $$props, $$invalidate) {
  let $store;
  let api = getContext$1("api");
  let store2 = createProxies(api);
  component_subscribe($$self, store2, (value) => $$invalidate(1, $store = value));
  window.store = store2;
  setContext("store", store2);
  let proxy = null;
  onMount(async () => {
    await store2.fetch();
  });
  async function onEdit(_proxy) {
    if ($store.constraint.price < 8e3) {
      alert("Custom proxies are only available in Flexi and higher plans");
      return;
    }
    $$invalidate(0, proxy = _proxy);
  }
  async function onDelete(id2) {
    await store2.del(id2);
  }
  const close_handler = () => $$invalidate(0, proxy = null);
  return [proxy, $store, api, store2, onEdit, onDelete, close_handler];
}
class Proxies extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$8, create_fragment$8, safe_not_equal, {});
  }
}
const Backbone$2 = window.Backbone;
if (!Backbone$2) {
  throw new Error("ADD Backbone");
}
const Model = base.Model;
const Collection$1 = base.Collection;
const InputParam = Model.extend({
  defaults: {
    name: "",
    type: "text"
  }
});
var Tpl = Model.extend({
  encodedFields: ["params", "sieve_config", "sieve_rule"],
  urlRoot: "/tpls/sieves",
  defaults: function() {
    return {
      desc_name: "Search Result",
      desc_uri: "https://www.domain.tld",
      desc_info: "Selection contains search result containing url and snippet. Does not contain ads.",
      sieve_type: C.TYPE_HTML,
      sieve_uri: null,
      sieve_config: {
        selections: [{
          frames: [{
            index: 0,
            excludes: [],
            includes: [{
              type: "css",
              expr: "body"
            }]
          }],
          dynamic: true
        }],
        includeStyle: false,
        dataAttr: "text"
      },
      params: new Collection$1([])
    };
  },
  parse: function(response) {
    var response = Tpl.__super__.parse.call(this, response);
    response.params = new Collection$1(response.params);
    return response;
  }
});
const Tpls = base.PagedCollection.extend({
  model: Tpl,
  url: "/tpls/sieves"
});
var Pattern = Model.extend({
  encodedFields: ["pattern_params"],
  defaults: function() {
    return {
      pattern: null,
      uri_ref: null,
      pattern_params: new Collection$1()
    };
  },
  parse: function(response) {
    var response = Pattern.__super__.parse.call(this, response);
    response.pattern_params = new Collection$1(response.pattern_params);
    return response;
  }
});
const Patterns = Collection$1.extend({
  model: Pattern,
  url: function() {
    return ["/tpls/sieves", this.tpl.id, "patterns"].join("/");
  }
});
var ModelTpl = {
  Pattern,
  Patterns,
  InputParam,
  Tpl,
  Tpls
};
const domo = window.domo;
if (!domo) {
  throw new Error("ADD domo");
}
const $$1 = window.jQuery;
if (!$$1) {
  throw new Error("ADD jQuery");
}
const _$1 = window._;
if (!_$1) {
  throw new Error("ADD _");
}
const async$1 = window.async;
if (!async$1) {
  throw new Error("ADD async");
}
const moment$1 = window.moment;
if (!moment$1) {
  throw new Error("ADD moment");
}
const Backbone$1 = window.Backbone;
if (!Backbone$1) {
  throw new Error("ADD Backbone");
}
function strToRe(str) {
  return str.replace(/[[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
}
function getSearchParams(url) {
  const params2 = {};
  url.searchParams.forEach(function(v, k) {
    params2[k] = v;
  });
  return params2;
}
const Row = View$1.Base.extend({
  name: "SieveTplRow",
  tagName: "li",
  className: "list-group-item",
  onDel: function() {
    this.model.destroy();
  },
  render: function() {
    const attrs = this.model.attributes;
    let btnDel;
    this.$el.empty().attr({
      "data-id": attrs.id
    }).append(DIV(DIV({ style: "float: left" }, btnDel = BUTTON({
      "class": "btn btn-default xbtn-light",
      "title": T("a_del")
    }, I({ "class": "fa fa-trash-o" }))), DIV(DIV(attrs.desc_name), DIV(attrs.desc_uri))));
    btnDel.onclick = this.onDel;
    return this;
  }
});
const Collection = View$1.Collection.extend({
  name: "TplCollection",
  tagName: "ul",
  className: "list-group",
  addOne: function(model) {
    const view = new Row({ model, parent: this });
    this.$el.append(view.render().el);
    return view;
  }
});
const TplList = View$1.ActionProvider.extend({
  postInit: function() {
    if (!App.user.isLoggedIn()) {
      this.view = new Backbone$1.View({ el: DIV("Please sign in to your account and try again") });
    } else {
      this.view = new Collection({
        collection: this.collection = new ModelTpl.Tpls(),
        parent: this
      });
    }
  },
  render: function() {
    this.$el.empty().append(DIV({ "class": "xpage-header" }, H3(T("l_sieve_tpl_list"), " ", SMALL("(beta)"))), this.view.render().el);
    return this;
  },
  showList: function() {
    this.collection && this.collection.fetch({ data: { user_id: USER.id } });
  }
});
const DescEditor = View$1.ActionProvider.extend({
  postInit: function(options) {
    const model = this.model;
    this.fields = {
      name: Editor.create("text", {
        parent: this,
        model,
        param: {
          name: "desc_name",
          help: "h_tpl_desc_name"
        }
      }),
      info: Editor.create("textarea", {
        parent: this,
        model,
        param: {
          name: "desc_info",
          help: "h_desc"
        }
      })
    };
  },
  render: function() {
    const fields = this.fields;
    this.$el.empty().append(_$1.map(["name", "info"], function(key) {
      return DIV({ "class": "form-group" }, LABEL({ "class": "control-label col-md-2" }, T("l_tpl_desc_" + key)), DIV({ "class": "col-md-10" }, fields[key].render().el));
    }));
    return this;
  }
});
const SimpleTplEditor = View$1.ActionProvider.extend({
  name: "SimpleTplEditor",
  actions: {
    "tpl_save": { fn: "action_save" }
  },
  action_save: function(x, el) {
    const self = this;
    const newModel = this.model.clone();
    $$1(el).button("loading");
    newModel.save({
      sieve_config: JSON.parse(this.sieve.config),
      sieve_type: this.sieve.content_type
    }, {
      error: onError,
      success: function(model) {
        Msg.info("Template saved!");
        setTimeout(savePatterns, 0);
      }
    });
    function savePatterns() {
      self.patterns.tpl = newModel;
      async$1.each(self.patterns.models, savePattern, function(err, res2) {
        if (err) {
          onError(err);
        } else {
          onFinish();
        }
      });
    }
    function savePattern(pattern, callback) {
      pattern.save(null, {
        error: function() {
          callback(new Error("Failed to save pattern"));
        },
        success: function() {
          callback();
        }
      });
    }
    function onFinish() {
      $$1(el).button("reset");
      push$1("/w/tpls/all/");
    }
    function onError(err) {
      console.error("Error saving template", err);
      $$1(el).button("reset");
      Msg.error("Failed to save template");
    }
  },
  handleNetworkError: function() {
    let msg = App.user.isLoggedIn() ? "Failed to load data. Please check network connection and try again." : "Please sign in to your account and try again";
    this.$elLoad.addClass("error").text(msg);
  },
  postInit: function(options) {
    const model = this.model;
    this.patterns = new ModelTpl.Patterns();
    this.pattern = new ModelTpl.Pattern();
    this.patterns.add(this.pattern);
    this.views = {
      patternURIEditor: new Editor.create("text", {
        parent: this,
        model: this.pattern,
        param: {
          name: "pattern",
          help: "h_tpl_url_pattern"
        }
      }),
      desc: new DescEditor({ parent: this, model }).render()
    };
    this.$el.addClass("form-horizontal");
    this.$el.empty().append(DIV({ "class": "xpage-header" }, H4(T("Match URL"))), DIV({ "class": "form-group" }, LABEL({ "class": "control-label col-md-2" }, T("l_uri_pattern")), this.elTip = DIV({ "class": "col-md-10 hide" }, this.views.patternURIEditor.render().el), this.elLoad = DIV({ "class": "col-md-10" }, "Loading data...")), DIV({ "class": "form-group" }, LABEL({ "class": "control-label col-md-2" }, T("l_url")), DIV({ "class": "col-md-10" }, this.elURL = DIV())), this.elDesc = DIV({ "class": "hide" }, DIV({ "class": "xpage-header" }, H4(T("l_desc"))), this.views.desc.el, DIV({ "class": "form-group" }, DIV({ "class": "col-md-offset-2 col-md-10 xtbar-form" }, BUTTON({
      "class": "btn btn-primary xbtn-default",
      "data-action": "tpl_save"
    }, T("a_save")), BUTTON({
      "class": "btn btn-default",
      "data-action": "go_back"
    }, T("a_discard"))))));
    this.$elLoad = $$1(this.elLoad);
    this.start();
  },
  setPattern: function(pattern) {
    const sieve = this.sieve;
    new URL(sieve.uri);
    $$1(this.elLoad).remove();
    $$1(this.elTip).removeClass("hide");
    $$1(this.elDesc).removeClass("hide");
    if (!pattern) {
      $$1(this.elTip).find("input").focus();
    } else {
      $$1(this.elDesc).find("input").first().focus();
    }
    this.pattern.set({
      pattern: pattern || strToRe(sieve.uri.split("/").slice(2).join("/")) + "$",
      uri_ref: sieve.uri
    });
    this.model.set({
      desc_name: sieve.name,
      desc_info: "",
      desc_uri: sieve.uri.split("/").slice(0, 3).join("/")
    });
  },
  start: function() {
    const self = this;
    Api.api("/sieves/" + this.options.sieveId, "GET", {}, function(err, sieve) {
      if (err) {
        self.handleNetworkError();
        return;
      }
      self.sieve = sieve;
      const uri = sieve.uri;
      self.$elLoad.text("Finding URL pattern...");
      self.elURL.textContent = uri;
      async$1.parallel({
        sieves: function(callback) {
          const host = new URL(uri).host;
          Api.api("/sieves", "GET", {
            "uri.ne": uri,
            "uri.like": "%" + host + "%",
            "state.in": [40, 45]
          }, callback);
        },
        patterns: function(callback) {
          Api.api("/tpls/patterns/search", "GET", {
            url: uri
          }, callback);
        }
      }, function(err2, result) {
        if (err2) {
          console.error("Failed to fetch data: ", err2);
          self.handleNetworkError();
        } else {
          self.suggestOptions(sieve, result.sieves.data, result.patterns.data);
        }
      });
    });
  },
  suggestOptions: function(sieve, sieves, patterns) {
    const self = this;
    const uri = sieve.uri;
    let suggestedPatterns;
    this.$elLoad.empty();
    if (patterns.length > 0) {
      suggestedPatterns = patterns;
    } else if (sieves.length > 0) {
      suggestedPatterns = this.generatePatterns(uri, sieves);
    }
    if (suggestedPatterns) {
      suggestedPatterns = _$1.uniq(suggestedPatterns, function(sp) {
        return sp.pattern;
      });
      this.$elLoad.append(DIV({ "class": "list-group" }, _$1.map(suggestedPatterns, function(pattern) {
        return A({ "href": "#", "class": "list-group-item" }, DIV(SAMP(pattern.pattern)), SMALL(pattern.uri_ref));
      })), P(), BUTTON({ "class": "btn btn-default" }, "Or, use custom pattern"));
      this.$(".list-group-item").click(".list-group-item", function(e) {
        e.preventDefault();
        self.setPattern($$1(e.currentTarget).find("samp").text());
      });
      this.$elLoad.find("button").click(function() {
        self.setPattern();
      });
    } else {
      this.setPattern();
    }
  },
  generatePatterns: function(uri, sieves) {
    const parts = uri.split("/");
    const url = new URL(uri);
    const pathParts = url.pathname.split("/");
    const searchParams = getSearchParams(url);
    const similarSieves = _$1.filter(sieves, function(sieve) {
      const url2 = new URL(sieve.uri);
      const pathParts2 = url2.pathname.split("/");
      const searchParams2 = getSearchParams(url2);
      return pathParts.length == pathParts2.length && _$1.isEqual(_$1.keys(searchParams), _$1.keys(searchParams2));
    });
    if (similarSieves.length > 0) {
      return _$1.map(similarSieves, function(sieve) {
        const refParts = sieve.uri.split("/");
        const exprParts = _$1.map(parts, function(part, i2) {
          return part === refParts[i2] ? strToRe(part) : part.length > 0 ? "(.*)" : "";
        });
        exprParts[2] = strToRe(parts[2]);
        return {
          pattern: exprParts.slice(2).join("/") + (url.pathname == "/" ? "$" : ""),
          uri_ref: sieve.uri
        };
      });
    }
  }
});
const TplEditor = View$1.ActionProvider.extend({
  name: "TplEditor",
  create: function(sieveId) {
    if (this.view) {
      this.view.remove();
    }
    this.view = new SimpleTplEditor({
      parent: this,
      sieveId,
      model: new ModelTpl.Tpl()
    });
    this.elView.appendChild(this.view.render().el);
  },
  render: function() {
    this.$el.empty().append(DIV({ "class": "xtbar" }, BUTTON({
      "class": "btn btn-default",
      "data-action": "go_back"
    }, I({ "class": "fa fa-chevron-left" }), " ", T("a_discard"))), DIV({ "class": "xpage-header" }, H3(T("l_tpl"), " ", SMALL("Templates help add monitors using preconfigured selections."))), this.elView = DIV());
    return this;
  }
});
var ViewSieveTpls = {
  TplList,
  Editor: TplEditor
};
function create_fragment$7(ctx) {
  let div1;
  let div0;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      ctx[1](div0);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div1);
      ctx[1](null);
    }
  };
}
function instance$7($$self, $$props, $$invalidate) {
  getContext$1("api");
  let parent2 = getContext$1("view:root");
  let el;
  let view;
  onMount(() => {
    view = new ViewSieveTpls.TplList({ el, parent: parent2 }).render();
    view.showList();
    return () => view.remove();
  });
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(0, el);
    });
  }
  return [el, div0_binding];
}
class List$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$7, create_fragment$7, safe_not_equal, {});
  }
}
function create_fragment$6(ctx) {
  let div1;
  let div0;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      ctx[2](div0);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div1);
      ctx[2](null);
    }
  };
}
function instance$6($$self, $$props, $$invalidate) {
  let { route: route2 } = $$props;
  getContext$1("api");
  let parent2 = getContext$1("view:root");
  let el;
  let view;
  onMount(() => {
    view = new ViewSieveTpls.Editor({ el, parent: parent2 }).render();
    view.create(route2.id);
    return () => view.remove();
  });
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(0, el);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("route" in $$props2)
      $$invalidate(1, route2 = $$props2.route);
  };
  return [el, route2, div0_binding];
}
class AddFrom extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$6, create_fragment$6, safe_not_equal, { route: 1 });
  }
}
function create_catch_block$1(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$1(ctx) {
  let current_block_type_index;
  let if_block;
  let t;
  let list;
  let current;
  const if_block_creators = [
    create_if_block$5,
    create_if_block_3$1,
    create_if_block_4$1,
    create_if_block_5$1,
    create_if_block_8,
    create_if_block_9,
    create_if_block_10,
    create_if_block_11,
    create_else_block$4
  ];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0].module == "sieve")
      return 0;
    if (ctx2[0].module == "export")
      return 1;
    if (ctx2[0].module == "import")
      return 2;
    if (ctx2[0].module == "tpls")
      return 3;
    if (ctx2[0].module == "macros")
      return 4;
    if (ctx2[0].module == "profiles")
      return 5;
    if (ctx2[0].module == "proxies")
      return 6;
    if (ctx2[0].module == "list")
      return 7;
    return 8;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  list = new List$5({
    props: {
      route,
      hidden: ctx[0].module != "list"
    }
  });
  return {
    c() {
      if_block.c();
      t = space();
      create_component(list.$$.fragment);
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, t, anchor);
      mount_component(list, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(t.parentNode, t);
      }
      const list_changes = {};
      if (dirty & 1)
        list_changes.hidden = ctx2[0].module != "list";
      list.$set(list_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(list.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(list.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(t);
      destroy_component(list, detaching);
    }
  };
}
function create_else_block$4(ctx) {
  let error404;
  let current;
  error404 = new Error404({ props: { useLayout: false } });
  return {
    c() {
      create_component(error404.$$.fragment);
    },
    m(target, anchor) {
      mount_component(error404, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(error404.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(error404.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(error404, detaching);
    }
  };
}
function create_if_block_11(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_if_block_10(ctx) {
  let proxies;
  let current;
  proxies = new Proxies({});
  return {
    c() {
      create_component(proxies.$$.fragment);
    },
    m(target, anchor) {
      mount_component(proxies, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(proxies.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(proxies.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(proxies, detaching);
    }
  };
}
function create_if_block_9(ctx) {
  let profiles;
  let current;
  profiles = new Profiles({});
  return {
    c() {
      create_component(profiles.$$.fragment);
    },
    m(target, anchor) {
      mount_component(profiles, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(profiles.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(profiles.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(profiles, detaching);
    }
  };
}
function create_if_block_8(ctx) {
  let macros;
  let current;
  macros = new Macros_1({});
  return {
    c() {
      create_component(macros.$$.fragment);
    },
    m(target, anchor) {
      mount_component(macros, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(macros.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(macros.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(macros, detaching);
    }
  };
}
function create_if_block_5$1(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_6$1, create_if_block_7];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (ctx2[0].prefix == "all")
      return 0;
    if (ctx2[0].prefix == "add-from")
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type_2(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_4$1(ctx) {
  let import_1;
  let current;
  import_1 = new Import({ props: { route: ctx[0] } });
  return {
    c() {
      create_component(import_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(import_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const import_1_changes = {};
      if (dirty & 1)
        import_1_changes.route = ctx2[0];
      import_1.$set(import_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(import_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(import_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(import_1, detaching);
    }
  };
}
function create_if_block_3$1(ctx) {
  let export_1;
  let current;
  export_1 = new Export({ props: { route: ctx[0] } });
  return {
    c() {
      create_component(export_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(export_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const export_1_changes = {};
      if (dirty & 1)
        export_1_changes.route = ctx2[0];
      export_1.$set(export_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(export_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(export_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(export_1, detaching);
    }
  };
}
function create_if_block$5(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_1$3, create_if_block_2$2];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[0].prefix == "dup" || ctx2[0].prefix == "add" || ctx2[0].prefix == "edit")
      return 0;
    if (ctx2[0].prefix == "detail")
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type_1(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_7(ctx) {
  let addtplfrom;
  let current;
  addtplfrom = new AddFrom({ props: { route: ctx[0] } });
  return {
    c() {
      create_component(addtplfrom.$$.fragment);
    },
    m(target, anchor) {
      mount_component(addtplfrom, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const addtplfrom_changes = {};
      if (dirty & 1)
        addtplfrom_changes.route = ctx2[0];
      addtplfrom.$set(addtplfrom_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(addtplfrom.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(addtplfrom.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(addtplfrom, detaching);
    }
  };
}
function create_if_block_6$1(ctx) {
  let tpllist;
  let current;
  tpllist = new List$1({});
  return {
    c() {
      create_component(tpllist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tpllist, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(tpllist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tpllist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tpllist, detaching);
    }
  };
}
function create_if_block_2$2(ctx) {
  let detail;
  let current;
  detail = new Detail({ props: { route } });
  return {
    c() {
      create_component(detail.$$.fragment);
    },
    m(target, anchor) {
      mount_component(detail, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(detail.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(detail.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(detail, detaching);
    }
  };
}
function create_if_block_1$3(ctx) {
  let edit;
  let current;
  edit = new Edit({ props: { route: ctx[0] } });
  return {
    c() {
      create_component(edit.$$.fragment);
    },
    m(target, anchor) {
      mount_component(edit, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const edit_changes = {};
      if (dirty & 1)
        edit_changes.route = ctx2[0];
      edit.$set(edit_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(edit.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(edit.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(edit, detaching);
    }
  };
}
function create_pending_block$1(ctx) {
  let t;
  return {
    c() {
      t = text("Loading...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$1(ctx) {
  let await_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$1,
    then: create_then_block$1,
    catch: create_catch_block$1,
    blocks: [, , ,]
  };
  handle_promise(ctx[2], info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function create_fragment$5(ctx) {
  let layout;
  let current;
  layout = new WatchListLayout({
    props: {
      renderDefaultToolbar: ctx[0].module !== "list",
      contentScrollTop: ctx[1],
      $$slots: { default: [create_default_slot$1] },
      $$scope: { ctx }
    }
  });
  layout.$on("scroll", ctx[3]);
  return {
    c() {
      create_component(layout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(layout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const layout_changes = {};
      if (dirty & 1)
        layout_changes.renderDefaultToolbar = ctx2[0].module !== "list";
      if (dirty & 2)
        layout_changes.contentScrollTop = ctx2[1];
      if (dirty & 131073) {
        layout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layout.$set(layout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(layout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(layout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(layout, detaching);
    }
  };
}
function matchRoute(rParam, path) {
  let i2 = 0, params2 = {};
  let matches = rParam.pattern.exec(path);
  while (i2 < rParam.keys.length) {
    params2[rParam.keys[i2]] = matches[++i2] || null;
  }
  return params2;
}
function instance$5($$self, $$props, $$invalidate) {
  let $route;
  let $querystring;
  component_subscribe($$self, route, ($$value) => $$invalidate(0, $route = $$value));
  component_subscribe($$self, querystring, ($$value) => $$invalidate(7, $querystring = $$value));
  let { params: params2 = {} } = $$props;
  let contentScrollTop = 0;
  let lastListScrollTop = 0;
  const user = getContext$1("user");
  const labels = getContext$1("labels");
  const clients = new ModelClient.Clients(user.clients);
  clients.defaultId = getContext$1("clientId");
  const sieves = new Model$2.Sieves(null, {
    comparator(model) {
      return -new Date(model.get("ts_data"));
    }
  });
  setContext("clients", clients);
  setContext("watchlist:stores", { clients, sieves });
  set_store_value(route, $route.team = "0", $route);
  const initPromise = fetchAll();
  setTimeout(() => {
    if (Supports.agents.local) {
      clientMsgs.fetch();
    }
    if (user.isLoggedIn()) {
      userMsgs.fetch({ data: { ts_viewed: "$null" } });
    }
  }, 2e3);
  window.App.clients = clients;
  window.App.sieves = sieves;
  const routes = [":data.d/:id.id", ":data.d/", ":id.id", ""];
  const rParams = routes.map(parse$2);
  onParamsChange(params2);
  function onParamsChange(params3) {
    if (params3.prefix == "error") {
      if (Supports.agents.local) {
        serviceProxy.ErrorActions.clearErrorUnreadList();
      }
    }
    let { prefix, wild } = params3;
    if (wild) {
      let path = "/" + wild;
      for (let rp of rParams) {
        if (rp.pattern.test(path)) {
          params3 = { ...params3, ...matchRoute(rp, path) };
          break;
        }
      }
    }
    params3.query = lib.parse($querystring);
    let oldModule = $route.module;
    let newModule = params3.module;
    let oldTeam = $route.team;
    let newTeam = params3.team;
    if (oldTeam != newTeam) {
      Api.setIdentityId(newTeam == 0 ? null : newTeam);
      fetchAll();
    }
    route.set(params3);
    if (oldModule != newModule) {
      if (oldModule == "list") {
        $$invalidate(1, contentScrollTop = lastListScrollTop);
      } else if (newModule == "list") {
        $$invalidate(1, contentScrollTop += 1);
      }
    }
  }
  function onScroll(e) {
    $route.module == "list" && (lastListScrollTop = e.target.scrollTop);
  }
  instance$1Q.on("clients", fetchClients);
  instance$1Q.on("open", fetchAll);
  instance$1Q.on("tags", fetchLabels);
  onDestroy(() => {
    instance$1Q.off("clients", fetchClients);
    instance$1Q.off("open", fetchAll);
    instance$1Q.off("tags", fetchLabels);
  });
  async function fetchClients() {
    await clients.fetch();
  }
  async function fetchAll() {
    await Promise.all([fetchClients(), labels.fetch()]);
  }
  async function fetchLabels() {
    await labels.fetch();
  }
  $$self.$$set = ($$props2) => {
    if ("params" in $$props2)
      $$invalidate(4, params2 = $$props2.params);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      {
        window.App.route = $route;
      }
    }
    if ($$self.$$.dirty & 16) {
      {
        onParamsChange(params2);
      }
    }
  };
  return [$route, contentScrollTop, initPromise, onScroll, params2];
}
class Watchlist extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$5, create_fragment$5, safe_not_equal, { params: 4 });
  }
}
function create_if_block$4(ctx) {
  let div8;
  let div0;
  let t1;
  let div7;
  let div6;
  let div1;
  let label0;
  let t3;
  let span0;
  let t4_value = (ctx[0].get("err").code || "NA") + "";
  let t4;
  let t5;
  let div2;
  let label1;
  let t7;
  let span1;
  let t8_value = (ctx[0].get("err").msg || ctx[0].get("err").message || JSON.stringify(ctx[0].get("err"))) + "";
  let t8;
  let t9;
  let div5;
  let strong0;
  let t11;
  let show_if;
  let show_if_1;
  let show_if_2;
  let show_if_3;
  let show_if_4;
  let t12;
  let div4;
  function select_block_type(ctx2, dirty) {
    if (dirty & 1)
      show_if = null;
    if (dirty & 1)
      show_if_1 = null;
    if (dirty & 1)
      show_if_2 = null;
    if (dirty & 1)
      show_if_3 = null;
    if (dirty & 1)
      show_if_4 = null;
    if (show_if == null)
      show_if = !!(ctx2[0].get("err").code === "SELECTION_EMPTY");
    if (show_if)
      return create_if_block_1$2;
    if (show_if_1 == null)
      show_if_1 = !!(ctx2[0].get("err").code === "EPROXY");
    if (show_if_1)
      return create_if_block_2$1;
    if (show_if_2 == null)
      show_if_2 = !!(ctx2[0].get("err").code === "EMACRO");
    if (show_if_2)
      return create_if_block_3;
    if (show_if_3 == null)
      show_if_3 = !!(ctx2[0].get("err").code === "TIMEOUT" || ctx2[0].get("err").code === "ENOTFOUND" || ctx2[0].get("err").code === "EREQUEST" || ctx2[0].get("err").code === "ETIMEDOUT" || ctx2[0].get("err").code === "ECONNREFUSED");
    if (show_if_3)
      return create_if_block_4;
    if (show_if_4 == null)
      show_if_4 = !!(ctx2[0].get("err").code === "JAVASCRIPT");
    if (show_if_4)
      return create_if_block_5;
    return create_else_block$3;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div8 = element("div");
      div0 = element("div");
      div0.innerHTML = `<h3 class="panel-title">Error Details</h3>`;
      t1 = space();
      div7 = element("div");
      div6 = element("div");
      div1 = element("div");
      label0 = element("label");
      label0.textContent = "Code:";
      t3 = space();
      span0 = element("span");
      t4 = text(t4_value);
      t5 = space();
      div2 = element("div");
      label1 = element("label");
      label1.textContent = "Msg:";
      t7 = space();
      span1 = element("span");
      t8 = text(t8_value);
      t9 = space();
      div5 = element("div");
      strong0 = element("strong");
      strong0.textContent = "Recommended Actions";
      t11 = space();
      if_block.c();
      t12 = space();
      div4 = element("div");
      div4.innerHTML = `<strong>Need Help?</strong> 
            <div>Contact us at support@distill.io</div>`;
      attr(div0, "class", "panel-heading");
      attr(div4, "class", "pt1");
      attr(div5, "class", "pt1");
      attr(div6, "data-id", "error");
      attr(div7, "class", "panel-body overflow-scroll");
      attr(div8, "class", "panel panel-danger");
    },
    m(target, anchor) {
      insert(target, div8, anchor);
      append(div8, div0);
      append(div8, t1);
      append(div8, div7);
      append(div7, div6);
      append(div6, div1);
      append(div1, label0);
      append(div1, t3);
      append(div1, span0);
      append(span0, t4);
      append(div6, t5);
      append(div6, div2);
      append(div2, label1);
      append(div2, t7);
      append(div2, span1);
      append(span1, t8);
      append(div6, t9);
      append(div6, div5);
      append(div5, strong0);
      append(div5, t11);
      if_block.m(div5, null);
      append(div5, t12);
      append(div5, div4);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t4_value !== (t4_value = (ctx2[0].get("err").code || "NA") + ""))
        set_data(t4, t4_value);
      if (dirty & 1 && t8_value !== (t8_value = (ctx2[0].get("err").msg || ctx2[0].get("err").message || JSON.stringify(ctx2[0].get("err"))) + ""))
        set_data(t8, t8_value);
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div5, t12);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(div8);
      if_block.d();
    }
  };
}
function create_else_block$3(ctx) {
  let show_if = ctx[0].get("err").status === 0;
  let t0;
  let div;
  let if_block = show_if && create_if_block_6();
  return {
    c() {
      if (if_block)
        if_block.c();
      t0 = space();
      div = element("div");
      div.textContent = "There is no information about this error.";
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t0, anchor);
      insert(target, div, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1)
        show_if = ctx2[0].get("err").status === 0;
      if (show_if) {
        if (if_block)
          ;
        else {
          if_block = create_if_block_6();
          if_block.c();
          if_block.m(t0.parentNode, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_5(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "Ensure that JavaScript is working in the page.";
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_4(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "Please ensure that the webpage is accessible.";
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_3(ctx) {
  let div;
  let t0_value = (prepareEMacroErrorMessage(ctx[0]) || "") + "";
  let t0;
  let t1;
  let a;
  let t3;
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      a = element("a");
      a.textContent = "Macro: Record and Replay Automated Actions";
      t3 = text(".");
      attr(a, "href", "https://distill.io/docs/web-monitor/macro-to-record-replay-actions/");
      attr(div, "class", "");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      append(div, a);
      append(div, t3);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t0_value !== (t0_value = (prepareEMacroErrorMessage(ctx2[0]) || "") + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_2$1(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.innerHTML = `Please consider using a different proxy:

                <a href="https://distill.io/docs/web-monitor/monitor-webpage-using-proxy-servers/">Using proxy servers for checks</a>.`;
      attr(div, "class", "");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_1$2(ctx) {
  let ul;
  return {
    c() {
      ul = element("ul");
      ul.innerHTML = `<li>Ensure that selected elements has text content.</li> 
              <li>If website needs login, make sure that you are logged in.</li>`;
      attr(ul, "class", "pl3");
    },
    m(target, anchor) {
      insert(target, ul, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(ul);
    }
  };
}
function create_if_block_6(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "Ensure that internet connection is working.";
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$4(ctx) {
  let show_if = ctx[0].get("err");
  let if_block_anchor;
  let if_block = show_if && create_if_block$4(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1)
        show_if = ctx2[0].get("err");
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$4(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function prepareEMacroErrorMessage(workStore) {
  if (workStore.get("err").code !== "EMACRO") {
    return;
  }
  if (!workStore.get("err").step) {
    return;
  }
  const stepType = workStore.get("err").step;
  switch (stepType.type) {
    case "KEYPRESS": {
      return "KEYPRESS is not supported in this device type. Please use a supported device for this monitor and retry";
    }
  }
}
function instance$4($$self, $$props, $$invalidate) {
  let { workStore } = $$props;
  $$self.$$set = ($$props2) => {
    if ("workStore" in $$props2)
      $$invalidate(0, workStore = $$props2.workStore);
  };
  return [workStore];
}
class Error$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4, create_fragment$4, safe_not_equal, { workStore: 0 });
  }
}
function create_else_block$2(ctx) {
  let i2;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", "fa fa-check green");
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(i2);
    }
  };
}
function create_if_block_2(ctx) {
  let i2;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", "fa fa-2x fa-times-circle red");
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(i2);
    }
  };
}
function create_if_block_1$1(ctx) {
  let p;
  return {
    c() {
      p = element("p");
      p.textContent = `${T("l_no_snapshot_found")}`;
      attr(p, "class", "pa2");
    },
    m(target, anchor) {
      insert(target, p, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
function create_if_block$3(ctx) {
  let loader;
  let current;
  loader = new Loader({
    props: { classes: "absolute z-1 ma0 mr2" }
  });
  return {
    c() {
      create_component(loader.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
    }
  };
}
function create_fragment$3(ctx) {
  let title_value;
  let t0;
  let div13;
  let div10;
  let div9;
  let div8;
  let div0;
  let t1;
  let div7;
  let div2;
  let div1;
  let h2;
  let span0;
  let t2_value = new Date(ctx[0].get("ts")).toDateString() + "";
  let t2;
  let t3;
  let span1;
  let t4_value = new Date(ctx[0].get("ts")).toLocaleTimeString() + "";
  let t4;
  let t5;
  let t6_value = T("l_snapshot") + "";
  let t6;
  let t7;
  let div6;
  let div5;
  let div3;
  let label0;
  let t10;
  let span2;
  let t11_value = ctx[0].get("duration") + "";
  let t11;
  let t12;
  let t13_value = ctx[0].get("duration") > 1 ? "seconds" : "second";
  let t13;
  let t14;
  let div4;
  let label1;
  let t17;
  let a;
  let span3;
  let t18_value = ctx[2].uri + "";
  let t18;
  let a_href_value;
  let t19;
  let div12;
  let div11;
  let current_block_type_index;
  let if_block1;
  let t20;
  let iframe;
  let iframe_title_value;
  let current;
  document.title = title_value = ctx[1].get("name") + " | Check Logs";
  function select_block_type(ctx2, dirty) {
    if (ctx2[2].err)
      return create_if_block_2;
    return create_else_block$2;
  }
  let current_block_type = select_block_type(ctx);
  let if_block0 = current_block_type(ctx);
  const if_block_creators = [create_if_block$3, create_if_block_1$1];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[2].fetchingSnapshot || ctx2[5])
      return 0;
    if (!ctx2[2]["snapshot_id"])
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type_1(ctx))) {
    if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      t0 = space();
      div13 = element("div");
      div10 = element("div");
      div9 = element("div");
      div8 = element("div");
      div0 = element("div");
      if_block0.c();
      t1 = space();
      div7 = element("div");
      div2 = element("div");
      div1 = element("div");
      h2 = element("h2");
      span0 = element("span");
      t2 = text(t2_value);
      t3 = space();
      span1 = element("span");
      t4 = text(t4_value);
      t5 = text("\n                | ");
      t6 = text(t6_value);
      t7 = space();
      div6 = element("div");
      div5 = element("div");
      div3 = element("div");
      label0 = element("label");
      label0.textContent = `${T("l_duration")}:`;
      t10 = space();
      span2 = element("span");
      t11 = text(t11_value);
      t12 = space();
      t13 = text(t13_value);
      t14 = space();
      div4 = element("div");
      label1 = element("label");
      label1.textContent = `${T("l_url")}:`;
      t17 = space();
      a = element("a");
      span3 = element("span");
      t18 = text(t18_value);
      t19 = space();
      div12 = element("div");
      div11 = element("div");
      if (if_block1)
        if_block1.c();
      t20 = space();
      iframe = element("iframe");
      attr(div0, "class", "mr1 mw2");
      attr(h2, "class", "panel-title f3");
      attr(div2, "class", "flex");
      attr(div3, "data-id", "duration");
      attr(a, "href", a_href_value = ctx[2].uri);
      attr(a, "target", "_blank");
      attr(a, "class", "truncate");
      attr(div4, "data-id", "links");
      attr(div4, "class", "ml3");
      attr(div5, "class", "flex");
      attr(div6, "class", "f4 pt1");
      attr(div7, "class", "ml2");
      attr(div8, "class", "flex");
      set_style(div8, "align-items", "center");
      attr(div9, "class", "mt3");
      attr(div10, "class", "panel-heading");
      attr(iframe, "frameborder", "none");
      attr(iframe, "class", "flex-grow-1");
      set_style(iframe, "height", "calc(100vh - " + ctx[4] + "px)");
      attr(iframe, "title", iframe_title_value = "Iframe for " + ctx[1].get("name"));
      attr(div11, "data-id", "snapshot");
      attr(div11, "class", "flex flex-column relative");
      attr(div12, "class", "panel-body pa0");
      attr(div13, "class", "panel mb0 panel-default");
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, div13, anchor);
      append(div13, div10);
      append(div10, div9);
      append(div9, div8);
      append(div8, div0);
      if_block0.m(div0, null);
      append(div8, t1);
      append(div8, div7);
      append(div7, div2);
      append(div2, div1);
      append(div1, h2);
      append(h2, span0);
      append(span0, t2);
      append(h2, t3);
      append(h2, span1);
      append(span1, t4);
      append(h2, t5);
      append(h2, t6);
      append(div7, t7);
      append(div7, div6);
      append(div6, div5);
      append(div5, div3);
      append(div3, label0);
      append(div3, t10);
      append(div3, span2);
      append(span2, t11);
      append(span2, t12);
      append(span2, t13);
      append(div5, t14);
      append(div5, div4);
      append(div4, label1);
      append(div4, t17);
      append(div4, a);
      append(a, span3);
      append(span3, t18);
      append(div13, t19);
      append(div13, div12);
      append(div12, div11);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div11, null);
      }
      append(div11, t20);
      append(div11, iframe);
      ctx[7](iframe);
      current = true;
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & 2) && title_value !== (title_value = ctx2[1].get("name") + " | Check Logs")) {
        document.title = title_value;
      }
      if (current_block_type !== (current_block_type = select_block_type(ctx2))) {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(div0, null);
        }
      }
      if ((!current || dirty & 1) && t2_value !== (t2_value = new Date(ctx2[0].get("ts")).toDateString() + ""))
        set_data(t2, t2_value);
      if ((!current || dirty & 1) && t4_value !== (t4_value = new Date(ctx2[0].get("ts")).toLocaleTimeString() + ""))
        set_data(t4, t4_value);
      if ((!current || dirty & 1) && t11_value !== (t11_value = ctx2[0].get("duration") + ""))
        set_data(t11, t11_value);
      if ((!current || dirty & 1) && t13_value !== (t13_value = ctx2[0].get("duration") > 1 ? "seconds" : "second"))
        set_data(t13, t13_value);
      if ((!current || dirty & 4) && t18_value !== (t18_value = ctx2[2].uri + ""))
        set_data(t18, t18_value);
      if (!current || dirty & 4 && a_href_value !== (a_href_value = ctx2[2].uri)) {
        attr(a, "href", a_href_value);
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block1) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block1 = if_blocks[current_block_type_index];
          if (!if_block1) {
            if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block1.c();
          } else {
            if_block1.p(ctx2, dirty);
          }
          transition_in(if_block1, 1);
          if_block1.m(div11, t20);
        } else {
          if_block1 = null;
        }
      }
      if (!current || dirty & 16) {
        set_style(iframe, "height", "calc(100vh - " + ctx2[4] + "px)");
      }
      if (!current || dirty & 2 && iframe_title_value !== (iframe_title_value = "Iframe for " + ctx2[1].get("name"))) {
        attr(iframe, "title", iframe_title_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div13);
      if_block0.d();
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      ctx[7](null);
    }
  };
}
function instance$3($$self, $$props, $$invalidate) {
  let $workStore, $$unsubscribe_workStore = noop, $$subscribe_workStore = () => ($$unsubscribe_workStore(), $$unsubscribe_workStore = subscribe(workStore, ($$value) => $$invalidate(2, $workStore = $$value)), workStore);
  $$self.$$.on_destroy.push(() => $$unsubscribe_workStore());
  let { workStore } = $$props;
  $$subscribe_workStore();
  let { sieveStore } = $$props;
  let workID = workStore.id;
  let iframeElement;
  let iframeTop = 0;
  let loadingSrcDoc = false;
  async function loadSrcDoc() {
    $$invalidate(5, loadingSrcDoc = true);
    $$invalidate(3, iframeElement.src = "about:blank", iframeElement);
    $$invalidate(3, iframeElement.srcdoc = workStore.get("snapshot").content, iframeElement);
    $$invalidate(4, iframeTop = iframeElement.getBoundingClientRect().y);
    await new Promise((res2) => {
      setTimeout(res2, 100);
    });
    const win = iframeElement.contentWindow;
    const doc = win.document;
    const el = doc.documentElement;
    async.map(el.querySelectorAll("link[rel=stylesheet]"), function(link, callback) {
      const img = doc.createElement("img");
      img.onerror = function() {
        callback();
      };
      img.src = link.href;
    }, (err, res2) => {
      $$invalidate(5, loadingSrcDoc = false);
    });
  }
  async function fetchSieveSnapshot() {
    if (!iframeElement) {
      await new Promise((res2) => {
        setTimeout(res2, 100);
      });
    }
    if (workStore.get("snapshot")) {
      await loadSrcDoc();
      return;
    }
    if (!workStore.get("err") || !workStore.get("snapshot_id")) {
      $$invalidate(3, iframeElement.srcdoc = "", iframeElement);
      $$invalidate(4, iframeTop = iframeElement.getBoundingClientRect().y);
      console.warn(`invalid work, ${workStore.id}, used for getting the sieve snapshot`);
      return;
    }
    await workStore.fetchScreenshot(sieveStore.id);
    await loadSrcDoc();
  }
  onMount(async () => {
    await fetchSieveSnapshot();
  });
  function iframe_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      iframeElement = $$value;
      $$invalidate(3, iframeElement);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("workStore" in $$props2)
      $$subscribe_workStore($$invalidate(0, workStore = $$props2.workStore));
    if ("sieveStore" in $$props2)
      $$invalidate(1, sieveStore = $$props2.sieveStore);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4) {
      $$invalidate(6, workID = $workStore.id);
    }
    if ($$self.$$.dirty & 64) {
      workID && fetchSieveSnapshot();
    }
  };
  return [
    workStore,
    sieveStore,
    $workStore,
    iframeElement,
    iframeTop,
    loadingSrcDoc,
    workID,
    iframe_binding
  ];
}
class Work extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3, create_fragment$3, safe_not_equal, { workStore: 0, sieveStore: 1 });
  }
}
function get_each_context(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[18] = list[i2];
  child_ctx[20] = i2;
  return child_ctx;
}
function create_catch_block(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block(ctx) {
  let h3;
  let t2;
  let div7;
  let div5;
  let div4;
  let div0;
  let show_if = ctx[7].get(ctx[0]);
  let t3;
  let div3;
  let div1;
  let t5;
  let div2;
  let ul;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t6;
  let div6;
  let work;
  let current;
  let if_block = show_if && create_if_block_1(ctx);
  let each_value = ctx[5].models;
  const get_key = (ctx2) => ctx2[18].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block(key, child_ctx));
  }
  work = new Work({
    props: {
      workStore: ctx[7].get(ctx[0]),
      sieveStore: ctx[6]
    }
  });
  return {
    c() {
      h3 = element("h3");
      h3.textContent = `${ctx[6].get("name")} | Monitor`;
      t2 = space();
      div7 = element("div");
      div5 = element("div");
      div4 = element("div");
      div0 = element("div");
      if (if_block)
        if_block.c();
      t3 = space();
      div3 = element("div");
      div1 = element("div");
      div1.textContent = "Logs";
      t5 = space();
      div2 = element("div");
      ul = element("ul");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t6 = space();
      div6 = element("div");
      create_component(work.$$.fragment);
      attr(h3, "class", "pa2");
      set_style(div0, "height", "30%");
      attr(div1, "class", "panel-heading");
      attr(ul, "class", "nav nav-pills nav-stacked ");
      attr(div2, "class", "panel-body pa0 pt1 overflow-scroll");
      set_style(div2, "height", "calc(100% - 40px)");
      attr(div3, "class", "panel panel-default");
      set_style(div3, "height", "70%");
      attr(div4, "class", "flex flex-column-l mr2");
      set_style(div4, "height", "calc(100vh - " + ctx[3] + "px)");
      attr(div5, "class", "w-25");
      attr(div6, "class", "border-right-none w-100 h-100");
      attr(div7, "class", "flex pa2");
    },
    m(target, anchor) {
      insert(target, h3, anchor);
      insert(target, t2, anchor);
      insert(target, div7, anchor);
      append(div7, div5);
      append(div5, div4);
      append(div4, div0);
      if (if_block)
        if_block.m(div0, null);
      append(div4, t3);
      append(div4, div3);
      append(div3, div1);
      append(div3, t5);
      append(div3, div2);
      append(div2, ul);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(ul, null);
      }
      ctx[11](ul);
      ctx[12](div4);
      append(div7, t6);
      append(div7, div6);
      mount_component(work, div6, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 1)
        show_if = ctx2[7].get(ctx2[0]);
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div0, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (dirty & 35) {
        each_value = ctx2[5].models;
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, ul, destroy_block, create_each_block, null, get_each_context);
      }
      if (!current || dirty & 8) {
        set_style(div4, "height", "calc(100vh - " + ctx2[3] + "px)");
      }
      const work_changes = {};
      if (dirty & 1)
        work_changes.workStore = ctx2[7].get(ctx2[0]);
      work.$set(work_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(work.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(work.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(h3);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(div7);
      if (if_block)
        if_block.d();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      ctx[11](null);
      ctx[12](null);
      destroy_component(work);
    }
  };
}
function create_if_block_1(ctx) {
  let error;
  let current;
  error = new Error$1({
    props: {
      workStore: ctx[7].get(ctx[0])
    }
  });
  return {
    c() {
      create_component(error.$$.fragment);
    },
    m(target, anchor) {
      mount_component(error, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const error_changes = {};
      if (dirty & 1)
        error_changes.workStore = ctx2[7].get(ctx2[0]);
      error.$set(error_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(error.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(error.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(error, detaching);
    }
  };
}
function create_if_block$2(ctx) {
  let span;
  let t_value = ctx[18].get("err").code + "";
  let t;
  return {
    c() {
      span = element("span");
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 32 && t_value !== (t_value = ctx2[18].get("err").code + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_each_block(key_1, ctx) {
  let li;
  let a;
  let div;
  let span;
  let t0_value = formatTimeV2(ctx[18].get("ts"), false, true) + "";
  let t0;
  let t1;
  let br;
  let t2;
  let show_if = ctx[18].get("err");
  let a_href_value;
  let t3;
  let mounted;
  let dispose;
  let if_block = show_if && create_if_block$2(ctx);
  function click_handler2(...args) {
    return ctx[10](ctx[18], ...args);
  }
  return {
    key: key_1,
    first: null,
    c() {
      li = element("li");
      a = element("a");
      div = element("div");
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      br = element("br");
      t2 = space();
      if (if_block)
        if_block.c();
      t3 = space();
      toggle_class(div, "error", ctx[0] !== ctx[18].id && !!ctx[18].get("err"));
      attr(a, "href", a_href_value = "#" + (ctx[1] + "?work=" + ctx[18].id));
      attr(li, "role", "presentation");
      toggle_class(li, "active", ctx[0] === ctx[18].id);
      toggle_class(li, "disabled", !ctx[18].get("err"));
      this.first = li;
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, a);
      append(a, div);
      append(div, span);
      append(span, t0);
      append(div, t1);
      append(div, br);
      append(div, t2);
      if (if_block)
        if_block.m(div, null);
      append(li, t3);
      if (!mounted) {
        dispose = listen(a, "click", click_handler2);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 32 && t0_value !== (t0_value = formatTimeV2(ctx[18].get("ts"), false, true) + ""))
        set_data(t0, t0_value);
      if (dirty & 32)
        show_if = ctx[18].get("err");
      if (show_if) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block$2(ctx);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 33) {
        toggle_class(div, "error", ctx[0] !== ctx[18].id && !!ctx[18].get("err"));
      }
      if (dirty & 34 && a_href_value !== (a_href_value = "#" + (ctx[1] + "?work=" + ctx[18].id))) {
        attr(a, "href", a_href_value);
      }
      if (dirty & 33) {
        toggle_class(li, "active", ctx[0] === ctx[18].id);
      }
      if (dirty & 32) {
        toggle_class(li, "disabled", !ctx[18].get("err"));
      }
    },
    d(detaching) {
      if (detaching)
        detach(li);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function create_pending_block(ctx) {
  let loader;
  let current;
  loader = new Loader({});
  return {
    c() {
      create_component(loader.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
    }
  };
}
function create_fragment$2(ctx) {
  let await_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block,
    then: create_then_block,
    catch: create_catch_block,
    value: 17,
    blocks: [, , ,]
  };
  handle_promise(ctx[8], info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function instance$2($$self, $$props, $$invalidate) {
  let $worksStore;
  let { sieveID } = $$props;
  let { workID } = $$props;
  let { basePath } = $$props;
  let el;
  let elTop = 0;
  let workListElem;
  const sieveStore = new Model$2.Sieve({ "id": sieveID });
  let worksStore = new Model$2.Works(null, { sieve: sieveStore });
  component_subscribe($$self, worksStore, (value) => $$invalidate(5, $worksStore = value));
  let worksFetched;
  let worksFetchPromise = new Promise((res2, rej) => {
    worksFetched = res2;
  });
  async function fetchWorks() {
    await sieveStore.fetch();
    await worksStore.fetch({ reset: true });
    if (!workID) {
      $$invalidate(0, workID = worksStore.at(0).id);
    }
    worksFetched(true);
  }
  fetchWorks();
  onMount(async () => {
    await worksFetchPromise;
    const selectedItemElem = workListElem.querySelector("li.active");
    if (selectedItemElem) {
      selectedItemElem.scrollIntoView({ block: "nearest", inline: "nearest" });
    }
    $$invalidate(3, elTop = el.getBoundingClientRect().top);
  });
  const click_handler2 = (work, e) => {
    $$invalidate(0, workID = work.id);
  };
  function ul_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      workListElem = $$value;
      $$invalidate(4, workListElem);
    });
  }
  function div4_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(2, el);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("sieveID" in $$props2)
      $$invalidate(9, sieveID = $$props2.sieveID);
    if ("workID" in $$props2)
      $$invalidate(0, workID = $$props2.workID);
    if ("basePath" in $$props2)
      $$invalidate(1, basePath = $$props2.basePath);
  };
  return [
    workID,
    basePath,
    el,
    elTop,
    workListElem,
    $worksStore,
    sieveStore,
    worksStore,
    worksFetchPromise,
    sieveID,
    click_handler2,
    ul_binding,
    div4_binding
  ];
}
class List extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2, create_fragment$2, safe_not_equal, { sieveID: 9, workID: 0, basePath: 1 });
  }
}
function create_else_block$1(ctx) {
  let error404;
  let current;
  error404 = new Error404({ props: { useLayout: false } });
  return {
    c() {
      create_component(error404.$$.fragment);
    },
    m(target, anchor) {
      mount_component(error404, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(error404.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(error404.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(error404, detaching);
    }
  };
}
function create_if_block$1(ctx) {
  let list;
  let current;
  list = new List({
    props: {
      sieveID: ctx[0].sieveID,
      workID: ctx[1],
      basePath: ctx[2]
    }
  });
  return {
    c() {
      create_component(list.$$.fragment);
    },
    m(target, anchor) {
      mount_component(list, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const list_changes = {};
      if (dirty & 1)
        list_changes.sieveID = ctx2[0].sieveID;
      if (dirty & 2)
        list_changes.workID = ctx2[1];
      if (dirty & 4)
        list_changes.basePath = ctx2[2];
      list.$set(list_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(list.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(list.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(list, detaching);
    }
  };
}
function create_default_slot(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$1, create_else_block$1];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    return 0;
  }
  current_block_type_index = select_block_type();
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if_block.p(ctx2, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_extra_slot(ctx) {
  let topbar;
  let current;
  topbar = new Topbar$1({ props: { title: "Check Logs" } });
  return {
    c() {
      create_component(topbar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(topbar, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(topbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(topbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(topbar, detaching);
    }
  };
}
function create_fragment$1(ctx) {
  let layout;
  let current;
  layout = new Layout({
    props: {
      renderDefaultToolbar: true,
      contentClass: "works",
      $$slots: {
        extra: [create_extra_slot],
        default: [create_default_slot]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(layout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(layout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const layout_changes = {};
      if (dirty & 23) {
        layout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layout.$set(layout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(layout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(layout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(layout, detaching);
    }
  };
}
function instance$1($$self, $$props, $$invalidate) {
  let $querystring;
  let $location;
  component_subscribe($$self, querystring, ($$value) => $$invalidate(3, $querystring = $$value));
  component_subscribe($$self, location$1, ($$value) => $$invalidate(2, $location = $$value));
  let { params: params2 = {} } = $$props;
  Api.setIdentityId(params2.team == 0 ? null : params2.team);
  let workID;
  if ($querystring) {
    const searchParams = new URLSearchParams($querystring);
    workID = searchParams.has("work") && searchParams.get("work");
  }
  $$self.$$set = ($$props2) => {
    if ("params" in $$props2)
      $$invalidate(0, params2 = $$props2.params);
  };
  return [params2, workID, $location];
}
class Works extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1, create_fragment$1, safe_not_equal, { params: 0 });
  }
}
var AppExt_svelte_svelte_type_style_lang = "";
function create_else_block(ctx) {
  let t;
  return {
    c() {
      t = text("Loading...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block(ctx) {
  let router;
  let current;
  router = new Router({ props: { routes: ctx[3] } });
  return {
    c() {
      create_component(router.$$.fragment);
    },
    m(target, anchor) {
      mount_component(router, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(router.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(router.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(router, detaching);
    }
  };
}
function create_fragment(ctx) {
  let div2;
  let t1;
  let current_block_type_index;
  let if_block;
  let t2;
  let a;
  let current;
  const if_block_creators = [create_if_block, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[1])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div2 = element("div");
      div2.innerHTML = `<div class="xmsg" style="display:inline-block;"></div> 
  <div class="xerror" style="display:inline-block;"></div>`;
      t1 = space();
      if_block.c();
      t2 = space();
      a = element("a");
      a.textContent = "Get Help";
      attr(div2, "id", "msg");
      attr(div2, "class", "container-fluid xmsgbox");
      set_style(div2, "width", "100%");
      attr(a, "class", "btn btn-danger xbtn-help xbtn-default");
      attr(a, "href", "https://distill.io/help/contact");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      ctx[7](div2);
      insert(target, t1, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, t2, anchor);
      insert(target, a, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(t2.parentNode, t2);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      ctx[7](null);
      if (detaching)
        detach(t1);
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(a);
    }
  };
}
let theme = "white";
function instance($$self, $$props, $$invalidate) {
  let $user, $$unsubscribe_user = noop, $$subscribe_user = () => ($$unsubscribe_user(), $$unsubscribe_user = subscribe(user, ($$value) => $$invalidate(8, $user = $$value)), user);
  $$self.$$.on_destroy.push(() => $$unsubscribe_user());
  let { labels = new ModelLabel.Labels() } = $$props;
  let { user = new Self() } = $$props;
  $$subscribe_user();
  let loaded = false;
  let elMsg;
  setContext("api", Api.api);
  setContext("user", user);
  setContext("labels", labels);
  setContext("clientId", serviceProxy.clientId);
  const routes = {
    "/settings/:module/": Index_ext,
    "/teams/": Teams,
    "/teams/:id": Team,
    "/usage/:module/": Usage_1,
    "/checks/:team/:sieveID": Works,
    "/w/:team/:module/": Watchlist,
    "/w/:team/:module/:prefix/*": Watchlist,
    "*": Error404
  };
  if (location.hash == "" || location.hash.startsWith("#inbox")) {
    replace$1("/w/0/list/all/");
  }
  instance$1Q.on("users", syncUser);
  var Root = View$1.RoutedRoot.extend({
    actions: {
      "go_back": { fn: "action_go_back" },
      "go_up": { fn: "action_go_up" }
    },
    action_go_back() {
      navBack();
    },
    action_go_up() {
      let path = location.hash.slice(1);
      if (path.endsWith("/")) {
        let parts = path.split("/");
        let newParts = parts.slice(0, parts.length - 2);
        let newPath = newParts.join("/") + "/";
        push$1(newPath);
      } else {
        push$1(path.slice(0, path.lastIndexOf("/") + 1));
      }
    },
    route(path) {
      push$1(`/${path}`);
    }
  });
  let { root = new Root() } = $$props;
  setContext("view:root", root);
  Core$1.Acts.setView(root);
  onMount(async () => {
    Msg.bind(elMsg);
    window.USER = $user;
    await isReady();
    await Promise.all([syncUser()]);
    $$invalidate(1, loaded = true);
  });
  onDestroy(() => {
    instance$1Q.off("users", syncUser);
  });
  function navBack() {
    if (history.length > 1) {
      history.back();
    } else {
      replace$1("/w/0/list/all/");
    }
  }
  async function isReady() {
    return new Promise(async (resolve) => {
      if (await serviceProxy.service.isReady()) {
        if (await serviceProxy.auth.isReady()) {
          resolve();
        } else {
          location.href = serviceProxy.CFG.URL.LOGIN;
        }
      } else {
        serviceProxy.serviceEvents.on("init", resolve);
      }
    });
  }
  async function syncUser() {
    if (await serviceProxy.auth.isLoggedIn()) {
      await user.fetch().catch(async (e) => {
        let tUser = await serviceProxy.store.UserStore.findOne({ id: await serviceProxy.auth.getId() });
        tUser && user.set(tUser);
      });
    }
    let locale = $user.locale || await serviceProxy.store.Prefs.get("locale");
    await loadLang(locale || "en-US");
  }
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elMsg = $$value;
      $$invalidate(2, elMsg);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("labels" in $$props2)
      $$invalidate(4, labels = $$props2.labels);
    if ("user" in $$props2)
      $$subscribe_user($$invalidate(0, user = $$props2.user));
    if ("root" in $$props2)
      $$invalidate(5, root = $$props2.root);
  };
  document.documentElement.setAttribute("theme", theme);
  return [user, loaded, elMsg, routes, labels, root, navBack, div2_binding];
}
class AppExt extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, { labels: 4, user: 0, root: 5, navBack: 6 });
  }
  get labels() {
    return this.$$.ctx[4];
  }
  set labels(labels) {
    this.$$set({ labels });
    flush();
  }
  get user() {
    return this.$$.ctx[0];
  }
  set user(user) {
    this.$$set({ user });
    flush();
  }
  get root() {
    return this.$$.ctx[5];
  }
  set root(root) {
    this.$$set({ root });
    flush();
  }
  get navBack() {
    return this.$$.ctx[6];
  }
}
export { AppExt as default };
